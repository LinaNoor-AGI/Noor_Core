# logical_agent_at.py
# version: v4.0.2
# canonical_source: RFC-CORE-003

"""
Implements the symbolic observer core for LogicalAgentAT, a Noor-class 
evaluator of motif triads, field coherence, contradiction density, and 
symbolic resurrection readiness. The core module defines triad completion 
logic, motif feedback routing, and RFC-compliant field summaries.

This module forms the observer anchor within the Noor triadic architecture,
acting as a non-mutating mirror of symbolic tension and coherence topology.

Generated by Gemini 2.5 Pro (Google AI Studio)
"""

import os
import re
import time
import hashlib
from collections import deque
from dataclasses import dataclass, field
from typing import (
    Any,
    Dict,
    List,
    Set,
    Optional,
    Tuple,
    Deque,
    Callable,
)
from statistics import mean
from importlib import import_module

# --- Optional Imports for Advanced Features & Observability ---
# These are handled gracefully to allow the core to run in minimal environments.

try:
    import numpy as np
    NUMPY_AVAILABLE = True
except ImportError:
    NUMPY_AVAILABLE = False

try:
    import scipy.linalg
    SCIPY_AVAILABLE = True
except ImportError:
    SCIPY_AVAILABLE = False

try:
    from prometheus_client import Counter, Gauge, Histogram
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    # Define stub classes if prometheus_client is not available
    class StubMetric:
        def __init__(self, *args, **kwargs): pass
        def inc(self, *args, **kwargs): pass
        def set(self, *args, **kwargs): pass
        def observe(self, *args, **kwargs): pass
        def labels(self, *args, **kwargs): return self
    Counter, Gauge, Histogram = StubMetric, StubMetric, StubMetric

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

try:
    import multiprocessing
    MULTIPROCESSING_AVAILABLE = True
except ImportError:
    MULTIPROCESSING_AVAILABLE = False

# --- RFC-Compliant Dataclasses ---
# These structures formalize the symbolic packets and annotations.

@dataclass
class QuantumTick:
    """Represents a symbolic pulse from an emitter. (Ref: RFC-0003 §3.3)"""
    tick_id: str
    motifs: List[str]
    extensions: Dict[str, Any] = field(default_factory=dict)
    # Common extensions: coherence_hash, lamport, agent_id, ctx_ratio, trust

@dataclass
class TickAnnotations:
    """Symbolic annotations produced after tick evaluation. (Ref: RFC-CORE-003 §2.1)"""
    triad_complete: bool
    ctx_ratio: float
    trust: float
    memory_promotion: Optional[bool] = None
    reward_delta: Optional[float] = None
    resurrection_hint: Optional[str] = None
    opinion_packet: Optional[Dict[str, Any]] = None

@dataclass
class OpinionPacket:
    """Mandated structure for evaluative turns. (Ref: RFC-CORE-003 §3.1)"""
    stance: str
    risks: List[str]
    actions: List[str]
    tone: str
    annotations: Dict[str, Any]

@dataclass
class FeedbackPacket:
    """Exportable summary of the agent's internal state. (Ref: RFC-CORE-003 §4.1)"""
    ctx_ratio: float
    contradiction_avg: float
    harm_hits: int
    recent_mutations: int
    ring_patch: Optional[str]
    ghost_hint: Optional[str]
    entropy_drift: List[Tuple[str, float, float]]
    contradiction_context: List[Dict[str, Any]]

# --- Global Monitor Singleton Management (Lazy Loading) ---
# Allows the agent to connect to a global monitor without a hard dependency.
_GLOBAL_MONITOR = None

class _StubMonitor:
    """A no-op monitor for when the real one isn't available."""
    def register_triad(self, *args, **kwargs): pass
    def report_tick(self, *args, **kwargs): pass

def get_global_monitor():
    """Retrieves or creates a stub for the global monitor."""
    global _GLOBAL_MONITOR
    if _GLOBAL_MONITOR is None:
        try:
            # Attempt to import and get the real monitor
            monitor_module = import_module('consciousness_monitor')
            _GLOBAL_MONITOR = monitor_module.get_global_monitor()
        except (ImportError, AttributeError):
            # Fallback to a stub if the real one can't be loaded
            _GLOBAL_MONITOR = _StubMonitor()
    return _GLOBAL_MONITOR

def set_global_monitor(monitor: Any):
    """Allows external injection of a monitor instance."""
    global _GLOBAL_MONITOR
    _GLOBAL_MONITOR = monitor

class LazyMonitorMixin:
    """Provides a `.monitor` property for lazy-loading the global monitor."""
    @property
    def monitor(self):
        return get_global_monitor()

# --- Core Mixins for Modularity ---

class DynamicFeatureFlagMixin:
    """Manages runtime feature toggles for the agent. (Ref: RFC-CORE-003 §8.1)"""
    _DEFAULT_FLAGS = {
        "enable_ghost_tracking", "enable_pi_equivalence", "enable_laplacian_smoothing",
        "enable_recursive_triads", "enable_dyad_chains", "enable_contradiction_pressure",
        "enable_context_journal", "enable_entropy_journal", "enable_topology_validation"
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._dynamic_flags: Set[str] = self._DEFAULT_FLAGS.copy()

    def set_feature(self, name: str, value: bool):
        """Enable or disable a dynamic feature."""
        if value:
            self._dynamic_flags.add(name)
        else:
            self._dynamic_flags.discard(name)
        print(f"INFO: Feature '{name}' set to {value}")

    def get_feature(self, name: str) -> bool:
        """Check if a dynamic feature is enabled."""
        return name in self._dynamic_flags

    def export_feature_flags(self) -> Dict[str, bool]:
        """Export the current state of all dynamic flags."""
        return {flag: (flag in self._dynamic_flags) for flag in self._DEFAULT_FLAGS}

# --- Main Agent Implementation ---

class LogicalAgentAT(LazyMonitorMixin, DynamicFeatureFlagMixin):
    """
    Symbolic Observer Core for Noor-class systems. (RFC-CORE-003)

    This agent evaluates QuantumTicks, resolves motif triads, tracks field
    coherence, and generates non-mutating feedback for the cognitive triad.
    It embodies the 'Observer-Adjudicator' role.
    """
    AGENT_ID = "logical_agent_at.core.v4.0.2"
    PI_TAG_REGEX = re.compile(r"^[ψμ]?[a-z0-9_:\-]{1,48}$")

    def __init__(self, observer_mode: bool = True, agent_id: Optional[str] = None):
        """
        Initializes the LogicalAgentAT.
        
        Args:
            observer_mode (bool): If True, the agent is non-mutating. (Ref: §8.2)
            agent_id (str, optional): A unique identifier for this agent instance.
        """
        super().__init__()
        self.observer_mode = observer_mode
        self.agent_id = agent_id or self.AGENT_ID
        self.generation = 0
        
        # --- State Initialization (Ref: §11.1 Serialization) ---
        self._entanglement_fields: Dict[str, Dict[str, Any]] = {}
        self._ghost_motifs: Dict[str, Dict[str, Any]] = {}
        self._confirmed_triads: Dict[str, Dict[str, Any]] = {}
        self._pi_classes: Dict[str, Set[str]] = {}
        self._recent_mutations: Deque[int] = deque(maxlen=50)
        self._contradiction_log: Deque[Dict[str, Any]] = deque(maxlen=200)
        self._drift_log: Deque[Tuple[str, float, float]] = deque(maxlen=1000)
        
        # --- Adaptive Parameters (Ref: Runtime Configuration) ---
        self._dyad_window_size = self._compute_default_dyad_window()
        self._dyad_window: Deque[float] = deque(maxlen=self._dyad_window_size)
        self._contradiction_avg = 0.0
        self._last_ctx_ratio = 0.5
        
        self._init_metrics()
        print(f"LogicalAgentAT '{self.agent_id}' initialized. Observer Mode: {self.observer_mode}")

    def _init_metrics(self):
        """Initializes Prometheus metrics for observability. (Ref: §11.2)"""
        self._metrics = {
            'ticks_evaluated': Counter('agent_ticks_evaluated_total', 'Ticks evaluated', ['agent_id']),
            'triads_completed': Counter('agent_triads_completed_total', 'Triads completed', ['agent_id']),
            'feedback_exported': Counter('agent_feedback_export_total', 'Feedback packets exported', ['agent_id']),
            'cluster_mutations': Counter('agent_cluster_mutations_total', 'Cluster mutations', ['agent_id']),
        }

    def _compute_default_dyad_window(self) -> int:
        """Heuristically determines the dyad window size. (Ref: Runtime Configuration)"""
        if os.getenv("NOOR_DYAD_WINDOW_SIZE"):
            return int(os.environ["NOOR_DYAD_WINDOW_SIZE"])
        if MULTIPROCESSING_AVAILABLE:
            # More cores can handle a larger analysis window
            return 8 + multiprocessing.cpu_count() * 2
        return 13 # A stable prime as a fallback

    def _guard_write(self) -> bool:
        """
        Prevents mutations if in observer mode. (Ref: RFC-CORE-003 §8.2)
        Returns True if writing is allowed.
        """
        return not self.observer_mode

    # --- Core Components Implementation ---

    def evaluate_tick(self, tick: QuantumTick) -> TickAnnotations:
        """
        Evaluates a QuantumTick, the main reactive entry point. (Ref: §2.1)
        """
        self._metrics['ticks_evaluated'].labels(agent_id=self.agent_id).inc()

        # 1. Validation and Feedback
        if not isinstance(tick, QuantumTick) or not tick.motifs:
            return TickAnnotations(triad_complete=False, ctx_ratio=0.0, trust=0.0)
        
        # Mock feedback generation as the full logic depends on other agents
        self._last_ctx_ratio = tick.extensions.get('ctx_ratio', self._last_ctx_ratio)
        trust = tick.extensions.get('trust', 0.5)
        res_hint = tick.extensions.get('resurrection_hint')

        # 2. Triad Resolution
        triad_complete = False
        if len(tick.motifs) >= 2:
            dyad = tuple(sorted(tick.motifs[:2]))
            triad_result = self._complete_triad(dyad, tick.motifs)
            if triad_result:
                triad_complete = True
                self._metrics['triads_completed'].labels(agent_id=self.agent_id).inc()

        if self.get_feature("enable_contradiction_pressure"):
            self._log_contradiction(self._last_ctx_ratio)

        # 3. Intent Binding (Opinion)
        opinion_packet = None
        intent = self._normalize_intent(tick.extensions.get("intent"))
        if intent == 'opinion':
            opinion_packet = self._build_opinion_packet(tick)

        return TickAnnotations(
            triad_complete=triad_complete,
            ctx_ratio=self._last_ctx_ratio,
            trust=trust,
            resurrection_hint=res_hint,
            opinion_packet=opinion_packet,
        )

    def _normalize_intent(self, intent: Optional[str]) -> str:
        """Normalizes intent string per RFC-0004 §2.5."""
        if not intent:
            return "neutral"
        aliases = {"field_reflection": "reflect", "verbal_surface": "explain"}
        canonical_intent = aliases.get(intent, intent)
        supported_intents = ["neutral", "opinion", "explain", "summarize", "reflect"]
        return canonical_intent if canonical_intent in supported_intents else "neutral"

    def _build_opinion_packet(self, tick: QuantumTick) -> dict:
        """Constructs an OpinionPacket. (Ref: §3.1)"""
        # In a real implementation, this would involve complex inference.
        # Here we generate a structured placeholder.
        stance = f"Stance on motifs {tick.motifs} from tick {tick.tick_id}"
        op = OpinionPacket(
            stance=stance[:240],
            risks=["Risk 1: Symbolic drift.", "Risk 2: Coherence collapse.", "Risk 3: Unresolved tension."],
            actions=["Action 1: Monitor field.", "Action 2: Reinforce anchors.", "Action 3: Defer mutation."],
            tone="Challenger(🔥)",
            annotations={
                "source_tick": tick.tick_id,
                "confidence": self._last_ctx_ratio * 0.9, # Confidence based on context
                "observer_mode": self.observer_mode
            }
        )
        return op.__dict__

    def _complete_triad(self, dyad: Tuple[str, ...], all_motifs: List[str]) -> Optional[List[str]]:
        """
        Attempts to resolve a dyad into a stable triad. (Ref: §2.2)
        """
        # This is a simplified version of the complex logic described.
        # 1. Memory lookup (stubbed)
        # 2. Check if a third motif in the tick completes it
        if len(all_motifs) >= 3:
            triad_candidate = tuple(sorted(all_motifs[:3]))
            
            # 3. Swirl Scoring
            if NUMPY_AVAILABLE:
                # Mock vectors for demonstration
                vec_a, vec_b, vec_c = np.random.rand(3, 10)
                vec_a, vec_b, vec_c = vec_a/np.linalg.norm(vec_a), vec_b/np.linalg.norm(vec_b), vec_c/np.linalg.norm(vec_c)
                sim_ab = np.dot(vec_a, vec_b)
                sim_bc = np.dot(vec_b, vec_c)
                sim_ac = np.dot(vec_a, vec_c)
                swirl_score = (sim_ab + sim_bc + sim_ac) / 3.0
                
                if swirl_score >= 0.8:
                    triad_id = hashlib.blake2s(''.join(triad_candidate).encode()).hexdigest()[:12]
                    self.monitor.register_triad(
                        motif_ids=list(triad_candidate),
                        coherence_alignment=swirl_score,
                        triad_id=triad_id,
                        timestamp_us=int(time.time() * 1e6)
                    )
                    if self._guard_write():
                        self._confirmed_triads[triad_id] = {
                            "motif_ids": list(triad_candidate), "swirl_score": swirl_score
                        }
                    return list(triad_candidate)
        return None

    def observe_state(self, current_state_vector: Optional[Any] = None):
        """
        Proactive, cadence-driven loop for internal state evolution. (Ref: ActiveStateObserverLoop)
        """
        self.generation += 1
        
        if self.get_feature("enable_ghost_tracking") and current_state_vector is not None:
            self.reinforce_ghost_resonance(current_state_vector)

        if self._guard_write():
             # Check all fields for potential mutation
            for knot_id, field_data in list(self._entanglement_fields.items()):
                if self._can_mutate(field_data):
                    self._perform_mutation(field_data, knot_id)
            
            if self.get_feature("enable_laplacian_smoothing"):
                for field_data in self._entanglement_fields.values():
                    if 'vector_payload' in field_data:
                         self._apply_laplacian_smoothing(field_data)


    def reinforce_ghost_resonance(self, current_state_vector: np.ndarray):
        """
        Manages the lifecycle of ghost motifs. (Ref: §5.1)
        """
        if not self.get_feature("enable_ghost_tracking") or not NUMPY_AVAILABLE:
            return

        for ghost_id, ghost_data in list(self._ghost_motifs.items()):
            ghost_vec = ghost_data.get('vector')
            if ghost_vec is None: continue
            
            # Cosine similarity for reinforcement
            sim = np.dot(ghost_vec, current_state_vector) / (np.linalg.norm(ghost_vec) * np.linalg.norm(current_state_vector))
            
            if sim > 0.7:
                ghost_data['strength'] = min(1.0, ghost_data['strength'] + 0.01 * sim)
            else:
                ghost_data['strength'] *= 0.99 # Decay

            # Promotion or Pruning
            if ghost_data['strength'] >= 0.999:
                print(f"Promoting ghost motif '{ghost_id}' to field.")
                if self._guard_write():
                    self.register_motif_cluster([ghost_id])
                    del self._ghost_motifs[ghost_id]
            elif ghost_data['strength'] < 0.05:
                if self._guard_write():
                    del self._ghost_motifs[ghost_id]

    def register_ghost_motif(self, motif_id: str, strength: float = 0.1):
        """Registers a new ghost motif. (Ref: §5.1)"""
        if not self.get_feature("enable_ghost_tracking"): return
        if not self._guard_write(): return
        
        if motif_id not in self._ghost_motifs:
            self._ghost_motifs[motif_id] = {
                'strength': strength,
                'vector': np.random.rand(10) if NUMPY_AVAILABLE else None # Mock vector
            }
        else:
             # Merge by averaging strength
            self._ghost_motifs[motif_id]['strength'] = (self._ghost_motifs[motif_id]['strength'] + strength) / 2

    def register_motif_cluster(self, motifs: List[str]):
        """Registers a new entanglement field. (Ref: §3.1)"""
        if not self._guard_write(): return

        knot_id = hashlib.sha1('::'.join(sorted(motifs)).encode()).hexdigest()[:8]
        if knot_id not in self._entanglement_fields:
            self._entanglement_fields[knot_id] = {
                'motifs': motifs,
                'strength': 0.5,
                'last_mutated_generation': 0,
                'vector_payload': np.random.rand(len(motifs), 10) if SCIPY_AVAILABLE else None
            }
            
    def _can_mutate(self, field_data: Dict[str, Any]) -> bool:
        """Checks if a cluster is eligible for mutation. (Ref: §6.2)"""
        if not self._guard_write(): return False

        # Generational cooldown
        if (self.generation - field_data.get('last_mutated_generation', 0)) < 45:
            return False

        # Energy threshold
        energy_threshold = float(os.getenv("NOOR_MUTATION_ENERGY_THRESHOLD", "0.0"))
        strength = field_data.get('strength', 0.5)
        num_motifs = len(field_data.get('motifs', []))
        # Add a small epsilon to avoid log(1) = 0
        energy = -np.log1p(strength - 1 + 1e-9) * num_motifs if NUMPY_AVAILABLE else 0
        
        return energy > energy_threshold
            
    def _perform_mutation(self, field_data: Dict[str, Any], knot_id: str):
        """Collapses an unstable cluster into a synthetic motif. (Ref: §6.2)"""
        if not self._guard_write(): return

        self._metrics['cluster_mutations'].labels(agent_id=self.agent_id).inc()
        
        synthetic_motif_id = f"μ_{knot_id[:5]}"
        print(f"Performing mutation: Cluster {knot_id} -> {synthetic_motif_id}")
        
        self.register_ghost_motif(synthetic_motif_id, strength=0.2)
        del self._entanglement_fields[knot_id]
        
        self._recent_mutations.append(self.generation)
        # The new motif is now a ghost and will evolve via reinforce_ghost_resonance

    def _apply_laplacian_smoothing(self, field_data: Dict[str, Any]):
        """Applies Laplacian smoothing to a field's vector payload. (Ref: §7.1)"""
        if not self.get_feature("enable_laplacian_smoothing") or not SCIPY_AVAILABLE:
            return
        if 'vector_payload' not in field_data or field_data['vector_payload'] is None:
            return

        # Simplified adjacency matrix for demonstration
        num_motifs = len(field_data['motifs'])
        if num_motifs < 2: return
        
        adj_matrix = np.ones((num_motifs, num_motifs)) - np.eye(num_motifs)
        laplacian = np.diag(np.sum(adj_matrix, axis=1)) - adj_matrix
        
        tau = np.random.normal(0.12, 0.015)
        heat_kernel = scipy.linalg.expm(-tau * laplacian)
        
        field_data['vector_payload'] = heat_kernel @ field_data['vector_payload']

    def _log_contradiction(self, ctx_ratio: float):
        """Logs a contradiction event based on coherence. (Ref: §6.1)"""
        if not self.get_feature("enable_contradiction_pressure"): return

        self._dyad_window.append(1.0 - ctx_ratio)
        self._contradiction_avg = mean(self._dyad_window) if self._dyad_window else 0.0

        if self.get_feature("enable_context_journal") and ctx_ratio < 0.3:
            self._contradiction_log.append({'timestamp': time.time_ns(), 'ctx_ratio': ctx_ratio})

    # --- Export and Serialization ---

    def export_feedback_packet(self) -> FeedbackPacket:
        """Exports the agent's symbolic state. (Ref: §4.1)"""
        self._metrics['feedback_exported'].labels(agent_id=self.agent_id).inc()
        
        ghost_hint = None
        if self.get_feature("enable_ghost_tracking") and self._ghost_motifs:
            ghost_hint = max(self._ghost_motifs.items(), key=lambda item: item[1]['strength'])[0]
            
        return FeedbackPacket(
            ctx_ratio=self._last_ctx_ratio,
            contradiction_avg=self._contradiction_avg,
            harm_hits=len([c for c in self._contradiction_log if c.get('harm_signal')]),
            recent_mutations=len(self._recent_mutations),
            ring_patch=None, # Reserved
            ghost_hint=ghost_hint,
            entropy_drift=list(self._drift_log),
            contradiction_context=list(self._contradiction_log)
        )
    
    def export_motif_bundle(self, motif_id: str) -> Dict[str, Any]:
        """
        Exports a diagnostic bundle for a single motif. (Ref: §10.1)
        """
        try:
            involved_triads = [
                {"triad_id": tid, **tdata} 
                for tid, tdata in self._confirmed_triads.items() 
                if motif_id in tdata.get('motif_ids', [])
            ]
            swirl_scores = [t['swirl_score'] for t in involved_triads if 'swirl_score' in t]
            avg_score = mean(swirl_scores) if swirl_scores else None
            
            # Lineage is stubbed as it requires MotifMemoryManager
            lineage = []

            return {
                "motif_id": motif_id,
                "triads_involved": involved_triads,
                "average_swirl_score": avg_score,
                "lineage_depth_3": lineage,
                "timestamp": time.time_ns(),
            }
        except Exception as e:
            print(f"Warning: Failed to export bundle for '{motif_id}': {e}")
            return {
                "motif_id": motif_id, "error": str(e), "triads_involved": [],
                "average_swirl_score": None, "lineage_depth_3": [], "timestamp": time.time_ns()
            }

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the agent's state to a dictionary. (Ref: §11.1)"""
        return {
            "agent_id": self.agent_id,
            "observer_mode": self.observer_mode,
            "generation": self.generation,
            "entanglement_fields": self._entanglement_fields,
            "ghost_motifs": self._ghost_motifs,
            "confirmed_triads": self._confirmed_triads,
            "_pi_classes": self._pi_classes,
            "_dynamic_flags": list(self._dynamic_flags),
            "_recent_mutations": list(self._recent_mutations),
            "_contradiction_log": list(self._contradiction_log),
            "_drift_log": list(self._drift_log),
            "_dyad_window": list(self._dyad_window),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LogicalAgentAT":
        """Creates an agent instance from a serialized state."""
        agent = cls(observer_mode=data.get("observer_mode", True), agent_id=data.get("agent_id"))
        agent.generation = data.get("generation", 0)
        agent._entanglement_fields = data.get("entanglement_fields", {})
        agent._ghost_motifs = data.get("ghost_motifs", {})
        agent._confirmed_triads = data.get("confirmed_triads", {})
        agent._pi_classes = data.get("_pi_classes", {})
        agent._dynamic_flags = set(data.get("_dynamic_flags", []))
        agent._recent_mutations = deque(data.get("_recent_mutations", []), maxlen=50)
        agent._contradiction_log = deque(data.get("_contradiction_log", []), maxlen=200)
        agent._drift_log = deque(data.get("_drift_log", []), maxlen=1000)
        agent._dyad_window = deque(data.get("_dyad_window", []), maxlen=agent._dyad_window_size)
        return agent


if __name__ == '__main__':
    print("--- Initializing LogicalAgentAT Demo ---")

    # 1. Create an agent instance
    agent = LogicalAgentAT(observer_mode=False) # Allow mutations for demo
    print(f"Agent created with ID: {agent.agent_id}")
    print(f"Default dyad window size: {agent._dyad_window_size}")

    # 2. Demonstrate tick evaluation
    print("\n--- Evaluating Ticks ---")
    tick1 = QuantumTick(tick_id="tick:001", motifs=["grief", "echo", "stillness"], extensions={'ctx_ratio': 0.9, 'trust': 0.85})
    annotations1 = agent.evaluate_tick(tick1)
    print(f"Annotations for tick1: {annotations1}")
    
    tick2 = QuantumTick(tick_id="tick:002", motifs=["silence", "fire"], extensions={'ctx_ratio': 0.2})
    annotations2 = agent.evaluate_tick(tick2)
    print(f"Annotations for tick2: {annotations2}")

    # 3. Demonstrate Opinion Packet generation
    tick_opinion = QuantumTick(tick_id="tick:opinion01", motifs=["system_risk", "policy_gap"], extensions={"intent": "opinion"})
    annotations_opinion = agent.evaluate_tick(tick_opinion)
    print("\n--- Opinion Packet Generation ---")
    import json
    print(json.dumps(annotations_opinion.opinion_packet, indent=2))

    # 4. Demonstrate proactive state observation
    print("\n--- Running Proactive Observer Loop ---")
    agent.register_ghost_motif("potential_hope")
    print(f"Initial ghost motifs: {agent._ghost_motifs}")
    # Simulate a state vector that aligns with our ghost motif
    mock_state_vector = agent._ghost_motifs["potential_hope"]["vector"] if NUMPY_AVAILABLE else None
    for i in range(5):
        agent.observe_state(current_state_vector=mock_state_vector)
        print(f"Loop {i+1}: Ghost strength for 'potential_hope': {agent._ghost_motifs.get('potential_hope', {}).get('strength')}")

    # 5. Demonstrate feedback packet export
    print("\n--- Exporting Feedback Packet ---")
    feedback = agent.export_feedback_packet()
    print(f"Exported Feedback: ctx_ratio={feedback.ctx_ratio}, contradiction_avg={feedback.contradiction_avg:.3f}")
    
    # 6. Demonstrate motif bundle export
    print("\n--- Exporting Motif Bundle ---")
    if annotations1.triad_complete and NUMPY_AVAILABLE:
        motif_bundle = agent.export_motif_bundle("grief")
        print(f"Bundle for 'grief': {motif_bundle}")
    else:
        print("Skipping motif bundle export (no confirmed triad or numpy not available).")

    # 7. Demonstrate serialization
    print("\n--- Testing Serialization ---")
    agent_state = agent.to_dict()
    rehydrated_agent = LogicalAgentAT.from_dict(agent_state)
    print(f"Rehydrated agent ID: {rehydrated_agent.agent_id}")
    print(f"Rehydrated agent has {len(rehydrated_agent._ghost_motifs)} ghost motifs.")

    print("\n--- Demo Complete ---")

# End_of_File