# -*- coding: utf-8 -*-
#
# Copyright (C) 2024-2025 — Noor Research Foundation, Inc.
#
# MIT License
#
# SoundCloud: https://soundcloud.com/mathew-j-edlund/
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# "Noor" is a trademark of the Noor Research Foundation, Inc.
#
# Regenerated by: Google Gemini Pro 1.5
# Date: 2024-08-16
#
# Regeneration Token:
#   RFC-CORE-003:v1.2.2|app.logical_agent_at:v4.2.2b|2024-08-16T12:00:00Z
#
# This file provides a monitor patch for LogicalAgentAT, adding Prometheus-based
# observability hooks into its symbolic evaluation and field resolution lifecycle.
# It is designed to be optionally applied, allowing the core agent to function
# without a hard dependency on monitoring infrastructure.
#
# The patch respects the observer integrity constraints defined in RFC-CORE-003,
# ensuring that monitoring does not introduce mutations or alter the agent's
# symbolic behavior.
#

import time
import logging
from functools import wraps
from typing import Any, Callable

# PDP-0001 §4.5: Graceful Degradation for optional dependencies.
# RFC-CORE-003 §11.2: If prometheus_client is not installed, all metrics default to stubs.
try:
    from prometheus_client import Counter, Gauge, Histogram
except ImportError:
    logging.warning(
        "prometheus_client not found. "
        "LogicalAgentAT metrics will be disabled. "
        "Install with: pip install prometheus_client"
    )
    # Define stub classes that mimic the Prometheus client API but do nothing.
    class _Stub:
        def __init__(self, *args, **kwargs): pass
        def inc(self, *args, **kwargs): pass
        def set(self, *args, **kwargs): pass
        def observe(self, *args, **kwargs): pass
        def collect(self): return []

    Counter, Gauge, Histogram = _Stub, _Stub, _Stub

# Forward declaration for type hinting to avoid circular imports.
class LogicalAgentAT:
    pass

class LogicalAgentMetrics:
    """
    A container for all Prometheus metrics related to LogicalAgentAT.
    This structure is aligned with the observability requirements outlined in
    the application specification for `application.logical_agent_at`.
    """
    def __init__(self, agent_id: str):
        self.agent_id = agent_id

        # --- Counters ---
        self.agent_ticks_total = Counter(
            "agent_ticks_total",
            "Total ticks evaluated by LogicalAgentAT",
            ["stage", "agent_id"]
        )
        self.agent_triads_completed_total = Counter(
            "agent_triads_completed_total",
            "Total triads successfully completed by this agent",
            ["agent_id"]
        )
        self.agent_dyad_completions_total = Counter(
            "agent_dyad_completions_total",
            "Total dyad completions from memory or inference",
            ["agent_id"]
        )
        self.agent_ghost_motifs_total = Counter(
            "agent_ghost_motifs_total",
            "Total ghost motifs registered by the agent",
            ["agent_id"]
        )
        self.agent_cluster_mutations_total = Counter(
            "agent_cluster_mutations_total",
            "Total cluster mutations (abstractions) performed",
            ["type", "agent_id"]
        )
        self.agent_topology_conflicts_total = Counter(
            "agent_topology_conflicts_total",
            "Total topology conflicts detected during validation",
            ["agent_id"]
        )
        self.agent_laplacian_calls_total = Counter(
            "agent_laplacian_calls_total",
            "Total calls to Laplacian smoothing function",
            ["agent_id"]
        )
        self.agent_pi_merges_total = Counter(
            "agent_pi_merges_total",
            "Total PI-groupoid equivalence merges",
            ["agent_id"]
        )
        self.agent_feedback_export_total = Counter(
            "agent_feedback_export_total",
            "Number of feedback packets exported",
            ["agent_id"]
        )

        # --- Gauges ---
        self.agent_observer_mode = Gauge(
            "agent_observer_mode",
            "Indicates if the agent is in non-mutating observer mode (1=True, 0=False)",
            ["agent_id"]
        )
        self.agent_dyad_ratio = Gauge(
            "agent_dyad_ratio",
            "Current dyad ratio reflecting contradiction pressure",
            ["agent_id"]
        )
        self.agent_max_fields_dynamic = Gauge(
            "agent_max_fields_dynamic",
            "Dynamically configured maximum number of entanglement fields"
        )
        self.agent_dyad_window_dynamic = Gauge(
            "agent_dyad_window_dynamic",
            "Dynamically configured size of the dyad contradiction window"
        )

        # --- Histogram ---
        self.agent_tick_evaluation_latency_seconds = Histogram(
            "agent_tick_evaluation_latency_seconds",
            "Latency of the tick evaluation loop",
            ["agent_id"]
        )

class LogicalAgentMonitorPatch:
    """
    Applies observability hooks to a LogicalAgentAT instance.

    This patch wraps key methods of the agent to increment Prometheus metrics,
    providing insights into its internal symbolic processing without altering

    the core logic. It follows the lazy-binding and graceful degradation
    principles outlined in RFC-CORE-003.
    """
    def __init__(self, agent: "LogicalAgentAT"):
        """
        Initializes the patch with a target agent instance.

        Args:
            agent: The instance of LogicalAgentAT to be patched.
        """
        self.agent = agent
        self.metrics = LogicalAgentMetrics(agent.agent_id)
        logging.info(f"Monitor patch initialized for LogicalAgentAT '{agent.agent_id}'.")

    def patch(self):
        """
        Applies all monitoring wrappers to the agent's methods.
        This method is idempotent; calling it multiple times has no further effect.
        """
        if hasattr(self.agent, "_monitor_patched") and self.agent._monitor_patched:
            logging.debug("Agent already patched. Skipping.")
            return

        logging.info(f"Applying monitor patch to agent '{self.agent.agent_id}'.")

        # Wrap core methods to capture metrics
        self.agent.evaluate_tick = self._wrap_evaluate_tick(self.agent.evaluate_tick)
        self.agent._complete_triad = self._wrap_complete_triad(self.agent._complete_triad)
        self.agent.register_ghost_motif = self._wrap_register_ghost_motif(self.agent.register_ghost_motif)
        self.agent._perform_mutation = self._wrap_perform_mutation(self.agent._perform_mutation)
        self.agent._apply_laplacian_smoothing = self._wrap_apply_laplacian_smoothing(self.agent._apply_laplacian_smoothing)
        self.agent.register_path_equivalence = self._wrap_register_path_equivalence(self.agent.register_path_equivalence)
        self.agent.export_feedback_packet = self._wrap_export_feedback_packet(self.agent.export_feedback_packet)
        self.agent._log_contradiction = self._wrap_log_contradiction(self.agent._log_contradiction)

        self.agent._monitor_patched = True
        logging.info(f"Monitor patch successfully applied to agent '{self.agent.agent_id}'.")

    def _wrap_evaluate_tick(self, original_method: Callable) -> Callable:
        """Wraps evaluate_tick to measure latency and update gauges."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            start_time = time.monotonic()
            
            # Update gauges that reflect the agent's current state
            self.metrics.agent_observer_mode.labels(agent_id=self.agent.agent_id).set(
                1 if self.agent.observer_mode else 0
            )
            # RFC-CORE-003 §11.3: Update adaptive parameter metrics
            self.metrics.agent_max_fields_dynamic.set(self.agent.max_fields)
            self.metrics.agent_dyad_window_dynamic.set(self.agent.dyad_window_size)
            
            # The contradiction average is 1 - dyad_ratio.
            if self.agent._contradiction_avg is not None:
                self.metrics.agent_dyad_ratio.labels(agent_id=self.agent.agent_id).set(
                    1.0 - self.agent._contradiction_avg
                )

            result = original_method(*args, **kwargs)
            
            latency = time.monotonic() - start_time
            self.metrics.agent_tick_evaluation_latency_seconds.labels(
                agent_id=self.agent.agent_id
            ).observe(latency)
            
            self.metrics.agent_ticks_total.labels(
                stage='evaluated', agent_id=self.agent.agent_id
            ).inc()
            
            return result
        return wrapper

    def _wrap_complete_triad(self, original_method: Callable) -> Callable:
        """Wraps _complete_triad to count triad and dyad completions."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            if result:
                # RFC-CORE-003 §9.2: A completed triad is registered.
                self.metrics.agent_triads_completed_total.labels(
                    agent_id=self.agent.agent_id
                ).inc()
                # A successful triad completion implies a dyad was also completed.
                self.metrics.agent_dyad_completions_total.labels(
                    agent_id=self.agent.agent_id
                ).inc()
            return result
        return wrapper
        
    def _wrap_register_ghost_motif(self, original_method: Callable) -> Callable:
        """Wraps register_ghost_motif to count ghost motif registrations."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_ghost_motifs_total.labels(
                agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper

    def _wrap_perform_mutation(self, original_method: Callable) -> Callable:
        """Wraps _perform_mutation to count cluster mutations (abstractions)."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_cluster_mutations_total.labels(
                type='abstraction', agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper

    def _wrap_apply_laplacian_smoothing(self, original_method: Callable) -> Callable:
        """Wraps _apply_laplacian_smoothing to count calls."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_laplacian_calls_total.labels(
                agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper
        
    def _wrap_register_path_equivalence(self, original_method: Callable) -> Callable:
        """Wraps register_path_equivalence to count PI-groupoid merges."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_pi_merges_total.labels(
                agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper
    
    def _wrap_export_feedback_packet(self, original_method: Callable) -> Callable:
        """Wraps export_feedback_packet to count exports."""
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_feedback_export_total.labels(
                agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper

    def _wrap_log_contradiction(self, original_method: Callable) -> Callable:
        """Wraps _log_contradiction to count topology conflicts."""
        # This function in the core agent is where contradiction pressure is logged.
        @wraps(original_method)
        def wrapper(*args, **kwargs) -> Any:
            result = original_method(*args, **kwargs)
            self.metrics.agent_topology_conflicts_total.labels(
                agent_id=self.agent.agent_id
            ).inc()
            return result
        return wrapper
        
# End_of_file