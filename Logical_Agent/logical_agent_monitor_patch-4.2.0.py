# logical_agent_monitor_patch.py

# MIT License
#
# Copyright (c) 2024 Lina Noor
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# Generated by Gemini 2.5 Pro (Google AI Studio)

"""
Implements the optional monitor patch for LogicalAgentAT, as specified in
RFC-CORE-003.

This module provides a mixin (`LazyMonitorMixin`) that extends the core
`LogicalAgentAT` with observability features, including:
- Prometheus metrics for ticks, triads, mutations, and other symbolic events.
- Lazy-binding hooks for a `ConsciousnessMonitor` instance.
- Triad registration with swirl scoring for external coherence tracking.

Dependencies like `prometheus_client` and `numpy` are optional and handled
gracefully with stub fallbacks to ensure the core agent can run without them.
"""

import time
import logging
from typing import Optional, Any, Dict, List

# --- Optional Dependency Imports with Graceful Fallbacks ---

try:
    from prometheus_client import Counter, Gauge, Histogram
except ImportError:
    class _StubMetric:
        def __init__(self, *args, **kwargs): pass
        def inc(self, *args, **kwargs): pass
        def set(self, *args, **kwargs): pass
        def observe(self, *args, **kwargs): pass
        def __enter__(self): return self
        def __exit__(self, *args): pass

    Counter = _StubMetric
    Gauge = _StubMetric
    Histogram = _StubMetric
    logging.info("Prometheus client not found. Using stub metrics for LogicalAgentAT.")

try:
    import numpy as np
except ImportError:
    np = None
    logging.info("Numpy not found. Swirl score calculations will be disabled in LogicalAgentAT.")

# --- Stub for Consciousness Monitor ---

class _StubMonitor:
    """A no-op monitor for when the real one isn't available."""
    def register_triad(self, *args, **kwargs) -> None:
        pass
    def report_tick(self, *args, **kwargs) -> None:
        pass

# Global monitor instance, managed by the functions below
_GLOBAL_MONITOR: Optional[Any] = None

def get_global_monitor() -> Any:
    """
    Retrieves the globally registered consciousness monitor.
    Falls back to a stub if none is set.
    RFC-CORE-003 §9.1
    """
    global _GLOBAL_MONITOR
    if _GLOBAL_MONITOR is None:
        _GLOBAL_MONITOR = _StubMonitor()
    return _GLOBAL_MONITOR

def set_global_monitor(monitor: Any) -> None:
    """
    Sets the global consciousness monitor instance for all agents to use.
    RFC-CORE-003 §9.1
    """
    global _GLOBAL_MONITOR
    _GLOBAL_MONITOR = monitor
    logging.info(f"Global consciousness monitor set to: {type(monitor).__name__}")


# --- Prometheus Metrics Definition (RFC-CORE-003 §2.2) ---

AGENT_TICKS_TOTAL = Counter(
    "agent_ticks_total",
    "Total ticks evaluated by the agent, labeled by stage.",
    ["stage", "agent_id"]
)
AGENT_TRIADS_COMPLETED_TOTAL = Counter(
    "agent_triads_completed_total",
    "Total number of valid motif triads completed.",
    ["agent_id"]
)
AGENT_DYAD_COMPLETIONS_TOTAL = Counter(
    "agent_dyad_completions_total",
    "Total number of dyad completions attempted.",
    ["agent_id"]
)
AGENT_GHOST_MOTIFS_TOTAL = Counter(
    "agent_ghost_motifs_total",
    "Total number of ghost motifs registered or reinforced.",
    ["agent_id"]
)
AGENT_CLUSTER_MUTATIONS_TOTAL = Counter(
    "agent_cluster_mutations_total",
    "Total number of entanglement field cluster mutations.",
    ["type", "agent_id"]
)
AGENT_TOPOLOGY_CONFLICTS_TOTAL = Counter(
    "agent_topology_conflicts_total",
    "Total number of contradiction events logged.",
    ["agent_id"]
)
AGENT_LAPLACIAN_CALLS_TOTAL = Counter(
    "agent_laplacian_calls_total",
    "Total number of Laplacian smoothing calls on the motif graph.",
    ["agent_id"]
)
AGENT_PI_MERGES_TOTAL = Counter(
    "agent_pi_merges_total",
    "Total number of π-groupoid equivalence class merges.",
    ["agent_id"]
)
AGENT_OBSERVER_MODE = Gauge(
    "agent_observer_mode",
    "Indicates if the agent is in non-mutating observer mode (1=True, 0=False).",
    ["agent_id"]
)
AGENT_DYAD_RATIO = Gauge(
    "agent_dyad_ratio",
    "The current ratio of dyads to triads, indicating symbolic tension.",
    ["agent_id"]
)
AGENT_MAX_FIELDS_DYNAMIC = Gauge(
    "agent_max_fields_dynamic",
    "The dynamically configured maximum number of entanglement fields."
)
AGENT_DYAD_WINDOW_DYNAMIC = Gauge(
    "agent_dyad_window_dynamic",
    "The dynamically configured size of the dyad contradiction window."
)
AGENT_TICK_EVALUATION_LATENCY_SECONDS = Histogram(
    "agent_tick_evaluation_latency_seconds",
    "Latency of the core tick evaluation loop.",
    ["agent_id"]
)

# --- Lazy Monitor Mixin ---

class LazyMonitorMixin:
    """
    A mixin for LogicalAgentAT that provides lazy-loaded access to a global
    consciousness monitor and patches core methods to emit Prometheus metrics.

    This implements the "monitor patch" functionality, enabling runtime
    observability without creating a hard dependency on monitoring tools.
    RFC-CORE-003 §9
    """
    _monitor_instance: Optional[Any] = None

    @property
    def monitor(self) -> Any:
        """
        Lazy-loads and returns the global consciousness monitor.
        RFC-CORE-003 §9.1
        """
        if self._monitor_instance is None:
            self._monitor_instance = get_global_monitor()
        return self._monitor_instance

    def _monitor_register_triad(self, motif_ids: List[str], coherence_alignment: float, triad_id: str):
        """
        Patched method to register a completed triad with the monitor.
        RFC-CORE-003 §9.2
        """
        if not self.get_feature("enable_monitor_hooks"):
            return

        timestamp_us = int(time.time() * 1_000_000)
        try:
            self.monitor.register_triad(
                motif_ids=motif_ids,
                coherence_alignment=coherence_alignment,
                triad_id=triad_id,
                timestamp_us=timestamp_us,
            )
            AGENT_TRIADS_COMPLETED_TOTAL.inc()
        except Exception as e:
            logging.warning(f"Failed to register triad with monitor: {e}")

    def _monitor_report_tick(self, tick: Any, annotations: Dict[str, Any]):
        """
        Patched method to report a full tick evaluation to the monitor.
        """
        if not self.get_feature("enable_monitor_hooks"):
            return

        try:
            self.monitor.report_tick(tick=tick, annotations=annotations)
        except Exception as e:
            logging.warning(f"Failed to report tick to monitor: {e}")

    def _monitor_increment_metric(self, metric: Counter, **labels) -> None:
        """Helper to safely increment a metric."""
        try:
            # Ensure agent_id is always present if the metric expects it
            if 'agent_id' in metric._labelnames and 'agent_id' not in labels:
                labels['agent_id'] = self.agent_id
            metric.labels(**labels).inc()
        except Exception as e:
            logging.debug(f"Failed to increment metric {metric._name}: {e}")

    def _monitor_set_gauge(self, gauge: Gauge, value: float, **labels) -> None:
        """Helper to safely set a gauge."""
        try:
            if 'agent_id' in gauge._labelnames and 'agent_id' not in labels:
                labels['agent_id'] = self.agent_id
            gauge.labels(**labels).set(value)
        except Exception as e:
            logging.debug(f"Failed to set gauge {gauge._name}: {e}")

    def _monitor_observe_histogram(self, histogram: Histogram, value: float, **labels) -> None:
        """Helper to safely observe a histogram value."""
        try:
            if 'agent_id' in histogram._labelnames and 'agent_id' not in labels:
                labels['agent_id'] = self.agent_id
            histogram.labels(**labels).observe(value)
        except Exception as e:
            logging.debug(f"Failed to observe histogram {histogram._name}: {e}")

# End_of_File