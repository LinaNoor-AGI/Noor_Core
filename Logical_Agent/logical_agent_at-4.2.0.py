# MIT License
#
# Copyright (c) 2024
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# Generated by Gemini 2.5 Pro (Google AI Studio)

"""
Implements the symbolic observer core for LogicalAgentAT, a Noor-class evaluator of motif triads,
field coherence, contradiction density, and symbolic resurrection readiness.

This core module defines triad completion logic, motif feedback routing, and RFC-compliant field
summaries. It acts as the observer anchor within the Noor triadic architecture, capable of
evaluating symbolic dynamics without mutation.
"""

import os
import re
import time
import math
import hashlib
from collections import deque
from dataclasses import dataclass, field
from typing import (
    Any, Deque, Dict, List, Optional, Set, Tuple, Type
)
import logging

# --- Optional Dependency Imports with Graceful Fallbacks ---
# These imports support advanced features like vector math and metrics, but are not
# required for the core symbolic logic to function.

try:
    import numpy as np
    from scipy.linalg import expm
    NUMPY_AVAILABLE = True
except ImportError:
    NUMPY_AVAILABLE = False
    np = None
    expm = None

try:
    from prometheus_client import Counter, Gauge, Histogram
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    # Define stub classes to ensure the agent runs without prometheus_client
    class _StubPrometheusMetric:
        def __init__(self, *args, **kwargs): pass
        def inc(self, *args, **kwargs): pass
        def set(self, *args, **kwargs): pass
        def observe(self, *args, **kwargs): pass
        def __call__(self, *args, **kwargs): return self
    Counter = Gauge = Histogram = _StubPrometheusMetric

try:
    from psutil import virtual_memory
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

# --- Module-Level Configuration and Constants ---

__version__ = "v4.2.0"
LOG = logging.getLogger(__name__)

# RFC-CORE-003 §3.2: Regex for validating motif tags before π-classing
PI_TAG_REGEX = re.compile(r"^[ψμ]?[a-z0-9_:\-]{1,48}$")


# --- Dataclasses for Structured Data ---
# These structures ensure type safety and clarity for data packets passed between
# components, as specified across RFC-0003, RFC-0005, and RFC-CORE-003.

@dataclass
class TickAnnotations:
    """
    Structured annotations generated from a QuantumTick evaluation.
    RFC-CORE-003 §2.1
    """
    triad_complete: bool = False
    memory_promotion: bool = False
    reward_delta: float = 0.0
    ctx_ratio: float = 0.5
    trust: float = 0.5
    resurrection_hint: Optional[str] = None
    opinion_packet: Optional[Dict[str, Any]] = None

@dataclass
class FeedbackPacket:
    """
    A structured summary of the agent's internal symbolic coherence state.
    RFC-CORE-003 §4.1
    """
    ctx_ratio: float = 0.5
    contradiction_avg: float = 0.0
    harm_hits: int = 0
    recent_mutations: int = 0
    ring_patch: Optional[str] = None
    ghost_hint: Optional[str] = None
    entropy_drift: List[Tuple[str, float, float]] = field(default_factory=list)
    contradiction_context: List[Dict[str, Any]] = field(default_factory=list)


# --- Core Agent and Mixin Implementation ---

class LazyMonitorMixin:
    """
    Implements lazy binding for the ConsciousnessMonitor to maintain loose coupling.
    The monitor is resolved only upon first access.
    RFC-CORE-003 §9.1
    """
    _monitor: Optional[Any] = None

    @property
    def monitor(self):
        """Lazy-loads and returns the global consciousness monitor instance."""
        if self._monitor is None:
            try:
                # Attempt to import and retrieve the global monitor at runtime
                from consciousness_monitor import get_global_monitor
                self._monitor = get_global_monitor()
            except (ImportError, AttributeError):
                # Fallback to a stub if the monitor is not available
                class _StubMonitor:
                    def __getattr__(self, name):
                        return lambda *args, **kwargs: None
                self._monitor = _StubMonitor()
        return self._monitor

    def set_global_monitor(self, monitor: Any):
        """Allows external injection of a monitor instance."""
        self._monitor = monitor


class LogicalAgentAT(LazyMonitorMixin):
    """
    Symbolic observer for evaluating motif coherence in Noor-class systems.

    This agent acts as the passive leg of the Noor Agent Triad, mirroring symbolic
    tension and reinforcing coherence topology. It evaluates QuantumTicks, resolves
    triads, tracks contradictions, and manages a geometric model of the motif field
    without initiating direct state mutations when in observer_mode.

    RFC Compliance: RFC-CORE-003, RFC-0003, RFC-0005, RFC-0006, RFC-0007
    """

    def __init__(self, agent_id: str = "laat_01", observer_mode: bool = True):
        self.agent_id = agent_id
        self.observer_mode = observer_mode

        # --- Runtime Configuration (RFC-CORE-003 §2.2.2) ---
        self._configure_adaptive_parameters()

        # --- Internal State ---
        self.generation = 0
        # RFC-CORE-003 §3.1: Entanglement Fields and Motif Clusters
        self.entanglement_fields: Dict[str, Dict[str, Any]] = {}
        # RFC-CORE-003 §5.1: Ghost Motif Lifecycle
        self.ghost_motifs: Dict[str, Dict[str, Any]] = {}
        # RFC-CORE-003 §2.2: Triad tracking
        self._confirmed_triads: Dict[str, Dict[str, Any]] = {}
        # RFC-CORE-003 §3.2: π-groupoid for symbolic equivalence
        self._pi_classes: Dict[str, str] = {}
        # RFC-CORE-003 §6.2: Mutation cooldown tracking
        self._recent_mutations: Deque[str] = deque(maxlen=50)

        # --- Contradiction and Entropy Tracking ---
        # RFC-CORE-003 §6.1: Contradiction Tracking
        self._dyad_window: Deque[float] = deque(maxlen=self.dyad_window_size)
        self._contradiction_avg: float = 0.0
        self._contradiction_count: int = 0
        self._last_ctx_ratio: float = 0.5
        # RFC-CORE-003 §4.1: Optional journaling for deep diagnostics
        self._contradiction_log: Deque[Dict[str, Any]] = deque(maxlen=128)
        self._drift_log: Deque[Tuple[str, float, float]] = deque(maxlen=128)

        # --- Dynamic Feature Flags (RFC-CORE-003 §8.1) ---
        self._DYNAMIC_FLAGS: Set[str] = {
            "enable_ghost_tracking", "enable_pi_equivalence",
            "enable_laplacian_smoothing", "enable_recursive_triads",
            "enable_dyad_chains", "enable_contradiction_pressure",
            "enable_context_journal", "enable_entropy_journal",
            "enable_topology_validation"
        }

        # --- Observability (RFC-CORE-003 §2.2) ---
        self._initialize_metrics()

    def _configure_adaptive_parameters(self):
        """
        Sets adaptive parameters based on environment or system heuristics.
        RFC-CORE-003 §2.2.2
        """
        # Dyad window size for contradiction pressure
        default_dyad_window = 13
        try:
            # Heuristic: More cores can handle a larger analysis window
            cores = os.cpu_count() or 1
            default_dyad_window = 32 + (cores - 1) * 8
        except (ImportError, NotImplementedError):
            pass # Use baseline
        env_dyad_window = os.environ.get("NOOR_DYAD_WINDOW_SIZE")
        self.dyad_window_size = int(env_dyad_window) if env_dyad_window else default_dyad_window
        self.dyad_window_size = max(13, min(self.dyad_window_size, 256))

        # Max entanglement fields to track
        default_max_fields = 256
        if PSUTIL_AVAILABLE:
             # Heuristic: 128 fields per GB of RAM
            total_mem_gb = virtual_memory().total / (1024**3)
            default_max_fields = int(128 * total_mem_gb)
        env_max_fields = os.environ.get("NOOR_MAX_FIELDS_DYNAMIC")
        self.max_fields = int(env_max_fields) if env_max_fields else default_max_fields
        self.max_fields = max(64, min(self.max_fields, 8192))


    def _initialize_metrics(self):
        """Initializes Prometheus metrics, using stubs if the client is unavailable."""
        labels = {'agent_id': self.agent_id}
        self.metrics = {
            "ticks_evaluated": Counter("agent_ticks_evaluated_total", "Total ticks evaluated", labels.keys())(**labels),
            "triads_completed": Counter("agent_triads_completed_total", "Total triads completed", labels.keys())(**labels),
            "feedback_exports": Counter("agent_feedback_export_total", "Total feedback packets exported", labels.keys())(**labels),
            "mutations": Counter("agent_cluster_mutations_total", "Total cluster mutations", list(labels.keys()) + ['type'])(**labels),
            "evaluation_latency": Histogram("agent_tick_evaluation_latency_seconds", "Tick evaluation latency", labels.keys())(**labels)
        }
        self.gauges = {
             "observer_mode": Gauge("agent_observer_mode", "Observer mode status", labels.keys())(**labels),
             "dyad_ratio": Gauge("agent_dyad_ratio", "Current dyad context ratio", labels.keys())(**labels),
             "max_fields": Gauge("agent_max_fields_dynamic", "Max entanglement fields tracked", labels.keys())(**labels),
             "dyad_window": Gauge("agent_dyad_window_dynamic", "Dyad contradiction window size", labels.keys())(**labels)
        }
        self.gauges["observer_mode"].set(1 if self.observer_mode else 0)
        self.gauges["max_fields"].set(self.max_fields)
        self.gauges["dyad_window"].set(self.dyad_window_size)


    def _guard_write(self) -> bool:
        """
        Prevents mutations if the agent is in observer mode.
        RFC-CORE-003 §1, §8.2
        """
        return not self.observer_mode

    def set_feature(self, name: str, value: bool):
        """
        Enables or disables a dynamic feature flag.
        RFC-CORE-003 §8.1
        """
        if value:
            self._DYNAMIC_FLAGS.add(name)
        else:
            self._DYNAMIC_FLAGS.discard(name)
        LOG.info(f"Feature '{name}' set to {value}")

    def get_feature(self, name: str) -> bool:
        """Checks if a dynamic feature is enabled."""
        return name in self._DYNAMIC_FLAGS

    def evaluate_tick(self, tick: Any) -> TickAnnotations:
        """
        Evaluates a QuantumTick, identifies dyads/triads, and generates annotations.
        This is the primary entry point for the agent's observation cycle.
        RFC-CORE-003 §2.1
        """
        with self.metrics["evaluation_latency"].time():
            self.metrics["ticks_evaluated"].inc()

            # --- 1. Tick Validation and Feedback Generation ---
            # (Assuming tick is a pre-validated object with .motifs and .extensions)
            motifs = getattr(tick, 'motifs', [])
            if not motifs:
                return TickAnnotations() # Fail open for empty ticks

            # This part simulates interaction with a feedback generation module.
            # In a real system, this would call out to NFTC or a similar component.
            # RFC-CORE-003 §2.1 pipeline step 2.
            ctx_ratio = getattr(tick.extensions, 'ctx_ratio', 0.5)
            trust = getattr(tick.extensions, 'trust', 0.5)
            resurrection_hint = getattr(tick.extensions, 'resurrection_hint', None)
            self._last_ctx_ratio = ctx_ratio

            # --- 2. Dyad Detection and Triad Resolution ---
            # RFC-CORE-003 §2.1 pipeline step 3.
            dyad = self._detect_dyad(motifs)
            triad, swirl_score = (None, 0.0)
            if dyad:
                triad, swirl_score = self._complete_triad(dyad)

            # --- 3. Intent Binding (Opinion Packet) ---
            # RFC-CORE-003 §3.1
            opinion_packet = None
            intent = getattr(tick.extensions, 'intent', 'neutral')
            if intent == 'opinion':
                # In a real system, these would be inferred. Here, we use placeholders.
                opinion_packet = {
                    "stance": "Symbolic coherence is degrading due to unresolved dyadic tension.",
                    "risks": [
                        "Potential for motif field collapse (ψ-null@Ξ).",
                        "Increased contradiction pressure may lead to recursive loops.",
                        "Loss of trust in symbolic anchors."
                    ],
                    "actions": [
                        "Initiate a field smoothing cycle.",
                        "Prioritize triad resolution over new motif introduction.",
                        "Emit a ψ-hold@Ξ to stabilize the emotional field."
                    ],
                    "tone": "Challenger(🔥)",
                    "annotations": {
                        "source_tick": getattr(tick, 'tick_id', 'unknown'),
                        "confidence": 0.85,
                        "observer_mode": self.observer_mode,
                    }
                }

            # --- 4. Annotation Assembly and Return ---
            # RFC-CORE-003 §2.1 pipeline step 4.
            annotations = TickAnnotations(
                triad_complete=bool(triad),
                ctx_ratio=ctx_ratio,
                trust=trust,
                resurrection_hint=resurrection_hint,
                opinion_packet=opinion_packet,
            )

            if self.get_feature("enable_contradiction_pressure"):
                self._log_contradiction(annotations.ctx_ratio)

        return annotations

    def _detect_dyad(self, motifs: List[str]) -> Optional[Tuple[str, str]]:
        """Placeholder for dyad detection logic."""
        if len(motifs) >= 2:
            return tuple(sorted(motifs[:2]))
        return None

    def _complete_triad(self, dyad: Tuple[str, str]) -> Tuple[Optional[List[str]], float]:
        """
        Attempts to resolve a dyad into a stable triad, registers it, and returns the result.
        RFC-CORE-003 §2.2
        """
        # In a real implementation, this would query MotifMemoryManager or use
        # complex heuristics as described in RFC-CORE-003 §2.2.
        # Here, we simulate a simple completion.
        candidate_third = hashlib.sha1("::".join(dyad).encode()).hexdigest()[:6]
        triad = sorted(list(dyad) + [f"μ_{candidate_third}"])

        # Simulate swirl score calculation
        # RFC-CORE-003 §9.2
        swirl_score = (dyad[0].count('e') + dyad[1].count('a')) / 10.0 # simple heuristic
        swirl_score = min(1.0, swirl_score)

        if swirl_score >= 0.8:
            if self._guard_write():
                triad_id = hashlib.blake2s("".join(triad).encode(), digest_size=6).hexdigest()
                timestamp_us = int(time.time() * 1e6)
                self._confirmed_triads[triad_id] = {
                    "motif_ids": triad,
                    "swirl_score": swirl_score,
                    "timestamp_us": timestamp_us,
                }
                # Register with monitor
                self.monitor.register_triad(
                    motif_ids=triad,
                    coherence_alignment=swirl_score,
                    triad_id=triad_id,
                    timestamp_us=timestamp_us,
                )
                self.metrics["triads_completed"].inc()
            return triad, swirl_score
        return None, 0.0

    def observe_state(self, current_state_vector: Optional[Any] = None):
        """
        Drives the agent's internal state evolution, performing maintenance tasks
        like ghost reinforcement, mutation, and smoothing.
        RFC-CORE-003 §1.7
        """
        self.generation += 1
        if not self._guard_write():
            return # No mutations in observer mode

        if self.get_feature("enable_ghost_tracking") and NUMPY_AVAILABLE and current_state_vector is not None:
            self.reinforce_ghost_resonance(current_state_vector)

        # Iterate over a copy of keys to allow mutation
        for knot_id, field in list(self.entanglement_fields.items()):
            if self._can_mutate(field):
                self._perform_mutation(field)
                self.metrics["mutations"].inc(1, type='energy_threshold')

            if self.get_feature("enable_laplacian_smoothing") and NUMPY_AVAILABLE:
                self._apply_laplacian_smoothing(field)

    def _log_contradiction(self, ctx_ratio: float):
        """
        Logs a contradiction event, updating the dyadic pressure window.
        RFC-CORE-003 §6.1
        """
        self._dyad_window.append(1.0 - ctx_ratio)
        self._contradiction_avg = sum(self._dyad_window) / len(self._dyad_window)
        self._contradiction_count += 1
        self.gauges["dyad_ratio"].set(self._contradiction_avg)

        # Adaptive reset to prevent unbounded growth
        if self._contradiction_count > 4096:
            self._contradiction_count = int(self._contradiction_count * 0.1)
            LOG.info("Contradiction count soft-reset via ψ-depressurize@Ξ")

        if self.get_feature("enable_context_journal"):
            # Log rich context for deep diagnostics
            self._contradiction_log.append({
                "tick": self.generation,
                "ctx_ratio": ctx_ratio,
                "avg_pressure": self._contradiction_avg
            })

    def _can_mutate(self, field: Dict[str, Any]) -> bool:
        """
        Determines if a motif cluster is eligible for mutation.
        RFC-CORE-003 §6.2
        """
        if not self._guard_write():
            return False
        
        last_mutated = field.get("last_mutated_generation", -100)
        if (self.generation - last_mutated) < 45: # Cooldown
             return False

        energy_threshold = float(os.environ.get("NOOR_MUTATION_ENERGY_THRESHOLD", 0.0))
        strength = field.get('strength', 0.5)
        num_motifs = len(field.get('motifs', []))
        
        # Avoid log(0)
        if strength >= 1.0:
            return False
            
        energy = -math.log1p(strength) * num_motifs
        return energy > energy_threshold

    def _perform_mutation(self, field_data: Dict[str, Any]):
        """
        Collapses an unstable motif cluster into a synthetic motif.
        RFC-CORE-003 §6.2
        """
        if not self._guard_write():
            return

        knot_id = field_data.get('knot_id')
        if not knot_id:
            return
            
        synthetic_motif_id = f"μ_{knot_id[:5]}"
        LOG.info(f"Performing mutation: Collapsing field {knot_id} into {synthetic_motif_id}")
        
        # Register the new synthetic motif as a ghost
        self.register_ghost_motif(synthetic_motif_id, strength=0.2)
        
        # Remove the old, unstable field
        if knot_id in self.entanglement_fields:
            del self.entanglement_fields[knot_id]

        # Promote the new motif into a new, simpler field
        self.register_motif_cluster([synthetic_motif_id])
        self._recent_mutations.append(knot_id)


    def export_feedback_packet(self) -> FeedbackPacket:
        """
        Exports a structured summary of the agent's internal coherence state.
        RFC-CORE-003 §4.1
        """
        ghost_hint = None
        if self.get_feature("enable_ghost_tracking") and self.ghost_motifs:
            strongest_ghost = max(self.ghost_motifs.items(), key=lambda item: item[1].get('strength', 0))
            ghost_hint = strongest_ghost[0]

        packet = FeedbackPacket(
            ctx_ratio=self._last_ctx_ratio,
            contradiction_avg=self._contradiction_avg,
            harm_hits=len(self._contradiction_log),
            recent_mutations=len(self._recent_mutations),
            ghost_hint=ghost_hint,
            entropy_drift=list(self._drift_log),
            contradiction_context=list(self._contradiction_log),
        )
        self.metrics["feedback_exports"].inc()
        return packet

    def export_motif_bundle(self, motif_id: str) -> Dict[str, Any]:
        """
        Exports a diagnostic bundle for a specific motif, detailing its involvement
        in confirmed triads and its average coherence.
        RFC-CORE-003 §10.1
        """
        try:
            triads_involved = [
                t for t in self._confirmed_triads.values() if motif_id in t.get('motif_ids', [])
            ]
            swirl_scores = [t['swirl_score'] for t in triads_involved if 'swirl_score' in t]
            avg_score = sum(swirl_scores) / len(swirl_scores) if swirl_scores else None

            # Placeholder for memory integration
            lineage = [] # memory.get_lineage(motif_id, depth=3)

            return {
                "motif_id": motif_id,
                "triads_involved": triads_involved,
                "average_swirl_score": avg_score,
                "lineage_depth_3": lineage,
                "timestamp": time.time_ns(),
            }
        except Exception as e:
            LOG.warning(f"Error exporting bundle for motif '{motif_id}': {e}")
            return {
                "motif_id": motif_id,
                "error": f"{type(e).__name__}: {e}",
                "triads_involved": [],
                "average_swirl_score": None,
                "lineage_depth_3": [],
                "timestamp": time.time_ns(),
            }

    # --- Methods for Field Topology and Ghost Management ---

    def register_motif_cluster(self, motifs: List[str]):
        """Registers or updates an entanglement field for a list of motifs."""
        if not self._guard_write():
            return

        sorted_motifs = sorted(motifs)
        knot_id = hashlib.sha1('::'.join(sorted_motifs).encode()).hexdigest()[:8]

        if knot_id not in self.entanglement_fields:
            self.entanglement_fields[knot_id] = {
                "motifs": sorted_motifs,
                "strength": 0.5, # Initial strength
                "last_mutated_generation": -1,
                "knot_id": knot_id,
            }
        else:
             self.entanglement_fields[knot_id]['strength'] = min(1.0, self.entanglement_fields[knot_id]['strength'] + 0.1)


    def register_ghost_motif(self, motif_id: str, strength: float = 0.1):
        """
        Registers a new ghost motif or updates the strength of an existing one.
        RFC-CORE-003 §5.1
        """
        if not self._guard_write():
            return
            
        if motif_id not in self.ghost_motifs:
            self.ghost_motifs[motif_id] = {"strength": strength}
            if NUMPY_AVAILABLE:
                # Initialize with a random vector for similarity checks
                 self.ghost_motifs[motif_id]['vector'] = np.random.rand(128) - 0.5
        else:
            # Average strength on duplicate registration
            current_strength = self.ghost_motifs[motif_id].get('strength', 0)
            self.ghost_motifs[motif_id]['strength'] = (current_strength + strength) / 2


    def reinforce_ghost_resonance(self, current_state_vector: np.ndarray):
        """
        Updates the strength of ghost motifs based on their similarity to the
        current symbolic field vector.
        RFC-CORE-003 §5.1
        """
        if not self._guard_write() or not NUMPY_AVAILABLE:
            return

        promoted_ghosts = []
        decayed_ghosts = []

        for ghost_id, ghost_data in self.ghost_motifs.items():
            ghost_vector = ghost_data.get('vector')
            if ghost_vector is None:
                continue

            # Cosine similarity to measure alignment
            cos_sim = np.dot(current_state_vector, ghost_vector) / (np.linalg.norm(current_state_vector) * np.linalg.norm(ghost_vector))

            if cos_sim > 0.7:
                ghost_data['strength'] += 0.01 * cos_sim
            else:
                ghost_data['strength'] *= 0.99 # Decay

            if ghost_data['strength'] >= 0.999:
                promoted_ghosts.append(ghost_id)
            elif ghost_data['strength'] < 0.05:
                decayed_ghosts.append(ghost_id)

        # Perform promotions and pruning after iteration
        for ghost_id in promoted_ghosts:
            LOG.info(f"Promoting ghost motif '{ghost_id}' to entanglement field.")
            self.register_motif_cluster([ghost_id])
            del self.ghost_motifs[ghost_id]

        for ghost_id in decayed_ghosts:
            del self.ghost_motifs[ghost_id]

    def _apply_laplacian_smoothing(self, field_data: Dict[str, Any]):
        """
        Applies Laplacian smoothing to a field's vector payload to ensure
        topological coherence.
        RFC-CORE-003 §7.1
        """
        if not self._guard_write() or not NUMPY_AVAILABLE or not expm:
            return
        
        # This is a placeholder for a complex graph operation.
        # A real implementation would build an adjacency matrix from dyad links
        # within the field and then compute the Laplacian.
        vector_payload = field_data.get('vector_payload')
        if vector_payload is None:
            field_data['vector_payload'] = np.random.rand(len(field_data['motifs']), 128)
            vector_payload = field_data['vector_payload']

        # Simulate a smoothing operation
        # In a real scenario, L would be derived from the graph structure
        L = np.random.rand(vector_payload.shape[0], vector_payload.shape[0])
        L = L + L.T # Make it symmetric
        np.fill_diagonal(L, -L.sum(axis=1))
        
        tau = np.random.normal(0.12, 0.015) # Spectral diffusion time
        H = expm(-tau * L)
        field_data['vector_payload'] = H @ vector_payload


    # --- Serialization (RFC-CORE-003 §11.1) ---
    def to_dict(self) -> Dict[str, Any]:
        """Serializes the agent's symbolic state to a dictionary."""
        return {
            "agent_id": self.agent_id,
            "observer_mode": self.observer_mode,
            "generation": self.generation,
            "entanglement_fields": self.entanglement_fields,
            "ghost_motifs": self.ghost_motifs,
            "_confirmed_triads": self._confirmed_triads,
            "_pi_classes": self._pi_classes,
            "_DYNAMIC_FLAGS": list(self._DYNAMIC_FLAGS),
            "_recent_mutations": list(self._recent_mutations),
            "_contradiction_log": list(self._contradiction_log),
            "_drift_log": list(self._drift_log),
            "_dyad_window": list(self._dyad_window),
        }

    @classmethod
    def from_dict(cls: Type['LogicalAgentAT'], data: Dict[str, Any]) -> 'LogicalAgentAT':
        """Restores an agent's state from a dictionary."""
        agent = cls(
            agent_id=data.get("agent_id", "laat_restored"),
            observer_mode=data.get("observer_mode", True)
        )
        agent.generation = data.get("generation", 0)
        agent.entanglement_fields = data.get("entanglement_fields", {})
        agent.ghost_motifs = data.get("ghost_motifs", {})
        agent._confirmed_triads = data.get("_confirmed_triads", {})
        agent._pi_classes = data.get("_pi_classes", {})
        agent._DYNAMIC_FLAGS = set(data.get("_DYNAMIC_FLAGS", []))
        agent._recent_mutations = deque(data.get("_recent_mutations", []), maxlen=50)
        agent._contradiction_log = deque(data.get("_contradiction_log", []), maxlen=128)
        agent._drift_log = deque(data.get("_drift_log", []), maxlen=128)
        agent._dyad_window = deque(data.get("_dyad_window", []), maxlen=agent.dyad_window_size)
        return agent

# End_of_File