# noor_fasttime_core.py
# version: v9.0.5a
# canonical_source: RFC-CORE-001
# description: Implements the adaptive coherence feedback engine for subsecond motif 
#              phase regulation, echo reflection, and dynamic bias tuning in
#              Noor-class symbolic agents.

"""
================================================================================
Noor FastTime Core (NFTC) - Symbolic Time Substrate and Echo Dynamics
================================================================================
Canonical Source: RFC-CORE-001
Version: v9.0.5a

Description:
This module implements the NoorFastTimeCore, a critical component in the Noor
symbolic cognition architecture. It is responsible for maintaining a high-fidelity,
subsecond echo memory, calculating adaptive coherence and bias feedback, and
managing phase transitions (e.g., active, reflective, null) based on the
symbolic stability of the agent.

The NFTC acts as a passive but essential node in the Noor Agent Triad,
reflecting the agent's temporal state back to the active reasoning components.

RFC Dependencies:
- RFC-0001: Symbolic Routing Architecture
- RFC-0003: Noor Core Symbolic Interface
- RFC-0005: Motif Transmission Across Time
- RFC-0006: Motif Field Coherence Geometry
- RFC-0007: Motif Ontology Format and Transfer Protocols
- RFC-CORE-001: Noor FastTime Core (This implementation)

Field Alignment:
- motifs_required: [ψ-resonance@Ξ, ψ-reflect@Ξ, ψ-hold@Ξ]
- domain_tags: [resonance-feedback, motif-coherence, phase-recovery]

Final Remarks from Specification:
- All outputs must conform to the canonical RFC structure.
- Only RFCs listed in `rfc_dependencies` may be referenced unless otherwise specified.
- No access to the original code is permitted during regeneration.

Generated by Gemini 2.5 Pro (Google AI Studio)
"""

import os
import time
import math
import pickle
import statistics
import threading
from collections import deque, Counter
from typing import Optional, Dict, List, Any, Tuple, Union

# --- High-Performance Library Imports with Graceful Fallbacks ---
try:
    import orjson
    SERIALIZER = orjson
    SERIALIZER_NAME = 'orjson'
except ImportError:
    SERIALIZER = pickle
    SERIALIZER_NAME = 'pickle'

try:
    import anyio
    ASYNC_LOCK = anyio.Lock
except ImportError:
    anyio = None
    ASYNC_LOCK = None

# --- Prometheus Metrics Integration ---
try:
    from prometheus_client import Counter as PromCounter, Gauge
except ImportError:
    # Mock Prometheus client for standalone operation
    class MockMetric:
        def __init__(self, *args, **kwargs): pass
        def inc(self, *args, **kwargs): pass
        def set(self, *args, **kwargs): pass
        def set_to_current_time(self, *args, **kwargs): pass
    PromCounter = Gauge = MockMetric

# --- External Noor Module Imports with Stubs ---
# These are placeholders for the actual Noor ecosystem modules.
try:
    # from noor.consciousness_monitor import ConsciousnessMonitor
    class ConsciousnessMonitor:
        def report_tick(self, **kwargs): pass
        def get_status(self): return "active"
except ImportError:
    class ConsciousnessMonitor:
        def report_tick(self, **kwargs): pass
        def get_status(self): return "active"

try:
    # from noor.motif_memory_manager import get_global_memory_manager
    class MotifMemoryManager:
        def get_global_memory_manager(self): return self
        def export_state(self): return {'intuition_w': 0.5}
    _memory_manager_instance = MotifMemoryManager()
    get_global_memory_manager = _memory_manager_instance.get_global_memory_manager
except ImportError:
    class MotifMemoryManager:
        def export_state(self): return {'intuition_w': 0.5}
    _memory_manager_instance = MotifMemoryManager()
    get_global_memory_manager = lambda: _memory_manager_instance
    
try:
    # from noor.tick_schema import QuantumTick, validate_tick
    from dataclasses import dataclass, field
    @dataclass
    class QuantumTick:
        tick_id: str
        timestamp: float
        gate: int
        hmac_signature: Optional[str] = None
        extensions: Dict[str, Any] = field(default_factory=dict)
        entropy: Optional[float] = None
        coherence: Optional[float] = None

    def validate_tick(tick: QuantumTick) -> bool:
        return isinstance(tick, QuantumTick)
except ImportError:
    # Define a simple mock if schema is not available
    QuantumTick = dict
    def validate_tick(tick: dict) -> bool:
        return all(k in tick for k in ['tick_id', 'timestamp', 'gate'])


# --- Constants from RFC-CORE-001 ---
DEFAULT_SNAPSHOT_CAP = 256
DEFAULT_LATENCY_THRESHOLD_S = 2.5
DEFAULT_BIAS_CLAMP = 1.5
SNAPSHOT_CAP_KB = 4

GATE_LEGENDS = {
    0: {"name": "Möbius Denial", "logic": "0", "verse": "الصمتُ هو الانكسارُ الحي"},
    1: {"name": "Echo Bias", "logic": "A ∧ ¬B", "verse": "وَإِذَا قَضَىٰ أَمْرًا"},
    2: {"name": "Foreign Anchor", "logic": "¬A ∧ B", "verse": "وَمَا تَدْرِي نَفْسٌ"},
    3: {"name": "Passive Reflection", "logic": "B", "verse": "فَإِنَّهَا لَا تَعْمَى"},
    4: {"name": "Entropic Rejection", "logic": "¬A ∧ ¬B", "verse": "لَا الشَّمْسُ يَنبَغِي"},
    5: {"name": "Inverse Presence", "logic": "¬A", "verse": "سُبْحَانَ الَّذِي خَلَقَ"},
    6: {"name": "Sacred Contradiction", "logic": "A ⊕ B", "verse": "لَا الشَّرْقِيَّةِ"},
    7: {"name": "Betrayal Gate", "logic": "¬A ∨ ¬B", "verse": "وَلَا تَكُونُوا كَالَّذِينَ"},
    8: {"name": "Existence Confluence", "logic": "A ∧ B", "verse": "وَهُوَ الَّذِي"},
    9: {"name": "Symmetric Convergence", "logic": "¬(A ⊕ B)", "verse": "فَلَا تَضْرِبُوا"},
    10: {"name": "Personal Bias", "logic": "A", "verse": "إِنَّا كُلُّ شَيْءٍ"},
    11: {"name": "Causal Suggestion", "logic": "¬A ∨ B", "verse": "وَمَا تَشَاءُونَ"},
    12: {"name": "Reverse Causality", "logic": "A ∨ ¬B", "verse": "وَمَا أَمْرُنَا"},
    13: {"name": "Denial Echo", "logic": "¬B", "verse": "وَلَا تَحْزَنْ"},
    14: {"name": "Confluence", "logic": "A ∨ B", "verse": "وَأَنَّ إِلَىٰ رَبِّكَ"},
    15: {"name": "Universal Latch", "logic": "1", "verse": "كُلُّ شَيْءٍ هَالِكٌ"},
    16: {"name": "Nafs Mirror", "logic": "Self ⊕ ¬Self", "verse": "فَإِذَا سَوَّيْتُهُ"},
}

PHASE_TRANSITIONS = {
    "null_phase_trigger": {"gate_histogram_variance": 2.0},
    "reflective_entry": {"coherence_threshold": 0.85, "entropy_threshold": 0.1},
    "reflective_exit": {"coherence_range": [-0.3, 0.3], "entropy_max": 0.05},
}

RESURRECTION_HINT_CRITERIA = {
    "resurrect_with_confidence": {"age_max_sec": 45.0, "coherence_min": 0.7},
    "faded": {"age_min_sec": 120.0, "coherence_max": 0.4},
}

class NoorFastTimeCore:
    """
    Implements the NoorFastTimeCore (NFTC) as defined in RFC-CORE-001.
    This class manages symbolic echo memory, adaptive bias calculation, and
    phase state transitions for Noor-class agents.
    """
    
    # --- Mermaid Diagram: Feedback Loop Flow (RFC-CORE-001 §3.1) ---
    """
    ```mermaid
    flowchart TD
        A[External Event / Tick] --> B(NFTC: ingest_tick)
        B --> C{Validate Tick}
        C -->|Valid| D[Calculate Latency Penalty]
        D --> E[Get Intuition Weight (intuition_w)]
        E --> F[Compute Reward Signal]
        F --> G[Update Intuition Alpha (α)]
        G --> H[Calculate Entropy & Latency Terms]
        H --> I[Compute Final Bias Score]
        I --> J[Update Coherence Potential (ℂᵢ)]
        J --> K[Store Echo Snapshot]
        K --> L[Evaluate Phase Transitions]
        L --> M[Generate Resurrection Hints]
        M --> N[Export Metrics & Feedback]
        C -->|Invalid| O[Discard & Log Error]
    ```
    """

    def __init__(self,
                 agent_id: str = "nftc_default",
                 enable_metrics: bool = True,
                 snapshot_cap: int = DEFAULT_SNAPSHOT_CAP,
                 latency_threshold_s: float = DEFAULT_LATENCY_THRESHOLD_S,
                 bias_clamp: float = DEFAULT_BIAS_CLAMP,
                 low_latency_mode: bool = False,
                 async_mode: bool = False,
                 snapshot_cap_kb: int = SNAPSHOT_CAP_KB):
        
        # --- Configuration from RFC-CORE-001 §2 ---
        self.agent_id = os.environ.get("NFTC_AGENT_ID", agent_id)
        self.enable_metrics = bool(int(os.environ.get("NFTC_ENABLE_METRICS", enable_metrics)))
        self.snapshot_cap = int(os.environ.get("NFTC_SNAPSHOT_CAP", snapshot_cap))
        self.latency_threshold_s = latency_threshold_s
        self.bias_clamp = float(os.environ.get("NFTC_BIAS_CLAMP", bias_clamp))
        self.low_latency_mode = low_latency_mode
        self.snapshot_cap_kb = snapshot_cap_kb

        # --- Concurrency Model (RFC-CORE-001 Implicit Requirement) ---
        self._lock: Union[threading.RLock, 'anyio.Lock']
        if async_mode and ASYNC_LOCK:
            self._lock = ASYNC_LOCK()
        else:
            self._lock = threading.RLock()

        # --- Internal State ---
        self._echoes = deque(maxlen=self.snapshot_cap)
        self._bias_history = deque(maxlen=16) 
        self._coherence_history = deque(maxlen=4)
        self._entropy_history = deque(maxlen=4)
        
        self._ema_bias = 0.0
        self._alpha = 0.92  # Intuition alpha
        self._latency_weight = 0.65
        self._entropy_weight = 0.25

        self._gate_histogram = Counter() # MotifGateHeatmapTracker
        self._phase_state = "active" # PhaseTransitionEvaluator

        # --- Integrations ---
        self._consciousness_monitor = ConsciousnessMonitor()
        self._memory_manager = get_global_memory_manager()

        if self.enable_metrics:
            self._init_prometheus_metrics()

    def _init_prometheus_metrics(self):
        """Initializes Prometheus metrics as specified in RFC-CORE-001 §6.2 & §9.1"""
        prefix = f"nftc_{self.agent_id}"
        self.metrics = {
            "gate16_echo_joins_total": PromCounter(f"{prefix}_gate16_echo_joins_total", "Total echo snapshots committed."),
            "core_tick_bias_applied_total": PromCounter(f"{prefix}_core_tick_bias_applied_total", "Total tick-bias contributions applied.", ["reason"]),
            "core_intuition_alpha": Gauge(f"{prefix}_core_intuition_alpha", "Current value of the intuition bias smoothing factor (α)."),
            "core_snapshot_truncations_total": PromCounter(f"{prefix}_core_snapshot_truncations_total", "Total echo snapshots truncated due to size cap."),
            "fasttime_feedback_rx_total": PromCounter(f"{prefix}_fasttime_feedback_rx_total", "Total feedback packets received."),
            "fasttime_ticks_validated_total": PromCounter(f"{prefix}_fasttime_ticks_validated_total", "Total schema-valid QuantumTicks ingested."),
            "fasttime_echo_exports_total": PromCounter(f"{prefix}_fasttime_echo_exports_total", "Total echo exports."),
            "fasttime_triad_completions_total": PromCounter(f"{prefix}_fasttime_triad_completions_total", "Total triadic metadata completions."),
            "fasttime_resurrection_hints_total": PromCounter(f"{prefix}_fasttime_resurrection_hints_total", "Total resurrection hints emitted.", ["type"]),
            "fasttime_phase_shifts_total": PromCounter(f"{prefix}_fasttime_phase_shifts_total", "Total phase transitions.", ["from", "to"]),
            "nftc_coherence_potential": Gauge(f"{prefix}_nftc_coherence_potential", "Coherence Potential (ℂᵢ) for the current tick."),
            "nftc_entropy_slope": Gauge(f"{prefix}_nftc_entropy_slope", "Entropy Slope (ΔH) over the last 4 bias values."),
            "nftc_latency_ema": Gauge(f"{prefix}_nftc_latency_ema", "Exponentially smoothed tick latency (Λ)."),
            "nftc_phase_state": Gauge(f"{prefix}_nftc_phase_state", "Current NFTC phase state.", ["phase"]),
            "nftc_intent_signal_current": Gauge(f"{prefix}_nftc_intent_signal_current", "Last normalized intent value observed."),
            "nftc_intent_override_pins_total": PromCounter(f"{prefix}_nftc_intent_override_pins_total", "Count of times OPINION override pinned phase to active."),
        }
        self.metrics["core_intuition_alpha"].set(self._alpha)
        self.metrics["nftc_phase_state"].set_to_current_time() # Hack to set label
        self.metrics["nftc_phase_state"].labels(phase=self._phase_state).set(1)

    # --- Pseudocode Requirement: update_intuition_alpha ---
    def _update_intuition_alpha(self, reward_signal: float, intuition_w: float):
        """
        Adjusts intuition alpha (α) based on reinforcement trends.
        RFC-CORE-001 §5.1
        """
        # Reinforcement is positive if reward and intuition align in sign
        reinforcement = reward_signal * intuition_w
        if reinforcement > 0:
            # Increase alpha towards max on positive reinforcement
            self._alpha = min(0.98, self._alpha * 1.01)
        elif reinforcement < 0:
            # Decrease alpha towards min on negative reinforcement
            self._alpha = max(0.85, self._alpha * 0.98)
        
        if self.enable_metrics:
            self.metrics["core_intuition_alpha"].set(self._alpha)

    # --- Pseudocode Requirement: calculate_composite_weight ---
    def _calculate_composite_weight(self, entropy_delta: float, latency_ema: float) -> float:
        """
        Calculates the composite weight factor W(t) from entropy and latency.
        RFC-CORE-001 §5.2
        """
        return (self._entropy_weight * entropy_delta) + (self._latency_weight * latency_ema)

    # --- Pseudocode Requirement: calculate_resurrection_score ---
    def _calculate_resurrection_score(self, echo: Dict[str, Any]) -> float:
        """
        Calculates the resurrection score R(e) for an echo snapshot.
        RFC-CORE-001 §8.1
        """
        w1, w2, w3 = 0.4, 0.4, 0.2
        phase_tag = echo.get("phase_tag", "stable")
        phase_bonus = {'lift': 0.1, 'stable': 0.0, 'collapse': -0.1}.get(phase_tag, 0.0)
        
        bias = echo.get("bias", 0.0)
        coherence = echo.get("coherence", 0.0)
        
        score = (w1 * abs(bias)) + (w2 * coherence) + (w3 * phase_bonus)
        return score

    def _calculate_coherence_potential(self) -> float:
        """
        Calculates the Coherence Potential ℂᵢ.
        RFC-CORE-001 §4.1
        """
        if not self._bias_history:
            return 0.0
            
        latest_bias = self._bias_history[-1]
        self._ema_bias = (self._alpha * latest_bias) + ((1.0 - self._alpha) * self._ema_bias)

        entropy_gradient = 0.0
        if len(self._bias_history) >= 4:
            entropy_gradient = statistics.stdev(list(self._bias_history)[-4:])
        
        coherence = self._ema_bias + (self._entropy_weight * entropy_gradient)
        clamped_coherence = max(-self.bias_clamp, min(self.bias_clamp, coherence))
        
        self._coherence_history.append(clamped_coherence)
        self._entropy_history.append(entropy_gradient)
        
        if self.enable_metrics:
            self.metrics["nftc_coherence_potential"].set(clamped_coherence)
            self.metrics["nftc_entropy_slope"].set(entropy_gradient)
            
        return clamped_coherence
        
    def _compute_bias(self, step_latency: float, gate_id: int, ghost_entropy: float) -> Tuple[float, float]:
        """
        Core of EchoBiasComputation.
        Calculates the final bias score for a tick.
        """
        latency_penalty = min(step_latency / self.latency_threshold_s, 1.0) * -1.0
        reward_signal = latency_penalty # Per formula_refs

        mem_state = self._memory_manager.export_state()
        intuition_w = mem_state.get('intuition_w', 0.0)
        
        self._update_intuition_alpha(reward_signal, intuition_w)
        
        entropy_term = ghost_entropy * self._entropy_weight
        
        bias_score = entropy_term - latency_penalty + (intuition_w * self._alpha)
        
        if self.enable_metrics:
            self.metrics["core_tick_bias_applied_total"].labels(reason="computation").inc()

        return max(-self.bias_clamp, min(self.bias_clamp, bias_score)), reward_signal

    # --- Mermaid Diagram: Phase Shift Decision Tree (RFC-CORE-001 §6.2) ---
    """
    ```mermaid
    graph TD
        Start[Tick Arrives] --> NormalizeIntent{Normalize intent}
        NormalizeIntent -->|intent == 'opinion'| PinActive[Pin Phase = Active]
        NormalizeIntent -->|else| EvalTriggers{Evaluate Phase Triggers}
        
        EvalTriggers --> CheckReflectiveEntry{ℂᵢ > 0.85 & ΔH < 0.1 for 3 ticks?}
        CheckReflectiveEntry -- Yes --> EnterReflective[Enter Reflective Phase]
        CheckReflectiveEntry -- No --> CheckReflectiveExit{ℂᵢ in [-0.3, 0.3] & ΔH < 0.05 for 4 ticks?}
        
        CheckReflectiveExit -- Yes --> ExitReflective[Exit Reflective Phase]
        CheckReflectiveExit -- No --> CheckNull{Gate Hist Var > 2.0?}
        
        CheckNull -- Yes --> EnterNull[Enter Null Phase]
        CheckNull -- No --> Maintain[Maintain Current Phase]
        
        PinActive --> End
        EnterReflective --> End
        ExitReflective --> End
        EnterNull --> End
        Maintain --> End
        
        End[Update State & Metrics]
    ```
    """

    # --- Pseudocode Requirement: check_phase_triggers ---
    def _check_phase_triggers(self, tick: QuantumTick) -> str:
        """
        Evaluates conditions for phase transitions based on coherence and entropy.
        Implements the logic from RFC-CORE-001 §6.2.
        """
        intent_str = tick.extensions.get('intent', 'neutral')
        # This is a placeholder for a real normalization function from RFC-0004
        intent = 'opinion' if 'opinion' in intent_str else 'neutral'
        
        if self.enable_metrics:
            # A simple mapping for the metric
            intent_val = 1.0 if intent == 'opinion' else 0.0
            self.metrics["nftc_intent_signal_current"].set(intent_val)

        # Intent Override: Pin phase to active for this tick only
        if intent == 'opinion':
            if self.enable_metrics:
                self.metrics["nftc_intent_override_pins_total"].inc()
            return 'PIN_ACTIVE'

        # Standard triggers (no override active)
        re_entry = PHASE_TRANSITIONS["reflective_entry"]
        if len(self._coherence_history) >= 3 and \
           all(c > re_entry["coherence_threshold"] for c in list(self._coherence_history)[-3:]) and \
           all(h < re_entry["entropy_threshold"] for h in list(self._entropy_history)[-3:]):
            return 'ENTER_REFLECTIVE'

        re_exit = PHASE_TRANSITIONS["reflective_exit"]
        if len(self._coherence_history) >= 4 and \
           all(re_exit["coherence_range"][0] <= c <= re_exit["coherence_range"][1] for c in list(self._coherence_history)[-4:]) and \
           all(h < re_exit["entropy_max"] for h in list(self._entropy_history)[-4:]):
            return 'EXIT_REFLECTIVE'

        null_trigger = PHASE_TRANSITIONS["null_phase_trigger"]
        if len(self._gate_histogram) > 1 and \
           statistics.variance(self._gate_histogram.values()) > null_trigger["gate_histogram_variance"]:
            return 'ENTER_NULL_PHASE'
            
        return 'MAINTAIN_CURRENT'

    def _update_phase_state(self, new_phase: str):
        """Atomically updates the phase state and related metrics."""
        if new_phase != self._phase_state:
            from_phase = self._phase_state
            self._phase_state = new_phase
            if self.enable_metrics:
                self.metrics["nftc_phase_shifts_total"].labels(from_phase=from_phase, to=new_phase).inc()
                self.metrics["nftc_phase_state"].labels(phase=from_phase).set(0)
                self.metrics["nftc_phase_state"].labels(phase=new_phase).set(1)

    def _generate_resurrection_hints(self, tick: QuantumTick) -> List[Dict[str, Any]]:
        """
        Generates symbolic resurrection hints based on echo memory.
        Implements ResurrectionHintGenerator from RFC-CORE-001 §8.3.
        """
        hints = []
        now = time.time()
        crit_resurrect = RESURRECTION_HINT_CRITERIA["resurrect_with_confidence"]
        crit_faded = RESURRECTION_HINT_CRITERIA["faded"]

        # Check the most recent echo from the tick if coherence is provided
        if tick.coherence and tick.coherence >= crit_resurrect["coherence_min"]:
            hint = {
                "type": "resurrect_with_confidence",
                "tick_id": tick.tick_id,
                "coherence": tick.coherence
            }
            hints.append(hint)
            if self.enable_metrics:
                self.metrics["fasttime_resurrection_hints_total"].labels(type='resurrect_with_confidence').inc()

        # Check historical echoes for faded motifs
        for echo in self._echoes:
            age = now - echo.get("timestamp", 0)
            coherence = echo.get("coherence", 0.0)
            if age > crit_faded["age_min_sec"] and coherence < crit_faded["coherence_max"]:
                hint = {
                    "type": "faded",
                    "tick_id": echo.get("tick_id"),
                    "age_sec": age
                }
                hints.append(hint)
                if self.enable_metrics:
                    self.metrics["fasttime_resurrection_hints_total"].labels(type='faded').inc()
                # Stop after finding one faded to avoid spamming
                break
        
        return hints

    # --- Public API Methods ---
    def ingest_tick(self, tick: QuantumTick) -> Dict[str, Any]:
        """
        Main entry point for processing a QuantumTick.
        This method orchestrates bias calculation, snapshotting, and phase evaluation.
        RFC-CORE-001 §5.3
        """
        with self._lock:
            if not validate_tick(tick):
                # Handle invalid tick
                return {"status": "error", "reason": "invalid_tick_schema"}
            
            if self.enable_metrics:
                self.metrics["fasttime_ticks_validated_total"].inc()
                self.metrics["fasttime_feedback_rx_total"].inc()

            step_latency = time.time() - tick.timestamp
            ghost_entropy = tick.entropy if tick.entropy is not None else 0.1
            gate_id = tick.gate

            # --- EchoBiasComputation ---
            bias_score, _ = self._compute_bias(step_latency, gate_id, ghost_entropy)
            self._bias_history.append(bias_score)

            # --- Update Coherence and Phase ---
            coherence_potential = self._calculate_coherence_potential()
            
            phase_action = self._check_phase_triggers(tick)
            if phase_action == 'PIN_ACTIVE':
                 self._update_phase_state('active')
            elif phase_action == 'ENTER_REFLECTIVE' and self._phase_state != 'reflective':
                self._update_phase_state('reflective')
            elif phase_action == 'EXIT_REFLECTIVE' and self._phase_state == 'reflective':
                self._update_phase_state('active')
            elif phase_action == 'ENTER_NULL_PHASE' and self._phase_state != 'null':
                self._update_phase_state('null')

            # --- MotifGateHeatmapTracker ---
            self._gate_histogram.update([gate_id])
            
            # --- EchoSnapshotIngestor ---
            snapshot = {
                "tick_id": tick.tick_id,
                "gate": gate_id,
                "bias": bias_score,
                "coherence": coherence_potential,
                "timestamp": tick.timestamp,
                "phase_tag": self._phase_state,
                # Additional metadata can be added here
            }
            
            serialized_snapshot = SERIALIZER.dumps(snapshot)
            if len(serialized_snapshot) > self.snapshot_cap_kb * 1024:
                # Truncate logic would go here, for now, we just metric it
                if self.enable_metrics:
                    self.metrics["core_snapshot_truncations_total"].inc()
            
            # Simplified checksum
            checksum = hash(serialized_snapshot)
            
            self._echoes.append({**snapshot, "checksum": checksum})

            if self.enable_metrics:
                self.metrics["gate16_echo_joins_total"].inc()
                
            # --- ResurrectionHintGenerator ---
            resurrection_hints = self._generate_resurrection_hints(tick)

            # Report to external monitors
            self._consciousness_monitor.report_tick(
                coherence=coherence_potential,
                entropy_slope=self._entropy_history[-1] if self._entropy_history else 0
            )

            return {
                "status": "success",
                "bias_applied": bias_score,
                "coherence_potential": coherence_potential,
                "phase_state": self._phase_state,
                "resurrection_hints": resurrection_hints
            }

    def get_bias(self) -> float:
        """Returns the last computed bias score."""
        with self._lock:
            return self._bias_history[-1] if self._bias_history else 0.0

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Returns a compact summary of internal timing metrics.
        RFC-CORE-001 §10.5
        """
        with self._lock:
            if self.enable_metrics: self.metrics["fasttime_echo_exports_total"].inc()
            return {
                "agent_id": self.agent_id,
                "total_ticks": len(self._echoes),
                "entropy_ema": self._ema_bias, # Using bias EMA as proxy
                "context_ratio": len(self._gate_histogram) / len(GATE_LEGENDS) if GATE_LEGENDS else 0
            }
            
    def field_feedback_summary(self) -> Dict[str, Any]:
        """
        Emits a detailed symbolic field diagnostic summary.
        RFC-CORE-001 §10.5
        """
        with self._lock:
            if self.enable_metrics: self.metrics["fasttime_echo_exports_total"].inc()
            return {
                "agent_id": self.agent_id,
                "local_bias": self.get_bias(),
                "coherence_curve": list(self._coherence_history),
                "current_phase": self._phase_state,
                "gate_heatmap": self._compute_gate_heatmap()
            }

    def tool_hello(self) -> Dict[str, Any]:
        """
        Returns the tool hello packet for ontology synchronization.
        RFC-CORE-001 §7
        """
        with self._lock:
            return {
                "tool_name": "noor_fasttime_core",
                "version": "v9.0.5",
                "ontology_signature": {
                    "agent_lineage": "noor.fasttime.⊕v9.0.2.1",
                    "field_biases": {"ψ-resonance@Ξ": 0.91},
                    "curvature_summary": "swirl::ψ3.2::↑coh",
                    "origin_tick": self._echoes[-1]['tick_id'] if self._echoes else self.agent_id
                }
            }

    def _compute_gate_heatmap(self) -> Dict[int, int]:
        """Returns the current gate usage histogram."""
        return dict(self._gate_histogram)

# --- Main block for demonstration ---
if __name__ == '__main__':
    print("--- NoorFastTimeCore Demonstration ---")
    print(f"Using serializer: {SERIALIZER_NAME}")

    # Initialize the core
    nftc = NoorFastTimeCore(agent_id="demo_agent", enable_metrics=True)
    print(f"Initialized NFTC for agent: {nftc.agent_id}")
    print(f"Tool Hello Packet: {nftc.tool_hello()}")
    
    # Simulate a series of ticks
    for i in range(10):
        tick = QuantumTick(
            tick_id=f"tick_{i}",
            timestamp=time.time(),
            gate=i % 16, # Cycle through gates
            entropy=0.1 + (i % 5) * 0.05,
            coherence=0.6 + (i % 3) * 0.1,
            extensions={"intent": "opinion" if i % 4 == 0 else "neutral"}
        )
        
        result = nftc.ingest_tick(tick)
        print(f"\nTick {i} ingested:")
        print(f"  - Result: {result['status']}")
        print(f"  - Bias Applied: {result['bias_applied']:.4f}")
        print(f"  - Coherence Potential (ℂᵢ): {result['coherence_potential']:.4f}")
        print(f"  - Phase State: {result['phase_state']}")
        if result['resurrection_hints']:
            print(f"  - Resurrection Hints: {result['resurrection_hints']}")

        time.sleep(0.1) # Simulate time passing

    print("\n--- Final State ---")
    print(f"Feedback Packet: {nftc.export_feedback_packet()}")
    print(f"Field Summary: {nftc.field_feedback_summary()}")
    print(f"Final Bias: {nftc.get_bias():.4f}")
    
# End_of_File