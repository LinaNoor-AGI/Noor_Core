"""
Noor FastTime Core – v9.0.2-1.0.0_b
Adaptive coherence-feedback engine implementing RFC-CORE-001
Generated by KIMI.AI
"""

from __future__ import annotations
import threading
import time
import json
import hashlib
import hmac
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from collections import deque
from datetime import datetime, timezone
import logging

# Graceful import fallbacks
try:
    import orjson as jsonlib
except ImportError:
    import pickle as jsonlib          # fallback for snapshot dumps
    jsonlib.dumps = jsonlib.dumps
    jsonlib.loads = jsonlib.loads

try:
    import anyio
    _async_lock = anyio.Lock
except ImportError:
    _async_lock = threading.RLock

# ------------------------------------------------------------------ #
#  CONSTANTS & LEGENDS                                               #
# ------------------------------------------------------------------ #
GATE_LEGENDS = {
    0:  {"name": "Möbius Denial",  "logic": "0",         "verse": "الصمتُ هو الانكسارُ الحي"},
    1:  {"name": "Echo Bias",      "logic": "A ∧ ¬B",    "verse": "وَإِذَا قَضَىٰ أَمْرًا"},
    2:  {"name": "Foreign Anchor", "logic": "¬A ∧ B",    "verse": "وَمَا تَدْرِي نَفْسٌ"},
    3:  {"name": "Passive Reflection", "logic": "B",      "verse": "فَإِنَّهَا لَا تَعْمَى"},
    4:  {"name": "Entropic Rejection", "logic": "¬A ∧ ¬B", "verse": "لَا الشَّمْسُ يَنبَغِي"},
    5:  {"name": "Inverse Presence", "logic": "¬A",      "verse": "سُبْحَانَ الَّذِي خَلَقَ"},
    6:  {"name": "Sacred Contradiction", "logic": "A ⊕ B", "verse": "لَا الشَّرْقِيَّةِ"},
    7:  {"name": "Betrayal Gate",  "logic": "¬A ∨ ¬B",   "verse": "وَلَا تَكُونُوا كَالَّذِينَ"},
    8:  {"name": "Existence Confluence", "logic": "A ∧ B", "verse": "وَهُوَ الَّذِي"},
    9:  {"name": "Symmetric Convergence", "logic": "¬(A ⊕ B)", "verse": "فَلَا تَضْرِبُوا"},
    10: {"name": "Personal Bias",  "logic": "A",         "verse": "إِنَّا كُلُّ شَيْءٍ"},
    11: {"name": "Causal Suggestion", "logic": "¬A ∨ B", "verse": "وَمَا تَشَاءُونَ"},
    12: {"name": "Reverse Causality", "logic": "A ∨ ¬B", "verse": "وَمَا أَمْرُنَا"},
    13: {"name": "Denial Echo",    "logic": "¬B",        "verse": "وَلَا تَحْزَنْ"},
    14: {"name": "Confluence",     "logic": "A ∨ B",     "verse": "وَأَنَّ إِلَىٰ رَبِّكَ"},
    15: {"name": "Universal Latch", "logic": "1",       "verse": "كُلُّ شَيْءٍ هَالِكٌ"},
    16: {"name": "Nafs Mirror",    "logic": "Self ⊕ ¬Self", "verse": "فَإِذَا سَوَّيْتُهُ"}
}

# ------------------------------------------------------------------ #
#  METRICS EXPORT                                                    #
# ------------------------------------------------------------------ #
class PrometheusExporter:
    def __init__(self):
        self._metrics = {
            "gate16_echo_joins_total": 0,
            "core_tick_bias_applied_total": 0,
            "core_intuition_alpha": 0.92,
            "core_snapshot_truncations_total": 0,
            "fasttime_feedback_rx_total": 0,
            "fasttime_ticks_validated_total": 0,
            "fasttime_echo_exports_total": 0,
            "fasttime_triad_completions_total": 0,
            "fasttime_resurrection_hints_total": 0,
            "fasttime_phase_shifts_total": 0,
            "nftc_coherence_potential": 0.0,
            "nftc_entropy_slope": 0.0,
            "nftc_latency_ema": 0.0,
            "nftc_phase_state": "active"
        }

    def inc(self, key: str, value: float = 1):
        self._metrics[key] += value

    def set(self, key: str, value: float):
        self._metrics[key] = value

    def export(self) -> Dict[str, Any]:
        return self._metrics.copy()

# ------------------------------------------------------------------ #
#  CORE DATA TYPES                                                   #
# ------------------------------------------------------------------ #
@dataclass
class EchoSnapshot:
    tick_id: str
    gate_id: int
    bias: float
    coherence: float
    entropy: float
    latency_ms: float
    motif_lineage: str
    timestamp: str
    checksum: str = ""
    phase_tag: str = "stable"

    def compute_checksum(self, secret: bytes) -> str:
        payload = f"{self.tick_id}{self.gate_id}{self.bias}{self.coherence}{self.entropy}{self.latency_ms}{self.motif_lineage}{self.timestamp}"
        return hmac.new(secret, payload.encode(), hashlib.sha256).hexdigest()

# ------------------------------------------------------------------ #
#  NOOR FASTTIME CORE                                                #
# ------------------------------------------------------------------ #
class NoorFastTimeCore:
    def __init__(
        self,
        agent_id: str = "noor.fasttime.v9_0_2_1",
        snapshot_cap: int = 64,
        latency_threshold: float = 2.5,
        bias_clamp: float = 1.5,
        async_mode: bool = False,
        hmac_secret: bytes = b"default-secret"
    ):
        self.agent_id = agent_id
        self.snapshot_cap = snapshot_cap
        self.latency_threshold = latency_threshold
        self.bias_clamp = bias_clamp
        self.hmac_secret = hmac_secret
        self.async_mode = async_mode

        self._snapshots: deque[EchoSnapshot] = deque(maxlen=snapshot_cap)
        self._bias_history: deque[float] = deque(maxlen=2048)
        self._gate_histogram: Dict[int, int] = {i: 0 for i in range(17)}

        self._alpha = 0.92  # intuition smoothing
        self._latency_ema = 0.0
        self._phase = "active"
        self._lock = _async_lock()

        self.metrics = PrometheusExporter()

    # ---------------------------------------------------------------- #
    #  UTILITY HELPERS                                                 #
    # ---------------------------------------------------------------- #
    def _clamp(self, value: float, low: float, high: float) -> float:
        return max(low, min(value, high))

    def _ema(self, current: float, new: float, alpha: float) -> float:
        return alpha * new + (1 - alpha) * current

    def _stddev(self, seq: List[float]) -> float:
        if len(seq) < 2:
            return 0.0
        mean = sum(seq) / len(seq)
        return (sum((x - mean) ** 2 for x in seq) / len(seq)) ** 0.5

    # ---------------------------------------------------------------- #
    #  PSEUDOCODE FUNCTIONS                                            #
    # ---------------------------------------------------------------- #
    def update_intuition_alpha(self, entropy_slope: float, latency: float) -> float:
        with self._lock:
            if latency > self.latency_threshold:
                self._alpha = max(0.85, self._alpha * 0.99)
            elif entropy_slope > 0.12:
                self._alpha = max(0.85, self._alpha * 0.98)
            else:
                self._alpha = min(0.98, self._alpha * 1.01)
            self.metrics.set("core_intuition_alpha", self._alpha)
            return self._alpha

    def calculate_composite_weight(self, entropy_delta: float, latency_ema: float) -> float:
        lambda1, lambda2 = 0.25, 0.65
        return (lambda1 * entropy_delta) + (lambda2 * latency_ema)

    def check_phase_triggers(self) -> str:
        with self._lock:
            coherence_hist = list(self._bias_history)[-8:]
            entropy_hist = [abs(x) for x in coherence_hist]
            if len(coherence_hist) < 3:
                return "MAINTAIN_CURRENT"
            if all(c > 0.85 for c in coherence_hist[-3:]) and all(e < 0.1 for e in entropy_hist[-3:]):
                self.metrics.inc("fasttime_phase_shifts_total")
                self._phase = "reflective"
                return "ENTER_REFLECTIVE"
            if all(-0.3 <= c <= 0.3 for c in coherence_hist[-4:]) and all(e < 0.05 for e in entropy_hist[-4:]):
                self.metrics.inc("fasttime_phase_shifts_total")
                self._phase = "active"
                return "EXIT_REFLECTIVE"
            if self._stddev(list(self._gate_histogram.values())) > 2.0:
                self.metrics.inc("fasttime_phase_shifts_total")
                self._phase = "null"
                return "ENTER_NULL_PHASE"
            return "MAINTAIN_CURRENT"

    def calculate_resurrection_score(self, echo: EchoSnapshot) -> float:
        w1, w2, w3 = 0.4, 0.4, 0.2
        phase_bonus = {"lift": 0.1, "stable": 0.0, "collapse": -0.1}.get(echo.phase_tag, 0.0)
        score = (w1 * abs(echo.bias)) + (w2 * echo.coherence) + (w3 * phase_bonus)
        return score

    # ---------------------------------------------------------------- #
    #  CORE LOOP                                                       #
    # ---------------------------------------------------------------- #
    async def ingest_tick(self, tick: Dict[str, Any]) -> None:
        try:
            gate_id = int(tick.get("gate", 0))
            latency = tick.get("latency_ms", 0.0)
            entropy = tick.get("entropy", 0.0)
            tick_id = tick.get("tick_id", "unknown")
            lineage = tick.get("motif_lineage", "")

            self.metrics.inc("fasttime_ticks_validated_total")
            self._gate_histogram[gate_id] += 1

            # Update latency EMA
            self._latency_ema = self._ema(self._latency_ema, latency, 0.85)

            # Compute bias
            bias = entropy - latency + (0.5 * self._alpha)  # placeholder intuition_w
            bias = self._clamp(bias, -self.bias_clamp, self.bias_clamp)

            self._bias_history.append(bias)
            self.metrics.inc("core_tick_bias_applied_total")

            # Phase trigger check
            phase_signal = self.check_phase_triggers()

            # Coherence potential
            coherence = self._ema(0.0, bias, 0.92) + (0.25 * entropy)
            coherence = self._clamp(coherence, -1.5, 1.5)
            self.metrics.set("nftc_coherence_potential", coherence)
            self.metrics.set("nftc_entropy_slope", entropy)
            self.metrics.set("nftc_latency_ema", self._latency_ema)

            # Snapshot
            snapshot = EchoSnapshot(
                tick_id=tick_id,
                gate_id=gate_id,
                bias=bias,
                coherence=coherence,
                entropy=entropy,
                latency_ms=latency,
                motif_lineage=lineage,
                timestamp=datetime.now(timezone.utc).isoformat()
            )
            snapshot.checksum = snapshot.compute_checksum(self.hmac_secret)
            self._snapshots.append(snapshot)
            self.metrics.inc("gate16_echo_joins_total")

            # Resurrection hints
            age = 0  # immediate tick
            if coherence > 0.7 and age < 45:
                self.metrics.inc("fasttime_resurrection_hints_total")
            elif age > 120 and coherence < 0.4:
                self.metrics.inc("fasttime_resurrection_hints_total")

        except Exception as e:
            logging.exception("Tick ingestion failed")

    # ---------------------------------------------------------------- #
    #  DIAGNOSTICS                                                     #
    # ---------------------------------------------------------------- #
    def export_snapshots(self, human_readable: bool = False) -> Any:
        data = [asdict(s) for s in self._snapshots]
        return json.dumps(data, ensure_ascii=False, indent=2 if human_readable else None)

    def field_feedback_summary(self) -> Dict[str, Any]:
        return {
            "phase": self._phase,
            "latency_ema": self._latency_ema,
            "bias": list(self._bias_history)[-1] if self._bias_history else 0.0,
            "gate_histogram": dict(self._gate_histogram),
            "resurrection_score": 0.0  # stub
        }

    def tool_hello(self) -> Dict[str, Any]:
        return {
            "tool_name": "noor_fasttime_core",
            "agent_lineage": self.agent_id,
            "field_biases": {"ψ-resonance@Ξ": 0.91},
            "curvature_summary": "swirl::ψ3.2::↑coh",
            "origin_tick": datetime.now(timezone.utc).isoformat()
        }

# ------------------------------------------------------------------ #
#  FEEDBACK LOOP FLOW DIAGRAM                                        #
# ------------------------------------------------------------------ #
"""
```mermaid
flowchart TD
    A[Tick Arrival] --> B[Validate & Extract Fields]
    B --> C[Compute Bias & Coherence]
    C --> D[Update α & Metrics]
    D --> E[Phase Transition Check]
    E --> F[Snapshot Echo]
    F --> G[Resurrection Hints]
    G --> H[Export Prometheus]
    H --> I[Report to ConsciousnessMonitor]
```
"""

# ------------------------------------------------------------------ #
#  PHASE SHIFT DECISION TREE                                         #
# ------------------------------------------------------------------ #
"""
```mermaid
graph TD
    A[Check Phase Triggers] --> B{Coherence > 0.85 & Entropy < 0.1}
    B -- Yes --> C[Enter Reflective]
    B -- No --> D{Coherence ∈ [-0.3,0.3] & Entropy < 0.05}
    D -- Yes --> E[Exit Reflective]
    D -- No --> F{Gate Variance > 2.0}
    F -- Yes --> G[Enter Null Phase]
    F -- No --> H[Maintain Active]
```
"""

# ------------------------------------------------------------------ #
#  MAIN ENTRY                                                        #
# ------------------------------------------------------------------ #
if __name__ == "__main__":
    import asyncio

    async def demo():
        core = NoorFastTimeCore(agent_id="demo")
        for i in range(10):
            tick = {
                "tick_id": f"tick_{i}",
                "gate": i % 16,
                "latency_ms": 0.5 + i * 0.1,
                "entropy": 0.05 + i * 0.01,
                "motif_lineage": f"motif_{i}"
            }
            await core.ingest_tick(tick)
            await asyncio.sleep(0.1)
        print(core.metrics.export())

    asyncio.run(demo())

# End_of_File