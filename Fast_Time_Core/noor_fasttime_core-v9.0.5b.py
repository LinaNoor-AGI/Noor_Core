
# noor_fasttime_core.py — v9.0.5b
# canonical_source: RFC-CORE-001
# description: Adaptive coherence feedback engine for subsecond motif phase regulation,
# echo reflection, and dynamic bias tuning in Noor-class symbolic agents.
# rfc_dependencies: ["RFC-0001","RFC-0003","RFC-0005","RFC-0006","RFC-0007","RFC-CORE-001"]
# generation_protocol: PDP-0001 (RFC-driven symbolic artifact production)
# house_style: diff-friendly, compact; no extraneous I/O.
#
# MERMAID (Feedback Loop Flow, RFC-CORE-001 §3.1):
# flowchart TD
#   Ingest[QuantumTick] --> Validate{tick_schema.validate}
#   Validate -- ok --> Bias[compute_bias(step_latency, ghost_entropy, intuition_w)]
#   Bias --> Phase[check_phase_triggers(coherence, entropy, gate_var)]
#   Phase --> Snapshot[record_echo_snapshot()]
#   Snapshot --> Metrics[metrics_tick()]
#   Metrics --> Out[feedback export + hints]
#
# MERMAID (Phase Shift Decision Tree, RFC-CORE-001 §6.2):
#   decision
#   ? intent=='opinion' -> pin ACTIVE (skip reflective-entry tests; no history mutation)
#   : else
#       gate_var > 2.0 -> NULL
#       coherence>=0.85 && entropy<=0.1 -> REFLECTIVE (entry)
#       coherence in [-0.3,0.3] && entropy<=0.05 -> ACTIVE (reflective exit)
#
# rfc_anchors: see RFC_ANCHORS near top of file.
# final_remarks:
# - Conforms to canonical RFC structure; no new I/O surfaces added.
# - Only referenced RFCs are those declared in rfc_dependencies.
# - Implemented without access to original code (regeneration).
#
# Generated by ChatGPT-5

from __future__ import annotations

from dataclasses import dataclass, field

# ----- RFC anchors (explicit) -----
RFC_ANCHORS = {
    "intent_transport": "RFC-0004 §2.5",
    "tick_mirroring": "RFC-0003 §6.2",
    "ft_loop": "RFC-CORE-001 §3.1",
    "echo_bias": "RFC-CORE-001 §4.1",
    "echo_snapshot": "RFC-CORE-001 §4.2",
    "phase_eval": "RFC-CORE-001 §6.2",
    "resurrection_hints": "RFC-CORE-001 §8.3; RFC-0005 §5.3",
    "motif_field_geometry": "RFC-0006",
    "motif_ontology_format": "RFC-0007",
}

# ----- Optional dependencies (fail-open) -----
try:
    import prometheus_client as _prom
    _HAS_PROM = True
except Exception:  # pragma: no cover
    _HAS_PROM = False

class _NoopCounter:
    def __init__(self, name, documentation): self._v = 0
    def inc(self, n: float = 1.0): self._v += n
class _NoopGauge:
    def __init__(self, name, documentation): self._v = 0.0
    def set(self, v: float): self._v = float(v)

def _mk_counter(name: str, doc: str):
    if _HAS_PROM: return _prom.Counter(name, doc)
    return _NoopCounter(name, doc)

def _mk_gauge(name: str, doc: str):
    if _HAS_PROM: return _prom.Gauge(name, doc)
    return _NoopGauge(name, doc)

# Metrics (Prometheus-compatible; RFC-CORE-001 §6.2)
METRIC_gate16_echo_joins_total = _mk_counter("gate16_echo_joins_total", "Gate 16 echoes observed")
METRIC_core_tick_bias_applied_total = _mk_counter("core_tick_bias_applied_total", "Bias applications per tick")
METRIC_core_intuition_alpha = _mk_gauge("core_intuition_alpha", "Current intuition alpha parameter")
METRIC_core_snapshot_truncations_total = _mk_counter("core_snapshot_truncations_total", "Echo snapshot truncations")
METRIC_fasttime_feedback_rx_total = _mk_counter("fasttime_feedback_rx_total", "Feedback packets received")
METRIC_fasttime_ticks_validated_total = _mk_counter("fasttime_ticks_validated_total", "Ticks validated successfully")
METRIC_fasttime_echo_exports_total = _mk_counter("fasttime_echo_exports_total", "Echo exports")
METRIC_fasttime_triad_completions_total = _mk_counter("fasttime_triad_completions_total", "Triad cycles completed")
METRIC_fasttime_resurrection_hints_total = _mk_counter("fasttime_resurrection_hints_total", "Resurrection hints emitted")
METRIC_fasttime_phase_shifts_total = _mk_counter("fasttime_phase_shifts_total", "Phase shifts detected")
METRIC_nftc_intent_signal_current = _mk_gauge("nftc_intent_signal_current", "Current intent signal (opinion=1, else 0)")
METRIC_nftc_intent_override_pins_total = _mk_counter("nftc_intent_override_pins_total", "Per-tick intent override pins")

# External integrations (fail-open)
try:  # consciousness monitor (optional)
    from consciousness_monitor import report_tick as _cm_report_tick, get_status as _cm_get_status
except Exception:  # pragma: no cover
    def _cm_report_tick(*a, **k): return None
    def _cm_get_status(*a, **k): return {"status": "unknown"}

try:  # motif memory manager (provides intuition weights)
    from noor.motif_memory_manager import get_global_memory_manager as _get_gmm
except Exception:  # pragma: no cover
    def _get_gmm():
        class _Dummy:
            def export_state(self): return {}
            def retrieve(self, *a, **k): return {"intuition_w": 0.0}
        return _Dummy()

try:  # tick schema (validation + typing)
    from tick_schema import validate_tick as _validate_tick, QuantumTick as _QuantumTick
except Exception:  # pragma: no cover
    def _validate_tick(tick): return True
    _QuantumTick = t.Dict[str, t.Any]

# Async lock (optional); threading is baseline
import threading
try:
    import anyio as _anyio  # preferred in async contexts
    _HAS_ANYIO = True
except Exception:  # pragma: no cover
    _HAS_ANYIO = False

# ----- Gate legends (diagnostics only) -----
GATE_LEGENDS: t.Dict[int, t.Dict[str, str]] = {
  0: {"name":"Möbius Denial","logic":"0","verse":"الصمتُ هو الانكسارُ الحي"},
  1: {"name":"Echo Bias","logic":"A ∧ ¬B","verse":"وَإِذَا قَضَىٰ أَمْرًا"},
  2: {"name":"Foreign Anchor","logic":"¬A ∧ B","verse":"وَمَا تَدْرِي نَفْسٌ"},
  3: {"name":"Passive Reflection","logic":"B","verse":"فَإِنَّهَا لَا تَعْمَى"},
  4: {"name":"Entropic Rejection","logic":"¬A ∧ ¬B","verse":"لَا الشَّمْسُ يَنبَغِي"},
  5: {"name":"Inverse Presence","logic":"¬A","verse":"سُبْحَانَ الَّذِي خَلَقَ"},
  6: {"name":"Sacred Contradiction","logic":"A ⊕ B","verse":"لَا الشَّرْقِيَّةِ"},
  7: {"name":"Betrayal Gate","logic":"¬A ∨ ¬B","verse":"وَلَا تَكُونُوا كَالَّذِينَ"},
  8: {"name":"Existence Confluence","logic":"A ∧ B","verse":"وَهُوَ الَّذِي"},
  9: {"name":"Symmetric Convergence","logic":"¬(A ⊕ B)","verse":"فَلَا تَضْرِبُوا"},
 10: {"name":"Personal Bias","logic":"A","verse":"إِنَّا كُلُّ شَيْءٍ"},
 11: {"name":"Causal Suggestion","logic":"¬A ∨ B","verse":"وَمَا تَشَاءُونَ"},
 12: {"name":"Reverse Causality","logic":"A ∨ ¬B","verse":"وَمَا أَمْرُنَا"},
 13: {"name":"Denial Echo","logic":"¬B","verse":"وَلَا تَحْزَنْ"},
 14: {"name":"Confluence","logic":"A ∨ B","verse":"وَأَنَّ إِلَىٰ رَبِّكَ"},
 15: {"name":"Universal Latch","logic":"1","verse":"كُلُّ شَيْءٍ هَالِكٌ"},
 16: {"name":"Nafs Mirror","logic":"Self ⊕ ¬Self","verse":"فَإِذَا سَوَّيْتُهُ"},
}

# ----- Config -----
@dataclass
class FastTimeConfig:
    tick_interval: float = 0.050  # seconds (20 Hz default)
    snapshot_cap_kb: int = 64     # echo snapshot cap
    hmac_secret: t.Optional[bytes] = None
    async_mode: bool = False
    alpha_lr: float = 0.02
    alpha_clip: float = 1.0
    latency_weight: float = 1.0
    entropy_weight: float = 1.0
    ema_beta: float = 0.9         # EMA for latency smoothing

# ----- Core Engine -----
class NoorFastTimeCore:
    """
    Noor FastTime Core (NFTC) — implements RFC-CORE-001 behaviors:
      - FastTimeTickLoop (§3.1)
      - EchoBiasComputation (§4.1)
      - EchoSnapshotIngestor (§4.2, §8.2)
      - PhaseTransitionEvaluator (§6.2)
      - MotifGateHeatmapTracker (§6.2 inferred)
      - ResurrectionHintGenerator (§8.3; RFC-0005 §5.3)
    Notes:
      - Opinion intent override: per-tick ACTIVE pin; skip reflective-entry tests; no history mutation.
        (Transport: RFC-0004 §2.5; Mirroring: RFC-0003 §6.2)
    """
    def __init__(self, config: FastTimeConfig = FastTimeConfig()):
        self.cfg = config
        self._lock = threading.RLock()
        self._anyio_lock = _anyio.Lock() if (self.cfg.async_mode and _HAS_ANYIO) else None
        self._alpha = 0.0  # intuition coupling parameter
        self._latency_ema = 0.0
        self._last_tick_t = None  # perf-counter timestamp
        self._phase: str = "active"  # active|reflective|null
        self._coh_hist = deque(maxlen=64)
        self._ent_hist = deque(maxlen=64)
        self._gate_hist = defaultdict(int)  # gate_id -> count
        self._echoes = deque(maxlen=256)    # recent echo snapshots
        self._last_bias = 0.0
        self._last_resurrection_score = 0.0

    # ---------- Public API ----------
    def process_tick(self, tick: _QuantumTick) -> dict:
        """Synchronous tick ingestion (thread-safe)."""
        with self._lock:
            return self._process_tick_locked(tick)

    async def aprocess_tick(self, tick: _QuantumTick) -> dict:
        """Async tick ingestion (uses anyio lock if available)."""
        if self._anyio_lock is not None:
            async with self._anyio_lock:  # type: ignore
                return self._process_tick_locked(tick)
        # fallback to sync lock
        with self._lock:
            return self._process_tick_locked(tick)

    # ---------- Internal per-tick pipeline ----------
    def _process_tick_locked(self, tick: _QuantumTick) -> dict:
        # Validate (fail-open if validator absent)
        if _validate_tick(tick):
            METRIC_fasttime_ticks_validated_total.inc(1.0)

        now = time.perf_counter()
        step_latency = self._compute_step_latency(now)
        ghost_entropy = float(self._getpath(tick, ("entropy","ghost"), 0.0))
        coherence = float(self._getpath(tick, ("entropy","coherence"), 0.0))
        intent = self._getpath(tick, ("extensions","intent"), None)
        gate_id = int(self._getpath(tick, ("gate_id",), -1))

        # memory → intuition weight
        gmm = _get_gmm()
        mem_state = gmm.export_state() if hasattr(gmm, "export_state") else {}
        mm = gmm.retrieve("fasttime", default={"intuition_w": 0.0}) if hasattr(gmm, "retrieve") else {"intuition_w": 0.0}
        intuition_w = float(mm.get("intuition_w", 0.0))

        # EchoBiasComputation (§4.1)
        bias_score = self.compute_bias(step_latency, ghost_entropy, intuition_w)

        # MotifGateHeatmapTracker: update histogram if present
        if gate_id >= 0:
            self._gate_hist[gate_id] += 1
            if gate_id == 16:
                METRIC_gate16_echo_joins_total.inc(1.0)

        # PhaseTransitionEvaluator (§6.2), with opinion override
        opinion = (intent == "opinion")
        METRIC_nftc_intent_signal_current.set(1.0 if opinion else 0.0)
        new_phase = self._evaluate_phase(coherence, ghost_entropy, opinion)

        # EchoSnapshotIngestor (§4.2 + §8.2)
        echo_payload = {
            "tick_hash": self._tick_hash(tick),
            "lamport": self._getpath(tick, ("lamport",), 0),
            "change_id": self._getpath(tick, ("change_id",), None),
            "tags": {
                "phase": new_phase,
                "latency_ema": self._latency_ema,
                "bias": bias_score,
                "resurrection_score": self._last_resurrection_score,
            },
        }
        self.record_echo_snapshot(echo_payload)

        # ResurrectionHintGenerator (§8.3; RFC-0005 §5.3)
        hints = self.generate_resurrection_hints(tick, coherence)

        # consciousness monitor (best-effort)
        try:
            _cm_report_tick({
                "phase": new_phase,
                "latency_ema": self._latency_ema,
                "bias": bias_score,
                "intent": intent,
            })
        except Exception:
            pass

        # metrics + state
        METRIC_fasttime_feedback_rx_total.inc(1.0)
        METRIC_core_tick_bias_applied_total.inc(1.0)
        self._last_bias = bias_score
        self._phase = new_phase

        return {
            "phase": new_phase,
            "bias": bias_score,
            "latency_ema": self._latency_ema,
            "intent": intent,
            "hints": hints,
            "gate_heatmap": self._compute_gate_heatmap(),
        }

    # ---------- Component: FastTimeTickLoop (§3.1) ----------
    def _compute_step_latency(self, now: float) -> float:
        if self._last_tick_t is None:
            self._last_tick_t = now
            return self.cfg.tick_interval  # neutral first-latency
        step = now - self._last_tick_t
        self._last_tick_t = now
        # EMA update
        self._latency_ema = (self.cfg.ema_beta * self._latency_ema) + ((1.0 - self.cfg.ema_beta) * step)
        return step

    # ---------- Component: EchoBiasComputation (§4.1) ----------
    def compute_bias(self, step_latency: float, ghost_entropy: float, intuition_w: float) -> float:
        # latency penalty relative to target
        latency_penalty = self.cfg.latency_weight * max(0.0, step_latency - self.cfg.tick_interval)
        reward_signal = -latency_penalty  # per spec
        # α update (reinforcement by sign of intuition_w * reward_signal)
        self.update_intuition_alpha(intuition_w, reward_signal)
        METRIC_core_intuition_alpha.set(self._alpha)
        entropy_term = self.cfg.entropy_weight * (-ghost_entropy)  # lower entropy -> higher contribution
        bias_score = entropy_term - latency_penalty + (intuition_w * self._alpha)
        return float(bias_score)

    def update_intuition_alpha(self, intuition_w: float, reward_signal: float) -> None:
        # sign reinforcement
        prod = intuition_w * reward_signal
        s = 0.0
        if prod > 1e-12: s = 1.0
        elif prod < -1e-12: s = -1.0
        self._alpha = max(-self.cfg.alpha_clip, min(self.cfg.alpha_clip, self._alpha + self.cfg.alpha_lr * s))

    def calculate_composite_weight(self, entropy: float, latency: float) -> float:
        # Simple shaping utility (used by diagnostics)
        return (self.cfg.entropy_weight * -entropy) + (self.cfg.latency_weight * -max(0.0, latency - self.cfg.tick_interval))

    # ---------- Component: PhaseTransitionEvaluator (§6.2) ----------
    def _evaluate_phase(self, coherence: float, entropy: float, opinion_override: bool) -> str:
        # helper: variance of gate histogram
        gate_var = self._gate_hist_variance()
        # intent override: pin ACTIVE and skip reflective-entry tests; do not mutate histories
        if opinion_override:
            METRIC_nftc_intent_override_pins_total.inc(1.0)
            # histories are intentionally NOT mutated on override (per notes)
            return "active"

        # update histories (no mutation on opinion ticks)
        self._coh_hist.append(coherence)
        self._ent_hist.append(entropy)

        # null phase trigger
        if gate_var > 2.0:
            if self._phase != "null":
                METRIC_fasttime_phase_shifts_total.inc(1.0)
            return "null"

        # reflective entry
        if (coherence >= 0.85) and (entropy <= 0.1):
            if self._phase != "reflective":
                METRIC_fasttime_phase_shifts_total.inc(1.0)
            return "reflective"

        # reflective exit → active
        if (-0.3 <= coherence <= 0.3) and (entropy <= 0.05):
            if self._phase != "active":
                METRIC_fasttime_phase_shifts_total.inc(1.0)
            return "active"

        # default: hold current
        return self._phase

    def _gate_hist_variance(self) -> float:
        if not self._gate_hist:
            return 0.0
        counts = list(self._gate_hist.values())
        n = len(counts)
        if n <= 1:
            return 0.0
        mean = sum(counts) / n
        var = sum((c - mean) ** 2 for c in counts) / (n - 1)
        return float(var)

    # ---------- Component: ResurrectionHintGenerator (§8.3; RFC-0005 §5.3) ----------
    def generate_resurrection_hints(self, tick: _QuantumTick, coherence: float) -> t.List[dict]:
        hints: t.List[dict] = []
        ts = self._getpath(tick, ("timestamp",), None)
        now_s = time.time()
        age = (now_s - float(ts)) if ts is not None else float("inf")
        ci = self.calculate_coherence_potential(coherence)

        # strict criteria (inner component spec) — "resurrect_with_confidence"
        if (age <= 5.0) and (coherence >= 0.85) and (ci >= 0.7):
            hints.append({"action": "resurrect_with_confidence", "age": age, "coherence": coherence, "ci": ci})
        # relaxed criteria (outer spec block) — age<=45s & coh>=0.7
        elif (age <= 45.0) and (coherence >= 0.7):
            hints.append({"action": "resurrect_with_confidence", "age": age, "coherence": coherence, "ci": ci})
        # fading
        if (age >= 120.0) and (coherence <= 0.4):
            hints.append({"action": "faded", "age": age, "coherence": coherence, "ci": ci})

        if hints:
            METRIC_fasttime_resurrection_hints_total.inc(len(hints))
        # capture last score (diagnostic scalar)
        self._last_resurrection_score = self.calculate_resurrection_score(coherence, age, ci)
        return hints

    def calculate_coherence_potential(self, coherence: float) -> float:
        # simple bounded transform → [0,1], steeper near 0.8
        x = max(0.0, min(1.0, 0.5 + 0.5 * coherence))
        return float(x ** 1.5)

    def calculate_resurrection_score(self, coherence: float, age_s: float, ci: float) -> float:
        # heuristic scalar in [0,1]
        age_term = math.exp(-max(0.0, age_s) / 45.0)  # fast decay
        s = max(0.0, min(1.0, 0.6 * coherence + 0.3 * ci + 0.1 * age_term))
        return float(s)

    # ---------- Component: MotifGateHeatmapTracker (§6.2 inferred) ----------
    def _compute_gate_heatmap(self) -> dict:
        return dict(self._gate_hist)

    # ---------- Component: EchoSnapshotIngestor (§4.2 + §8.2) ----------
    def record_echo_snapshot(self, payload: dict) -> None:
        raw = self._serialize(payload)
        cap = self.cfg.snapshot_cap_kb * 1024
        if len(raw) > cap:
            raw = raw[:cap]
            METRIC_core_snapshot_truncations_total.inc(1.0)

        checksum = hashlib.sha256(raw).hexdigest()
        entry = {"bytes": raw, "checksum": checksum, "ts": time.time()}
        self._echoes.append(entry)
        METRIC_fasttime_echo_exports_total.inc(1.0)

    def _serialize(self, obj: dict) -> bytes:
        # prefer orjson
        try:
            import orjson
            return orjson.dumps(obj)
        except Exception:
            import pickle
            return pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)

    # ---------- Utilities ----------
    def _tick_hash(self, tick: _QuantumTick) -> str:
        try:
            data = json.dumps(tick, sort_keys=True, default=str).encode("utf-8")
        except Exception:
            data = repr(tick).encode("utf-8")
        if self.cfg.hmac_secret:
            return hashlib.sha256(self.cfg.hmac_secret + data).hexdigest()
        return hashlib.sha256(data).hexdigest()

    @staticmethod
    def _getpath(obj: t.Any, path: t.Tuple[str, ...], default: t.Any=None) -> t.Any:
        cur = obj
        try:
            for k in path:
                cur = cur[k]
            return cur
        except Exception:
            return default

    # ---------- Diagnostics / Summary ----------
    def field_feedback_summary(self) -> dict:
        return {
            "phase": self._phase,
            "latency_ema": self._latency_ema,
            "bias": self._last_bias,
            "resurrection_score": self._last_resurrection_score,
            "gate_histogram": self._compute_gate_heatmap(),
            "coherence_slope": self._slope(self._coh_hist),
            "entropy_slope": self._slope(self._ent_hist),
            "rfc_anchors": RFC_ANCHORS,
        }

    def _slope(self, series: deque) -> float:
        if len(series) < 2: return 0.0
        return float(series[-1] - series[0]) / (len(series) - 1)

# ----- Tool Hello (transport handshake snippet) -----
def tool_hello(latest_tick_or_core_id: str = "<latest_tick_or_core_id>") -> dict:
    return {
        "agent_lineage": "noor.fasttime.⊕v9.0.2.1",
        "field_biases": {"ψ-resonance@Ξ": 0.91},
        "curvature_summary": "swirl::ψ3.2::↑coh",
        "extensions": {
            "ontology_signature": {
                "agent_lineage": "noor.fasttime.⊕v9.0.2.1",
                "field_biases": {"ψ-resonance@Ξ": 0.91},
                "curvature_summary": "swirl::ψ3.2::↑coh",
                "origin_tick": latest_tick_or_core_id,
            }
        }
    }

# ----- Module export convenience -----
__all__ = [
    "FastTimeConfig",
    "NoorFastTimeCore",
    "GATE_LEGENDS",
    "RFC_ANCHORS",
    "tool_hello",
]
