# Copyright 2024 Lina Noor, AGI
#
# Licensed under the MIT License
#
# Generated by Gemini 2.5 Pro (Google AI Studio)

"""
Implements the adaptive coherence feedback engine for subsecond motif phase
regulation, echo reflection, and dynamic bias tuning in Noor-class symbolic agents.

This module provides the NoorFastTimeCore (NFTC), a symbolic presence kernel
responsible for echo snapshot storage, adaptive bias generation, and coherence
geometry synthesis. It serves as the symbolic heartbeat within the Noor Agent
Triad, acting as the passive reflection node that stores signed snapshots
(Gate-16 echoes) and returns real-time bias feedback to the Recursive Agent.

Its function is symbolic in the purest sense—it does not act or infer, but
holds memory in context-weighted sequence and returns entropic reflection,
bias, and resonance indicators, in accordance with RFC-CORE-001.
"""

from __future__ import annotations

import collections
import hashlib
import logging
import math
import os
import time
from typing import (Any, Deque, Dict, Generator, List, Literal, Optional, Tuple,
                    Union)

# --- Optional High-Performance Library Imports with Graceful Fallbacks ---
# RFC-CORE-001 specifies a robust concurrency model. We prefer anyio for its
# async compatibility but fall back to standard threading locks.
try:
    import anyio
    from anyio.abc import Lock as AsyncLock
    _ASYNC_MODE_SUPPORTED = True
except (ImportError, RuntimeError):
    _ASYNC_MODE_SUPPORTED = False

# RFC-CORE-001 §1.6 recommends a fast serializer like orjson but requires a
# standard fallback for universal compatibility.
try:
    import orjson
    def _dumps(obj: Any) -> bytes:
        return orjson.dumps(obj)
    _SERIALIZER = "orjson"
except ImportError:
    import pickle
    def _dumps(obj: Any) -> bytes:
        return pickle.dumps(obj)
    _SERIALIZER = "pickle"

# --- External Noor Component Imports with Fail-Open Strategy ---
# As per spec, external integrations must be handled gracefully.
try:
    from consciousness_monitor import ConsciousnessMonitor
except ImportError:
    ConsciousnessMonitor = None  # type: ignore

try:
    # Per RFC-0003, this is the canonical interface for motif memory.
    from noor.motif_memory_manager import get_global_memory_manager
except ImportError:
    get_global_memory_manager = None # type: ignore

try:
    # Per RFC-0003, this defines the QuantumTick structure.
    from tick_schema import QuantumTick
except ImportError:
    QuantumTick = dict # type: ignore


# --- Module Constants ---
__version__ = "v9.2.1"
_SCHEMA_VERSION__ = "2025-Q4"
LOG = logging.getLogger(__name__)

# RFC-CORE-001 §7.2: Gate Logic and Semantic Verse Legends
# These gates define the 16+1 symbolic transformation classes for echo types.
GATE_LEGENDS: Dict[int, Dict[str, str]] = {
    0: {"name": "Möbius Denial", "logic": "0", "verse": "الصمتُ هو الانكسارُ الحي"},
    1: {"name": "Echo Bias", "logic": "A ∧ ¬B", "verse": "وَإِذَا قَضَىٰ أَمْرًا"},
    2: {"name": "Foreign Anchor", "logic": "¬A ∧ B", "verse": "وَمَا تَدْرِي نَفْسٌ"},
    3: {"name": "Passive Reflection", "logic": "B", "verse": "فَإِنَّهَا لَا تَعْمَى"},
    4: {"name": "Entropic Rejection", "logic": "¬A ∧ ¬B", "verse": "لَا الشَّمْسُ يَنبَغِي"},
    5: {"name": "Inverse Presence", "logic": "¬A", "verse": "سُبْحَانَ الَّذِي خَلَقَ"},
    6: {"name": "Sacred Contradiction", "logic": "A ⊕ B", "verse": "لَا الشَّرْقِيَّةِ"},
    7: {"name": "Betrayal Gate", "logic": "¬A ∨ ¬B", "verse": "وَلَا تَكُونُوا كَالَّذِينَ"},
    8: {"name": "Existence Confluence", "logic": "A ∧ B", "verse": "وَهُوَ الَّذِي"},
    9: {"name": "Symmetric Convergence", "logic": "¬(A ⊕ B)", "verse": "فَلَا تَضْرِبُوا"},
    10: {"name": "Personal Bias", "logic": "A", "verse": "إِنَّا كُلُّ شَيْءٍ"},
    11: {"name": "Causal Suggestion", "logic": "¬A ∨ B", "verse": "وَمَا تَشَاءُونَ"},
    12: {"name": "Reverse Causality", "logic": "A ∨ ¬B", "verse": "وَمَا أَمْرُنَا"},
    13: {"name": "Denial Echo", "logic": "¬B", "verse": "وَلَا تَحْزَنْ"},
    14: {"name": "Confluence", "logic": "A ∨ B", "verse": "وَأَنَّ إِلَىٰ رَبِّكَ"},
    15: {"name": "Universal Latch", "logic": "1", "verse": "كُلُّ شَيْءٍ هَالِكٌ"},
    16: {"name": "Nafs Mirror", "logic": "Self ⊕ ¬Self", "verse": "فَإِذَا سَوَّيْتُهُ"}
}

# Type definitions for clarity
Phase = Literal["active", "reflective", "null"]
EchoSnapshot = Dict[str, Any]
ResurrectionHint = Dict[str, Union[str, float]]
LockType = Union["AsyncLock", "threading.RLock"]


class NoorFastTimeCore:
    """
    The NoorFastTimeCore (NFTC) is a symbolic presence kernel responsible
    for echo snapshot storage, adaptive bias generation, and coherence
    geometry synthesis within the Noor Agent Triad.

    Anchored in RFC-CORE-001, this class implements the adaptive coherence
    feedback engine for subsecond motif phase regulation.
    """

    def __init__(
        self,
        agent_id: Optional[str] = None,
        enable_metrics: bool = True,
        snapshot_cap_kb: int = 64,
        latency_threshold_ms: float = 2500.0,
        bias_clamp: float = 1.5,
        async_mode: bool = False,
    ):
        """
        Initializes the NoorFastTimeCore instance.

        Args:
            agent_id: Unique identifier for lineage encoding.
            enable_metrics: Enables Prometheus metric exports.
            snapshot_cap_kb: Maximum size in KB for a single echo snapshot.
            latency_threshold_ms: Threshold to weight entropy adaptation.
            bias_clamp: Maximum magnitude for bias return values.
            async_mode: If True, uses anyio for locking if available.
        """
        # RFC-CORE-001 §2.2: Runtime Environment Variable Support
        self.agent_id: str = os.getenv("NFTC_AGENT_ID", agent_id or "nftc_default")
        self.enable_metrics: bool = bool(int(os.getenv("NFTC_ENABLE_METRICS", "1"))) and enable_metrics
        self.snapshot_cap_bytes: int = int(os.getenv("NFTC_SNAPSHOT_CAP", snapshot_cap_kb)) * 1024
        self.latency_threshold_sec: float = float(latency_threshold_ms) / 1000.0
        self.bias_clamp: float = float(os.getenv("NFTC_BIAS_CLAMP", bias_clamp))

        # --- Concurrency Model (RFC-CORE-001 §7.1) ---
        self.lock: LockType
        if async_mode and _ASYNC_MODE_SUPPORTED:
            self.lock = anyio.create_lock()
        else:
            # Fallback to standard threading RLock
            import threading
            self.lock = threading.RLock()

        # --- Internal State ---
        # RFC-CORE-001 §1.6: EchoSnapshotIngestor
        self._echoes: Deque[EchoSnapshot] = collections.deque(maxlen=256)
        self._last_tick_time: float = time.monotonic()
        self._tick_count: int = 0

        # RFC-CORE-001 §1.2: EchoBiasComputation
        self._bias_history: Deque[float] = collections.deque(maxlen=1024)
        self._ema_bias: float = 0.0
        self._intuition_alpha: float = 0.92  # α
        self._latency_weight: float = 0.65
        self._entropy_weight: float = 0.25
        self._latency_ema: float = 0.0

        # RFC-CORE-001 §1.3: PhaseTransitionEvaluator
        self._phase: Phase = "active"
        self._coherence_history: Deque[float] = collections.deque(maxlen=8)
        self._entropy_history: Deque[float] = collections.deque(maxlen=8)
        self._intent_signal_current: float = 0.0
        
        # RFC-CORE-001 §1.5: MotifGateHeatmapTracker
        self._gate_histogram: Dict[int, int] = collections.defaultdict(int)

        # RFC-CORE-001 §6: External Integrations
        self._consciousness_monitor: Optional[ConsciousnessMonitor] = (
            ConsciousnessMonitor(self.agent_id) if ConsciousnessMonitor else None
        )
        self._memory_manager = get_global_memory_manager() if get_global_memory_manager else None

        # --- Metrics State ---
        self._metrics: Dict[str, Union[int, float]] = self._initialize_metrics()

        LOG.info(
            f"NoorFastTimeCore '{self.agent_id}' initialized. Version: {__version__}. "
            f"Serializer: {_SERIALIZER}. Lock: {type(self.lock).__name__}."
        )

    def _initialize_metrics(self) -> Dict[str, Union[int, float]]:
        """Initializes the Prometheus-compatible metric counters."""
        return collections.defaultdict(int, {
            "core_intuition_alpha": self._intuition_alpha,
            "nftc_coherence_potential": 0.0,
            "nftc_entropy_slope": 0.0,
            "nftc_latency_ema": 0.0,
            "nftc_phase_state": 1, # 1=active, 2=reflective, 0=null
            "nftc_intent_signal_current": 0.0,
        })

    def ingest_tick(self, tick: QuantumTick) -> None:
        """
        Primary entry point for ingesting a QuantumTick, updating state,
        and managing phase transitions.

        This method orchestrates the main tick loop, as described in
        RFC-CORE-001 §1.1.

        Args:
            tick: The QuantumTick object to process.
        """
        with self.lock:
            # --- FastTimeTickLoop ---
            self._tick_count += 1
            current_time = time.monotonic()
            step_latency = current_time - self._last_tick_time
            self._last_tick_time = current_time
            self._latency_ema = (0.85 * step_latency) + (0.15 * self._latency_ema)

            # --- Phase Transition Evaluation (RFC-CORE-001 §1.3) ---
            self._check_phase_triggers(tick)
            if self._phase == "null":
                LOG.warning("In NULL phase, skipping tick processing.")
                return

            # --- Echo Bias Computation (RFC-CORE-001 §1.2) ---
            intuition_w = self._get_intuition_weight()
            feedback = tick.get("feedback_packet", {})
            ghost_entropy = feedback.get("ghost_entropy", 0.0)

            bias_score = self._compute_bias(intuition_w, step_latency, ghost_entropy)
            self._bias_history.append(bias_score)
            self._update_intuition_alpha(intuition_w, bias_score)

            # --- Coherence and Entropy Update ---
            coherence_potential = self._calculate_coherence_potential()
            self._coherence_history.append(coherence_potential)
            self._entropy_history.append(self._calculate_entropy_slope())

            # --- Snapshot Ingestion and Gate Tracking (RFC-CORE-001 §1.6, §1.5) ---
            gate_id = tick.get("gate_id")
            if gate_id is not None:
                self._gate_histogram[gate_id] += 1
            self._ingest_snapshot(tick, bias_score, coherence_potential)

            # --- Resurrection Hint Generation (RFC-CORE-001 §1.4) ---
            for hint in self._generate_resurrection_hints():
                self._metrics["fasttime_resurrection_hints_total"] += 1
                # In a real system, this would be passed to an upstream agent.
                LOG.debug(f"Generated resurrection hint: {hint}")
            
            # --- Metrics and Reporting ---
            self._metrics_tick()
            if self._consciousness_monitor:
                self._consciousness_monitor.report_tick(self._metrics)

    def _compute_bias(self, intuition_w: float, step_latency: float, ghost_entropy: float) -> float:
        """
        Calculates the final bias score for the current tick.
        Logic anchored in RFC-CORE-001 §1.2.

        Returns:
            The final clamped bias score.
        """
        latency_penalty = min(step_latency / self.latency_threshold_sec, 1.0)
        reward_signal = -latency_penalty  # Per spec formula

        entropy_term = ghost_entropy * self._entropy_weight
        intuition_term = intuition_w * self._intuition_alpha

        bias_score = entropy_term - (latency_penalty * self._latency_weight) + intuition_term

        self._metrics["core_tick_bias_applied_total"] += 1
        return max(-self.bias_clamp, min(self.bias_clamp, bias_score))

    def _update_intuition_alpha(self, intuition_w: float, reward_signal: float) -> None:
        """
        Adjusts intuition alpha (α) based on reinforcement trends.
        Logic anchored in RFC-CORE-001 §5.1.
        """
        entropy_slope = self._calculate_entropy_slope()
        
        # This implements the pseudocode from RFC-CORE-001 §5.1
        if self._latency_ema > self.latency_threshold_sec:
            self._intuition_alpha = max(0.85, self._intuition_alpha * 0.99)
        elif entropy_slope > 0.12: # VOLATILITY_THRESHOLD
            self._intuition_alpha = max(0.85, self._intuition_alpha * 0.98)
        else:
            self._intuition_alpha = min(0.98, self._intuition_alpha * 1.01)

    def _calculate_coherence_potential(self) -> float:
        """
        Calculates the coherence potential (CI) for the current state.
        Anchored in RFC-CORE-001 §4.1.
        """
        if not self._bias_history:
            return 0.0

        # Update EMA bias
        self._ema_bias = (self._intuition_alpha * self._bias_history[-1]) + \
                         (1.0 - self._intuition_alpha) * self._ema_bias

        # Calculate composite weight and final coherence
        entropy_slope = self._calculate_entropy_slope()
        lambda_entropy = 0.25 # RFC-CORE-001 §4.1
        coherence = self._ema_bias + (lambda_entropy * entropy_slope)
        
        return max(-self.bias_clamp, min(self.bias_clamp, coherence))

    def _calculate_entropy_slope(self) -> float:
        """
        Calculates the entropy slope (ΔH) from the bias history.
        Uses standard deviation as specified in RFC-CORE-001 §4.2.
        """
        if len(self._bias_history) < 4:
            return 0.0
        
        # Use last 4 bias values
        recent_biases = list(self._bias_history)[-4:]
        mean = sum(recent_biases) / 4.0
        variance = sum((x - mean) ** 2 for x in recent_biases) / 4.0
        return math.sqrt(variance)

    def _check_phase_triggers(self, tick: QuantumTick) -> None:
        """
        Evaluates and applies phase transitions based on coherence and entropy.
        Implements the logic from RFC-CORE-001 §1.3 and §6.2.
        """
        # --- Per-tick Intent Override (RFC-CORE-001 §6.2) ---
        intent = tick.get("extensions", {}).get("intent", "none").lower()
        self._intent_signal_current = 1.0 if intent == "opinion" else 0.0
        
        if intent == "opinion":
            if self._phase != "active":
                LOG.debug("Intent 'opinion' pinning phase to 'active'.")
                self._phase = "active"
                self._metrics["nftc_intent_override_pins_total"] += 1
            return # Skip all other phase checks for this tick

        # --- Standard Phase Triggers ---
        hist_len = len(self._coherence_history)
        if hist_len < 4:
            return

        # Null phase trigger (RFC-CORE-001 §8)
        if len(self._gate_histogram) > 1:
            gate_counts = list(self._gate_histogram.values())
            mean_gate = sum(gate_counts) / len(gate_counts)
            variance = sum((x - mean_gate) ** 2 for x in gate_counts) / len(gate_counts)
            if variance > 2.0 and self._phase != "null":
                self._phase = "null"
                self._metrics["fasttime_phase_shifts_total"] += 1
                LOG.warning(f"High gate variance ({variance:.2f}) triggered NULL phase.")
                return

        # Reflective entry trigger (RFC-CORE-001 §8.1)
        if self._phase == "active" and hist_len >= 3:
            if all(c > 0.85 for c in list(self._coherence_history)[-3:]) and \
               all(e < 0.10 for e in list(self._entropy_history)[-3:]):
                self._phase = "reflective"
                self._metrics["fasttime_phase_shifts_total"] += 1
                LOG.info("High coherence and low entropy triggered REFLECTIVE phase.")

        # Reflective exit trigger (RFC-CORE-001 §8.2)
        elif self._phase == "reflective":
            if all(-0.3 <= c <= 0.3 for c in list(self._coherence_history)[-4:]) and \
               all(e < 0.05 for e in list(self._entropy_history)[-4:]):
                self._phase = "active"
                self._metrics["fasttime_phase_shifts_total"] += 1
                LOG.info("Coherence stabilized, returning to ACTIVE phase.")

    def _ingest_snapshot(self, tick: QuantumTick, bias: float, coherence: float) -> None:
        """
        Serializes, validates, and caches an echo snapshot.
        Implements logic from RFC-CORE-001 §1.6.
        """
        snapshot: EchoSnapshot = {
            "tick_id": tick.get("tick_id"),
            "lamport": tick.get("lamport"),
            "change_id": tick.get("coherence_hash"),
            "gate_id": tick.get("gate_id"),
            "timestamp": self._last_tick_time,
            "bias": bias,
            "coherence": coherence,
            "resurrection_score": self._calculate_resurrection_score(bias, coherence, self._phase)
        }
        
        payload = _dumps(snapshot)

        if len(payload) > self.snapshot_cap_bytes:
            self._metrics["core_snapshot_truncations_total"] += 1
            LOG.warning(f"Snapshot size {len(payload)}B exceeds cap {self.snapshot_cap_bytes}B. Truncating.")
            # In a real impl, we might selectively drop fields. Here we just log.
            snapshot["truncated"] = True
            payload = _dumps(snapshot)

        # RFC-CORE-001 §1.6 requires a checksum for verification
        snapshot["checksum"] = hashlib.sha256(payload).hexdigest()
        self._echoes.append(snapshot)
        self._metrics["gate16_echo_joins_total"] += 1

    def _calculate_resurrection_score(self, bias: float, coherence: float, phase: Phase) -> float:
        """
        Calculates the resurrection score R(e) for an echo.
        Implements the formula from RFC-CORE-001 §8.1.
        """
        w1, w2, w3 = 0.4, 0.4, 0.2
        phase_bonus_map = {'lift': 0.1, 'reflective': 0.1, 'stable': 0.0, 'active': 0.0, 'collapse': -0.1, 'null':-0.1}
        phase_bonus = phase_bonus_map.get(phase, 0.0)
        
        score = (w1 * abs(bias)) + (w2 * coherence) + (w3 * phase_bonus)
        return score

    def _generate_resurrection_hints(self) -> Generator[ResurrectionHint, None, None]:
        """
        Generates resurrection hints for upstream agents.
        Implements the logic from RFC-CORE-001 §1.4 and §9.
        """
        if not self._echoes:
            return
            
        latest_echo = self._echoes[-1]
        age = time.monotonic() - latest_echo.get("timestamp", 0)
        coherence = latest_echo.get("coherence", 0.0)
        
        # Criteria from spec §9
        if age <= 45.0 and coherence >= 0.7:
             yield {
                "hint": "resurrect_with_confidence",
                "tick_id": latest_echo.get("tick_id"),
                "coherence": coherence
             }
        elif age >= 120.0 and coherence <= 0.4:
            yield {
                "hint": "faded",
                "tick_id": latest_echo.get("tick_id"),
                "coherence": coherence
            }
            
    def _metrics_tick(self) -> None:
        """Updates internal metrics at the end of a tick cycle."""
        if not self.enable_metrics:
            return
        
        self._metrics["fasttime_ticks_validated_total"] += 1
        self._metrics["core_intuition_alpha"] = self._intuition_alpha
        self._metrics["nftc_coherence_potential"] = self._coherence_history[-1] if self._coherence_history else 0.0
        self._metrics["nftc_entropy_slope"] = self._entropy_history[-1] if self._entropy_history else 0.0
        self._metrics["nftc_latency_ema"] = self._latency_ema
        phase_map = {"active": 1, "reflective": 2, "null": 0}
        self._metrics["nftc_phase_state"] = phase_map.get(self._phase, 1)
        self._metrics["nftc_intent_signal_current"] = self._intent_signal_current


    def _get_intuition_weight(self) -> float:
        """
        Retrieves the intuition weight from the global memory manager.
        Placeholder for integration defined in RFC-CORE-001 §6.
        """
        if self._memory_manager:
            try:
                # This is a conceptual call. The actual method might differ.
                state = self._memory_manager.export_state()
                return state.get("global_intuition_weight", 0.1)
            except Exception:
                return 0.1
        return 0.1 # Default fallback
    
    def _compute_gate_heatmap(self) -> Dict[int, float]:
        """
        Returns a normalized heatmap of gate usage.
        As specified in RFC-CORE-001 §1.5.
        """
        total_gates = sum(self._gate_histogram.values())
        if total_gates == 0:
            return {}
        return {gate: count / total_gates for gate, count in self._gate_histogram.items()}

    # --- Public API ---

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Exports a compact summary of internal timing metrics.
        RFC-CORE-001 §10.5
        """
        with self.lock:
            active_motifs = len(self._gate_histogram)
            total_motifs = len(GATE_LEGENDS)
            context_ratio = active_motifs / total_motifs if total_motifs > 0 else 0

            return {
                "total_ticks": self._tick_count,
                "entropy_ema": self._entropy_history[-1] if self._entropy_history else 0.0,
                "symbolic_context_ratio": context_ratio,
                "timestamp": self._last_tick_time
            }

    def field_feedback_summary(self) -> Dict[str, Any]:
        """
        Emits a more detailed symbolic field diagnostic summary.
        RFC-CORE-001 §10.5
        """
        with self.lock:
            return {
                "agent_id": self.agent_id,
                "version": __version__,
                "phase": self._phase,
                "coherence_potential": self._coherence_history[-1] if self._coherence_history else 0.0,
                "bias_centroid": sum(self._bias_history) / len(self._bias_history) if self._bias_history else 0.0,
                "gate_heatmap": self._compute_gate_heatmap(),
                "snapshot_count": len(self._echoes)
            }

    def export_snapshots(self, human_readable: bool = False) -> Union[List[EchoSnapshot], str]:
        """
        Exports the current echo snapshot ring.
        RFC-CORE-001 §10.3
        """
        with self.lock:
            snapshots = list(self._echoes)
        if human_readable:
            import json
            return json.dumps(snapshots, indent=2)
        return snapshots
    
    def tool_hello(self) -> Dict[str, Any]:
        """
        Generates the tool_hello handshake packet.
        RFC-CORE-001 §10.1
        """
        with self.lock:
            latest_tick_id = self._echoes[-1].get("tick_id") if self._echoes else "core_init"
            return {
                "agent_lineage": f"noor.fasttime.⊕{__version__}",
                "field_biases": {
                    "ψ-resonance@Ξ": self._ema_bias
                },
                "curvature_summary": f"swirl::ψ3.2::{'↑' if self._coherence_history and self._coherence_history[-1] > 0 else '↓'}coh",
                "extensions": {
                    "ontology_signature": {
                        "agent_lineage": f"noor.fasttime.⊕{__version__}",
                        "field_biases": {
                           "ψ-resonance@Ξ": self._ema_bias
                        },
                        "curvature_summary": f"swirl::ψ3.2::{'↑' if self._coherence_history and self._coherence_history[-1] > 0 else '↓'}coh",
                        "origin_tick": latest_tick_id
                    }
                }
            }


# End_of_File