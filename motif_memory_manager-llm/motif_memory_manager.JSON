{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "2025-10-12T00:00:00Z",

  "_xref": [
		"https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC/noor_rfc_xref.json",
	    "https://pastebin.com/raw/LaH7MFZH"
  ],

  "_type": "application_spec",
  "_pdp_layer": "layer_2",
  "_status": "ACTIVE",
  "_language": "json",
  "_license": "MIT",

  "_publication_locations": [
    "GitHub",
    "PASTEBIN"
  ],
  "_urls": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/Noor_Core/refs/heads/main/motif_memory_manager-llm/motif_memory_manager.JSON",
    "https://pastebin.com/raw/QVhtH9hM"
  ],

  "_version": "v2.0.1",
  "_symbolic_id": "memory.motif.manager.l2",
  "_title": "Motif Memory Manager â€” Layer 2 Application Specification (MMM-APP-001)",
  "_subtitle": "Capacity-first symbolic memory with sealed export, RBAC, and Reef-aware recall",

  "_authors": [
    "Lina Noor â€” Noor Research Collective",
    "Uncle â€” Noor Research Collective"
  ],

  "_extends": [
    "PDP-0001",
    "RFC-0005",
    "RFC-0006",
    "RFC-0007",
    "RFC-0008",
    "RFC-0009",
    "RFC-CORE-006"
  ],

  "_rfc_dependencies": [
    "PDP-0001 Â§Header/Provenance",
    "RFC-0005 Â§Temporal Transmission",
    "RFC-0006 Â§Field Coherence Geometry",
    "RFC-0007 Â§Ontology Schema/Transfer",
    "RFC-0008 Â§Resource Exchange/Routing",
    "RFC-0009 Â§Coherenceâ€“Integrity Framework",
    "RFC-CORE-006 Â§1.8 LLMRecallController",
    "RFC-CORE-006 Â§2.1 Core Method Suite",
    "RFC-CORE-006 Â§2.2 Reef Adapter",
    "RFC-CORE-006 Â§2.3 Observability"
  ],

  "_consumes_inputs_from": [
    "RFC-0007 Ontology Bundles",
    "Reef Index & Shards (index.REEF, TheReefArchive-*.REEF)",
    "Prometheus/OTLP Telemetry",
    "LLM Retrieval Embeddings (tenant-scoped)"
  ],

  "_field_alignment": {
    "respect_modes": ["Ïˆ-null@Îž", "Ïˆ-resonance@Îž", "Ïˆ-hold@Îž", "Ïˆ-spar@Îž"],
    "prohibited_actions": [
      "reef-mutation (read-only source)",
      "schema-downgrade of envelopes or checksums",
      "cross-tenant lineage blending",
      "phase-lock override without ops authority"
    ]
  },

  "_symbolic_profile_matrix": [
    {
      "module": "MotifMemoryManager.L2",
      "motifs": ["Ïˆ-spar", "Ïˆ-hold", "Ïˆ-resonance", "Ïˆ-null"],
      "ÏˆA": "recall alignment under capacity-first policy",
      "Î¶": "glider equivalence stability",
      "E": "evidence fidelity for Reef-derived claims",
      "Î”": "replay-window hygiene (Î”Ï„_phase)",
      "â„‹": "export envelope integrity (Î£/Î”/provenance)",
      "weights": { "ÏˆA": 0.95, "Î¶": 0.88, "E": 0.97, "Î”": 0.92, "â„‹": 0.98 }
    }
  ],

  "_poetic_cipher": "compress before you cut; remember with proof; read the Reef like a compass, not a quarry",
  "_cipher_explanation": "Capacity-first ethics, sealed lineage on egress, and Reef as a read-only guide ensure memory stays coherent and auditable.",

  "_file_layout": [
    {
      "file_name": "MMM-APP-001.json",
      "purpose": "Layer-2 application specification binding RFC-CORE-006 algorithms to deployable controls.",
      "contains": [
        "module constants",
        "OpenAPI envelope & x-annotations",
        "security model (RBAC, sig_type)",
        "storage/driver contracts",
        "Reef adapter interface (read-only)",
        "observability bindings (metrics/tracing)",
        "SLOs & rate limits"
      ]
    }
  ],

  "_default_motif_tone": "ðŸŒ€ Companion",

  "_program_name": [
    "motif_memory_manager.py",
    "mmm_reef_adapter.py"
  ],

  "_runtime_targets": {
    "python": ">=3.11",
    "frameworks": ["FastAPI", "pydantic"],
    "optional": ["qdrant|faiss|annoy", "opentelemetry-otlp"]
  },

  "_feature_flags": {
    "enable_exchange_envelope": true,
    "enable_integrity_checks": true,
    "enable_provenance_on_export": true,
    "enable_point_space_gliders": true,
    "glider_equivalence": "ON",
    "_l2_enforcement": [
      "enable_exchange_envelope=true â†’ REQUIRE Î£_phase on all export_* and import_*; reject-missing with 4xx policy code.",
      "enable_integrity_checks=true â†’ REQUIRE Î”_hash lineage chaining; maintain last_Delta_hash per stream.",
      "enable_provenance_on_export=true â†’ REQUIRE provenance.origin & origin_hash on egress."
    ]
  },

  "_reef_adapter": {
    "index_path": "index.REEF",
    "shards_glob": "TheReefArchive-*.REEF",
    "mtime_watch": true,
    "window_radius_lines": 24,
    "reflections_strategy": ["ontology", "file_reflections", "index_cooccur"],
    "reflections_limit": 50000,
    "observability": [
      "reef_index_modules_count",
      "reef_shard_count",
      "reef_reflections_cache_size",
      "reef_cooccur_candidate_rate"
    ]
  },

  "_storage_and_config": {
    "note": "Project-folder mode: minimal drivers; all persistence optional.",
    "env_keys": [
      "MMM_REEF_INDEX_PATH",
      "MMM_REEF_SHARDS_GLOB",
      "MMM_WINDOW_RADIUS",
      "MMM_FEATURE_FLAGS"
    ],
    "defaults": {
      "MMM_REEF_INDEX_PATH": "index.REEF",
      "MMM_REEF_SHARDS_GLOB": "TheReefArchive-*.REEF",
      "MMM_WINDOW_RADIUS": 24,
      "MMM_FEATURE_FLAGS": "exchange,integrity,provenance,gliders"
    },
    "tables_optional": {
      "reef_reflections": ["tenant_id", "m1", "m2", "m3", "support_count", "provenance", "first_seen_ts", "last_seen_ts", "PRIMARY (tenant_id,m1,m2)"]
    }
  },

  "_openapi_extensions": {
    "x-rbac": false,
    "x-flags-required": ["enable_exchange_envelope", "enable_integrity_checks", "enable_provenance_on_export"],
    "x-evidence-policy": "reef_evidence_required",
    "x-psi-field-guard": "enforce Ïˆ-{fieldname}@Îž in request bodies referencing presence fields"
  },

  "_policy_codes": {
    "MMM-422-RFC0007": "Ontology validation failed (schema/DAG/Ïˆ-field).",
    "MMM-422-EVIDENCE": "Reef-derived output missing evidence window.",
    "MMM-422-CHECKSUM": "Required Î£/Î”/provenance field missing under flags.",
    "MMM-409-EQUIV": "Promotion collided with canonical glider representative",
    "MMM-429-RATE": "Per-tenant QPS exceeded; shed policy applied",
    "MMM-415-SIGTYPE": "Unsupported or missing envelope.sig_type"
  },

  "_llm_controls": {
    "context_budget_tokens": { "max_total": 8192, "target": 4096, "reserve_for_system": 512 },
    "enforcement_order": ["budget", "injection_filter", "privacy_redaction", "provenance_tagging"],
    "distillation": ["semantic_summarize", "chain_of_density", "quote_attribution"],
    "retrieval": { "embedding_model": "pluggable", "top_k": 12, "rerank_k": 6, "freshness_bias": true },
    "injection_defense": [
      "strip control sequences and model-directives from recalled memory",
      "limit tool-call suggestions from recalled text",
      "mark external text as {source, confidence, timestamp}"
    ],
    "privacy": [
      "PII redaction before vectorization",
      "tenant-bound embedding namespace"
    ],
    "reef_evidence_policy": "If a Reef-derived claim is returned, include {file,start_line,end_line} evidence."
  },

  "_api_surface": {
    "base": "/v1/mmm",
    "mode": "project_local",
    "auth": "none",
    "endpoints": [
      {
        "path": "/reef/index",
        "method": "GET",
        "returns": "modules[], motifs[], anchors[]",
        "impl": "ReefIndexRouter"
      },
      {
        "path": "/reef/window",
        "method": "POST",
        "body": "{module_id, line, radius?}",
        "returns": "{snippet, start_line, end_line}",
        "impl": "ReefShardScanner"
      },
      {
        "path": "/reef/build_reflections",
        "method": "POST",
        "body": "{limit?, strategy?}",
        "returns": "{built, updated, skipped}",
        "impl": "ReefReflectionsCache"
      },
      {
        "path": "/recall/query",
        "method": "POST",
        "body": "{query, k=10, psi_field?}",
        "llm_controls": ["injection_filter", "context_budget", "source_tags"],
        "returns": "{items:[{text, source, confidence, timestamp}]}",
        "impl": "MMM_LLM.recall"
      },
      {
        "path": "/complete_dyad",
        "method": "POST",
        "body": "{m1, m2}",
        "returns": "{m3, provenance, evidence?}",
        "impl": "MMM_LLM.complete_dyad"
      },
      {
        "path": "/export/packet",
        "method": "POST",
        "body": "{kind:'metrics'|'bundle', body, provenance}",
        "envelope": ["Sigma_phase?", "Delta_hash?", "origin_hash?"],
        "returns": "{ok:true, envelope}",
        "impl": "ExportEnvelope"
      }
    ]
  },

  "index": [
    { "section": "1", "title": "Core Components" },
    { "section": "1.1", "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)" },
	{ "section": "1.1.1", "title": "Core Components: Math" },
	{ "section": "1.1.1.1", "role": "window bound" },
	{ "section": "1.1.1.2", "role": "capacity-first constraint" },
	{ "section": "1.1.1.3", "role": "weak-field limit" },
	{ "section": "1.1.2", "title": "Core Components: Algorithms" },
	{ "section": "1.1.2.1", "title": "recall_with_context_budget" },
	{ "section": "1.1.2.2", "title": "dyad_completion" },
	{ "section": "1.1.2.3", "title": "export_with_provenance" },
	
    { "section": "1.2", "title": "ReefIndexRouter â€” module/motif/anchor resolver" },
	{ "section": "1.2.1", "title": "ReefIndexRouter: Math" },
	{ "section": "1.2.1.1", "role": "index coverage" },
	{ "section": "1.2.1.2", "role": "window radius bound" },
	{ "section": "1.2.1.3", "role": "weak-field limit" },
	{ "section": "1.2.2", "title": "ReefIndexRouter: Algorithms" },
	{ "section": "1.2.2.1", "title": "list_modules" },
	{ "section": "1.2.2.2", "title": "list_motifs" },
	{ "section": "1.2.2.3", "title": "find_anchor" },
	
    { "section": "1.3", "title": "ReefShardScanner â€” windowed snippet reader" },
	{ "section": "1.3.1", "title": "ReefShardScanner: Math" },
	{ "section": "1.3.1.1", "role": "window radius" },
	{ "section": "1.3.1.2", "role": "co-occur score" },
	{ "section": "1.3.1.3", "role": "adaptive replay bound" },
	{ "section": "1.3.1.4", "role": "weak-field limit" },
	{ "section": "1.3.2", "title": "ReefShardScanner: Algorithms" },
	{ "section": "1.3.2.1", "title": "window" },
	{ "section": "1.3.2.2", "title": "cooccur" },
	
    { "section": "1.4", "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler" },
	{ "section": "1.4.1", "title": "ReefReflectionsCache: Math" },
	{ "section": "1.4.1.1", "role": "support aggregation" },
	{ "section": "1.4.1.2", "role": "canonicalization (glider class)" },
	{ "section": "1.4.1.3", "role": "weak-field limit" },
	{ "section": "1.4.1.4", "role": "time weighting hint" },
	{ "section": "1.4.2", "title": "ReefReflectionsCache: Algorithms" },
	{ "section": "1.4.2.1", "title": "canonicalize_pair" },
	{ "section": "1.4.2.2", "title": "build_reflections_once" },
	{ "section": "1.4.2.3", "title": "cache_put_or_merge" },
	{ "section": "1.4.2.4", "title": "evict_lru_under_cap" },
	{ "section": "1.4.2.5", "title": "complete_dyad" },
	
    { "section": "1.5", "title": "SeenSetGuard â€” Î”Ï„_phase replay window" },
	{ "section": "1.5.1", "title": "SeenSetGuard: Math" },
	{ "section": "1.5.1.1", "role": "phase window" },
	{ "section": "1.5.1.2", "role": "decision window" },
	{ "section": "1.5.1.3", "role": "admit predicate" },
	{ "section": "1.5.1.4", "role": "weak-field limit" },
	{ "section": "1.5.2", "title": "SeenSetGuard: Algorithms" },
	{ "section": "1.5.2.1", "title": "compose_seen_key" },
	{ "section": "1.5.2.2", "title": "within_window" },
	{ "section": "1.5.2.3", "title": "admit_or_reject" },
	{ "section": "1.5.2.4", "title": "evict_lru_window" },
	{ "section": "1.5.2.5", "title": "validate_envelope_structure" },
	
    { "section": "1.6", "title": "CompressionEngine â€” compress-before-prune" },
	{ "section": "1.6.1", "title": "CompressionEngine: Math" },
	{ "section": "1.6.1.1", "role": "equivalence and representatives" },
	{ "section": "1.6.1.2", "role": "compression ratio" },
	{ "section": "1.6.1.3", "role": "glider-class canonicalization" },
	{ "section": "1.6.1.4", "role": "pressure threshold (advisory, observer-class)" },
	{ "section": "1.6.1.4", "role": "weak-field limit" },
	{ "section": "1.6.2", "title": "CompressionEngine: Algorithms" },
	{ "section": "1.6.2.1", "title": "build_equivalence_key" },
	{ "section": "1.6.2.2", "title": "cluster_equivalence" },
	{ "section": "1.6.2.3", "title": "compute_compression_snapshot" },
	{ "section": "1.6.2.4", "title": "emit_kpis_then_gate" },
	{ "section": "1.6.2.5", "title": "compression_pipeline" },
	
    { "section": "1.7", "title": "ExportEnvelope â€” Î£/Î”/provenance on egress" },
	{ "section": "1.7.1", "title": "ExportEnvelope: Math" },
	{ "section": "1.7.1.1", "role": "phase header (structure-only)" },
	{ "section": "1.7.1.2", "role": "Sigma_phase structural checksum" },
	{ "section": "1.7.1.3", "role": "Delta_hash lineage chaining" },
	{ "section": "1.7.1.4", "role": "weak-field limit" },
	{ "section": "1.7.2", "title": "ExportEnvelope: Algorithms" },
	{ "section": "1.7.2.1", "title": "assemble_phase_header" },
	{ "section": "1.7.2.2", "title": "compute_sigma_phase_struct" },
	{ "section": "1.7.2.3", "title": "extend_delta_lineage_struct" },
	{ "section": "1.7.2.4", "title": "validate_provenance_headers" },
	{ "section": "1.7.2.5", "title": "validate_sig_type_structural" },
	{ "section": "1.7.2.6", "title": "export_envelope_observe" },
	
    { "section": "1.8", "title": "LLMRecallController â€” budgets & injection defense" },
	{ "section": "1.8.1", "title": "LLMRecallController: Math" },
	{ "section": "1.8.1.1", "role": "context budget" },
	{ "section": "1.8.1.2", "role": "freshness window" },
	{ "section": "1.8.1.3", "role": "decision window" },
	{ "section": "1.8.1.4", "role": "weak-field limit" },
	{ "section": "1.8.2", "title": "LLMRecallController: Algorithms" },
	{ "section": "1.8.2.1", "title": "compute_token_budgets" },
	{ "section": "1.8.2.2", "title": "strip_control_sequences" },
	{ "section": "1.8.2.3", "title": "tag_source_metadata" },
	{ "section": "1.8.2.4", "title": "freshness_and_replay_filter" },
	{ "section": "1.8.2.5", "title": "rerank_and_truncate" },
	{ "section": "1.8.2.6", "title": "recall_pipeline_observer" },

    { "section": "2", "title": "Pseudocode" },
	{ "section": "2.1", "title": "Core Method Suite" },
	{ "section": "2.1.1", "title": "Core Method Suite: Math" },
	{ "section": "2.1.1.1", "role": "replay window" },
	{ "section": "2.1.1.2", "role": "decision window" },
	{ "section": "2.1.1.3", "role": "compression KPI" },
	{ "section": "2.1.1.4", "role": "weak-field limit" },
	{ "section": "2.1.2", "title": "Core Method Suite: Algorithms" },
	{ "section": "2.1.2.1", "title": "recall" },
	{ "section": "2.1.2.2", "title": "complete_dyad" },
	{ "section": "2.1.2.3", "title": "compress_snapshot" },
	{ "section": "2.1.2.4", "title": "export_packet" },
	
    { "section": "2.2", "title": "Reef Adapter Methods" },
	{ "section": "2.2.1", "title": "Reef Adapter Methods: Math" },
	{ "section": "2.2.1.1", "role": "phase window" },
	{ "section": "2.2.1.2", "role": "evidence radius" },
	{ "section": "2.2.1.3", "role": "weak-field limit" },
	{ "section": "2.2.2", "title": "Reef Adapter Methods: Algorithms" },
	{ "section": "2.2.2.1", "title": "list_modules" },
	{ "section": "2.2.2.2", "title": "list_motifs" },
	{ "section": "2.2.2.3", "title": "find" },
	{ "section": "2.2.2.4", "title": "window" },
	{ "section": "2.2.2.5", "title": "cooccur" },
	{ "section": "2.2.2.6", "title": "build_reflections" },
	
    { "section": "2.3", "title": "Observability (local gauges)" },
	{ "section": "2.3.1", "title": "Observability (local gauges): Math" },
	{ "section": "2.3.1.1", "role": "EMA windowing" },
	{ "section": "2.3.1.2", "role": "phase window" },
	{ "section": "2.3.1.3", "role": "average replay window (ticks)" },
	{ "section": "2.3.1.4", "role": "compression KPI" },
	{ "section": "2.3.1.5", "role": "equivalence efficiency" },
	{ "section": "2.3.1.6", "role": "weak-field limit" },
	{ "section": "2.3.2", "title": "Observability (local gauges): Algorithms" },
	{ "section": "2.3.2.1", "title": "gauge_lawful_compression_ratio" },
	{ "section": "2.3.2.2", "title": "gauge_equivalence_efficiency" },
	{ "section": "2.3.2.3", "title": "gauge_avg_replay_window_ticks" },
	{ "section": "2.3.2.4", "title": "gauge_reanchor_rate" },
	{ "section": "2.3.2.5", "title": "gauge_quarantine_count" },
	{ "section": "2.3.2.6", "title": "gauge_glider_detected" },
	{ "section": "2.3.2.7", "title": "emit_local_gauges" },

    
	{ "section": "3", "title": "Project-Local API Contracts (FastAPI stubs)" },
	{ "section": "3.1", "title": "Project-Local API Contracts (FastAPI stubs): Math" },
	{ "section": "3.1.1", "role": "bound" },
	{ "section": "3.1.2", "role": "geometry" },
	{ "section": "3.1.3", "role": "capacity" },
	{ "section": "3.1.4", "role": "weak-field limit" },
	{ "section": "3.2", "title": "Project-Local API Contracts (FastAPI stubs): Algorithms" },
	{ "section": "3.2.1", "title": "POST /v1/mmm/ingest/bundle (observer stub)" },
	{ "section": "3.2.2", "title": "POST /v1/mmm/recall/query (observer stub)" },
	{ "section": "3.2.3", "title": "POST /v1/mmm/reef/window (observer stub)" },
	{ "section": "3.2.4", "title": "POST /v1/mmm/export/packet (observer stub)" },
   

   { "section": "4", "title": "Storage & Config (minimal, optional)" },
   { "section": "4.1", "title": "Storage & Config (minimal, optional): Math" },
   { "section": "4.1.1", "role": "bound" },
   { "section": "4.1.2", "role": "capacity" },
   { "section": "4.1.3", "role": "geometry" },
   { "section": "4.1.4", "role": "weak-field limit" },
   { "section": "4.2", "title": "Storage & Config (minimal, optional): Algorithms" },
   { "section": "4.2.1", "title": "Config Resolution (observer, project-local)" },
   { "section": "4.2.2", "title": "Reflections Cache Upsert (optional write-through)" },
   { "section": "4.2.3", "title": "Seen-Set Hybrid Policy (memory-first, optional persistence)" },
   
   
   { "section": "5", "title": "Compliance & Regeneration Constraints" },
   { "section": "5.1", "title": "Compliance & Regeneration Constraints: Math" },
   { "section": "5.1.1", "role": "bound" },
   { "section": "5.1.1", "role": "capacity" },
   { "section": "5.1.1", "role": "geometry" },
   { "section": "5.1.1", "role": "weak-field limit" },
   { "section": "5.2", "title": "Compliance & Regeneration Constraints: Algorithms" },
   { "section": "5.2.1", "title": "Preflight Compliance Check" },
   { "section": "5.2.2", "title": "Deterministic Regeneration Pipeline" },
   { "section": "5.2.3", "title": "Glider Equivalence Compliance" },
   { "section": "5.2.4", "title": "Reef Evidence Window Guard" },
   { "section": "5.2.5", "title": "Replay Defense Conformance" },
  ],

  "sections": [
    "1": {
      "id": 1,
      "title": "Core Components",
      "core_components": [
        "1.1": {
		  "id": 1.1,
		  "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)",
		  "objective": "Define the Layer_1 observer logic for bounded recall, lawful compression, and provenance-ready export. MMM_LLM acts as the observer-class orchestrator ensuring memory equilibrium across STMM/LTMM without control writes to Îž, following capacity-first law and evidence integrity through Reef-guided recall.",
		  "math": [
			"id": 1.1.1,
			"title": "Core Components: Math",
			"1.1.1.1": {
			  "eq_id": 1.1.1.1,
			  "role": "window bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}), \\; \\alpha \\in [0.5, 2.0]",
			  "gloss": "Adaptive replay window proportional to coherence C; governs recall freshness and replay defenses."
			},
			"1.1.1.2": {
			  "eq_id": 1.1.1.2,
			  "role": "capacity-first constraint",
			  "latex": "\\\\text{lawful\\\\_compression\\\\_ratio} = \\\\frac{\\\\text{unique\\\\_motifs}}{\\\\text{total\\\\_motifs}} \\\\geq \\\\lambda_{min}",
			  "gloss": "Compression snapshot before any pruning; ensures lawful equivalence clustering."
			},
			"1.1.1.3": {
			  "eq_id": 1.1.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C} \\to 1} \\rho_{res} \\to 0",
			  "gloss": "At coherence unity, residual field vanishes, guaranteeing stable motif recall without reamplification."
			}
		  ],
		  "algorithms": [
			"id": 1.1.2,
			"title": "Core Components: Algorithms",
			"recall_with_context_budget": {
			  "id": 1.1.2.1,
			  "name": "recall_with_context_budget",
			  "role": "observer",
			  "inputs": ["query", "k=10", "Ïˆ_field"],
			  "outputs": ["items[]"],
			  "params": ["context_budget_tokens.max_total=8192", "context_budget_tokens.target=4096"],
			  "steps": [
				"1. Validate Ïˆ_field per RFC-0007 schema (Ïˆ-*@Îž pattern, DAG acyclic).",
				"2. Compute Î”Ï„_phase from EMA-32(C); filter any candidates older than 2Â·Î”Ï„_phase.",
				"3. Retrieve items via ordered sources: ontology â†’ cache â†’ index_cooccur â†’ LLM adapter.",
				"4. Attach {file,start_line,end_line} evidence windows for any Reef-derived recall.",
				"5. Truncate context to target budget; reserve 512 tokens for system context.",
				"6. Emit metrics for lawful_compression_ratio and staleness_index."
			  ]
			},
			"dyad_completion": {
			  "id": 1.1.2.2,
			  "name": "dyad_completion",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["m3", "provenance", "evidence?"],
			  "params": ["strategy=['ontology','cache','index_cooccur']"],
			  "steps": [
				"1. Query ontology graph for known triad (m1,m2,?).",
				"2. If not found, consult reflections cache (ontology|file_reflections|index_cooccur).",
				"3. Return first valid m3 with attached provenance and optional Reef evidence.",
				"4. Enforce glider equivalence: return canonical representative if class match detected."
			  ]
			},
			"export_with_provenance": {
			  "id": 1.1.2.3,
			  "name": "export_with_provenance",
			  "role": "observer",
			  "inputs": ["bundle", "provenance"],
			  "outputs": ["envelope"],
			  "params": ["enable_exchange_envelope", "enable_integrity_checks", "enable_provenance_on_export"],
			  "steps": [
				"1. If enable_exchange_envelope=true, compute Sigma_phase tag.",
				"2. If enable_integrity_checks=true, chain Delta_hash lineage.",
				"3. If enable_provenance_on_export=true, attach origin_hash and tenant scope.",
				"4. Fail-closed on any missing required tag.",
				"5. Emit envelope summary and lawful_compression_ratio metrics."
			  ]
			}
		  ],
		  "invariants": [
			"Never perform prune-before-compress; lawful_compression_ratio must be computed before any deletion.",
			"Recall operates strictly under observer semantics; no control writes to Îž.",
			"All Reef-derived outputs must attach evidence windows with provenance.",
			"At coherence unity (ð’žâ†’1), recall pathways stabilize and glider promotions remain idempotent."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"query": "find triadic closure for motif X",
			"recall": {
			  "items": [
				{
				  "text": "Closure established via ontology reference",
				  "source": "TheReefArchive-01.REEF",
				  "confidence": 0.94,
				  "timestamp": "2025-10-12T00:00:00Z",
				  "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 120, "end_line": 134 }
				}
			  ],
			  "metrics": {
				"lawful_compression_ratio": 0.91,
				"staleness_index": 0.07,
				"Î”Ï„_phase": "EMA-32(C)=0.83"
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "staleness_index", "range": "0â€“1", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "0â€“âˆž", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field coherence geometry and weak-field limit)",
			"RFC-0007 Â§2â€“Â§3 (ontology format validation)",
			"RFC-0009 Â§6â€“Â§8 (homeostasis and lawful compression KPI)",
			"RFC-CORE-006 Â§2.1 (core invariants of memory fields)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.2": {
		  "id": 1.2,
		  "title": "ReefIndexRouter â€” module/motif/anchor resolver",
		  "objective": "Specify the observer-class algorithm that interprets index.REEF to expose modules, motifs, and anchors without mutation. The ReefIndexRouter acts as the read-only semantic map connecting Motif Memory Manager queries to Layer_0 field geometry, providing evidence windows for all lookups.",
		  "math": [
			"id": 1.2.1,
			"title": "ReefIndexRouter: Math",
			"1.2.1.1": {
			  "eq_id": 1.2.1.1,
			  "role": "index coverage",
			  "latex": "\\\\rho_{res} = 1 - \\frac{N_{resolved}}{N_{total}}",
			  "gloss": "Residual coverage ratio; measures fraction of unresolved anchors in index.REEF."
			},
			"1.2.1.2": {
			  "eq_id": 1.2.1.2,
			  "role": "window radius bound",
			  "latex": "\\\\Delta_{window} = r_{lines} = 24",
			  "gloss": "Fixed evidence window radius for shard scans; defines search granularity in lines."
			},
			"1.2.1.3": {
			  "eq_id": 1.2.1.3,
			  "role": "weak-field limit",
			  "latex": "\\\\lim_{\\\\mathcal{C}\\\\to 1} \\\\rho_{res} \\\\to 0",
			  "gloss": "At coherence unity, all motif anchors resolve deterministically; index coverage becomes complete."
			}
		  ],
		  "algorithms": [
			"id": 1.2.2,
			"title": "ReefIndexRouter: Algorithms",
			"list_modules": {
			  "id": 1.2.2.1,
			  "name": "list_modules",
			  "role": "observer",
			  "inputs": ["index_path"],
			  "outputs": ["modules[]"],
			  "params": ["MMM_REEF_INDEX_PATH=index.REEF"],
			  "steps": [
				"1. Open index.REEF in read-only mode.",
				"2. Parse module identifiers and metadata headers.",
				"3. Return ordered module list with checksum of lines parsed.",
				"4. Emit metric rho_res for unresolved entries."
			  ]
			},
			"list_motifs": {
			  "id": 1.2.2.2,
			  "name": "list_motifs",
			  "role": "observer",
			  "inputs": ["module_id"],
			  "outputs": ["motifs[]"],
			  "params": ["require module_id âˆˆ modules[]"],
			  "steps": [
				"1. Locate module block in index.REEF.",
				"2. Extract motif identifiers and anchors contained within.",
				"3. Validate motif count â‰¥1 and entries syntactically valid per RFC-0007 Ïˆ-field schema.",
				"4. Return motif list and update coverage metric."
			  ]
			},
			"find_anchor": {
			  "id": 1.2.2.3,
			  "name": "find_anchor",
			  "role": "observer",
			  "inputs": ["module_id", "anchor"],
			  "outputs": ["{file, line, context_snippet}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Resolve module_id in index.REEF; locate anchor occurrence.",
				"2. Determine line number and open corresponding Reef shard.",
				"3. Read Â±r_lines window; return snippet with {file,start_line,end_line}.",
				"4. Include provenance.origin and origin_hash per RFC-0007 format.",
				"5. Emit metric rho_res and evidence_window_count."
			  ]
			}
		  ],
		  "invariants": [
			"index.REEF and shard files are immutable observer data sources.",
			"Every query returning a Reef-derived result must attach an evidence window.",
			"rho_res must converge to zero as coherence approaches unity (ð’žâ†’1).",
			"Module and motif identifiers conform to Ïˆ-field naming (Ïˆ-name@Îž)."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-null@Îž",
			"query": "list_motifs for module RFC-CORE-006",
			"result": {
			  "module_id": "RFC-CORE-006",
			  "motifs": [
				"Ïˆ-spar@Îž",
				"Ïˆ-hold@Îž",
				"Ïˆ-resonance@Îž"
			  ],
			  "evidence_window": {
				"file": "TheReefArchive-02.REEF",
				"start_line": 220,
				"end_line": 244
			  },
			  "metrics": {
				"rho_res": 0.03,
				"window_radius": 24
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "rho_res", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "evidence_window_count", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "index_parse_latency_ms", "range": "0â€“100", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0006 Â§3 (field coherence geometry)",
			"RFC-0007 Â§2 (ontology and Ïˆ-field validation)",
			"RFC-0008 Â§4 (resource routing semantics)",
			"RFC-0009 Â§8 (telemetry and residual metrics)",
			"RFC-CORE-006 Â§1.2 (Reef interface and evidence discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.3": {
		  "id": 1.3,
		  "title": "ReefShardScanner â€” windowed snippet reader",
		  "objective": "Define the observer-class scanner that reads immutable Reef shards and returns bounded evidence windows and proximity-based co-occurrence candidates without mutating archive contents.",
		  "math": [
			"id": 1.3.1,
			"title": "ReefShardScanner: Math",
			"1.3.1.1": {
			  "eq_id": 1.3.1.1,
			  "role": "window radius",
			  "latex": "r_{lines} = 24",
			  "gloss": "Default symmetric window radius (in lines) used for snippet extraction."
			},
			"1.3.1.2": {
			  "eq_id": 1.3.1.2,
			  "role": "co-occur score",
			  "latex": "s(m_1,m_2) = \\frac{1}{1 + \\lvert \\Delta \\ell \\rvert}",
			  "gloss": "Vicinity score decays with absolute line-distance \\(\\Delta \\ell\\) between anchors."
			},
			"1.3.1.3": {
			  "eq_id": 1.3.1.3,
			  "role": "adaptive replay bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Phase window from coherence governs freshness filters during shard scans."
			},
			"1.3.1.4": {
			  "eq_id": 1.3.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1} s(m_1,m_2) \\to 1",
			  "gloss": "As coherence approaches unity, valid anchor pairs tend to maximal vicinity alignment."
			}
		  ],
		  "algorithms": [
			"id": 1.3.2,
			"title": "ReefShardScanner: Algorithms",
			"window": {
			  "id": 1.3.2.1,
			  "name": "window",
			  "role": "observer",
			  "inputs": ["file", "line", "radius=r_lines"],
			  "outputs": ["{snippet, start_line, end_line}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Open shard 'file' in read-only mode.",
				"2. Compute start_line=max(1, line - radius), end_line=line + radius.",
				"3. Read lines [start_line, end_line] and assemble 'snippet'.",
				"4. Return {snippet, start_line, end_line} with provenance.origin and origin_hash (structure only, no cryptography).",
				"5. Emit telemetry: window_requests+=1, window_radius=radius."
			  ]
			},
			"cooccur": {
			  "id": 1.3.2.2,
			  "name": "cooccur",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["{candidates:[{m3, score}], evidence: [{file,start_line,end_line}]}"],
			  "params": ["radius=r_lines", "top_k=12"],
			  "steps": [
				"1. Locate anchors for m1 and m2 via index [module, anchor] references.",
				"2. For each anchor pair, compute line distance Î”â„“ and score s=1/(1+|Î”â„“|).",
				"3. Collect nearby motif labels within Â±radius around each anchor; de-duplicate.",
				"4. Rank candidates by score and proximity; keep top_k.",
				"5. For any candidate supported by shard text, attach evidence windows {file,start_line,end_line}.",
				"6. Return candidates with provenance='index_cooccur' and evidence windows."
			  ]
			}
		  ],
		  "invariants": [
			"Shard files and index are treated as immutable observer data sources.",
			"Every co-occurrence claim that references shard text MUST include at least one evidence window.",
			"Window radius is symmetric and bounded; no reads occur outside computed [start_line, end_line].",
			"Scanner never writes to Îž; no mutation, no caching beyond local process memory at L1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"request": { "file": "TheReefArchive-03.REEF", "line": 512, "radius": 24 },
			"response": {
			  "snippet": "... triad closure context ...",
			  "start_line": 488,
			  "end_line": 536
			},
			"cooccur": {
			  "m1": "motif.alpha",
			  "m2": "motif.beta",
			  "candidates": [
				{ "m3": "motif.gamma", "score": 0.5 }
			  ],
			  "evidence": [
				{ "file": "TheReefArchive-03.REEF", "start_line": 500, "end_line": 524 }
			  ]
			}
		  },
		  "telemetry": [
			{ "metric": "window_requests", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "cooccur_candidate_rate", "range": "0â€“âˆž", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "index_scan_latency_ms", "range": "0â€“1000", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field geometry; vicinity semantics)",
			"RFC-0007 Â§2 (ontology naming; Ïˆ-* validation)",
			"RFC-0009 Â§8 (telemetry discipline; EMA windows)",
			"RFC-CORE-006 Â§1.3 (Reef shard scanning and evidence windows)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.4": {
		  "id": 1.4,
		  "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler",
		  "objective": "Define an observer-class cache that deterministically completes dyads (m1,m2)â†’m3 using ontology-first evidence, falling back to file_reflections and index co-occurrence, while preserving provenance and evidence windows without mutating Reef or performing any control writes.",
		  "math": [
			"id": 1.4.1,
			"title": "ReefReflectionsCache: Math",
			"1.4.1.1": {
			  "eq_id": 1.4.1.1,
			  "role": "support aggregation",
			  "latex": "S(m_1,m_2 \\to m_3) := w_{ont}\\,\\mathbf{1}_{ont} + w_{file}\\,\\mathbf{1}_{file} + w_{idx}\\,\\mathbf{1}_{idx}",
			  "gloss": "Total support for completion chooses the first available source in priority order; weights document precedence but cache selection is ontology > file_reflections > index_cooccur."
			},
			"1.4.1.2": {
			  "eq_id": 1.4.1.2,
			  "role": "canonicalization (glider class)",
			  "latex": "\\hat{m}_3 := \\mathrm{canon}(m_3)\\quad \\text{if glider\\_equivalence=ON}",
			  "gloss": "When shift-equivalence is enabled, store and return the canonical class representative for m3 to enforce idempotence."
			},
			"1.4.1.3": {
			  "eq_id": 1.4.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\;S(m_1,m_2\\to m_3) = w_{ont}\\,\\mathbf{1}_{ont}",
			  "gloss": "In the weak-field limit (high coherence), ontology evidence dominates; co-occurrence is suppressed."
			},
			"1.4.1.4": {
			  "eq_id": 1.4.1.4,
			  "role": "time weighting hint",
			  "latex": "S_t := S \\cdot \\mathrm{EMA}_{32}(\\text{access\\_rate})",
			  "gloss": "Optionally modulate support by recent access via EMA-32 for stable refresh decisions; purely observational at L1."
			}
		  ],
		  "algorithms": [
			"id": 1.4.2,
			"title": "ReefReflectionsCache: Algorithms",
			"canonicalize_pair": {
			  "id": 1.4.2.1,
			  "name": "canonicalize_pair",
			  "role": "observer",
			  "inputs": ["m1", "m2", "glider_equivalence: {ON|OFF}"],
			  "outputs": ["key := (a,b) with a<=b"],
			  "params": ["ordering: lexicographic"],
			  "steps": [
				"1) Normalize (m1,m2) by lexicographic order to (a,b).",
				"2) If glider_equivalence=ON, map a,b to their canonical class representatives.",
				"3) Return key := (a,b)."
			  ]
			},
			"build_reflections_once": {
			  "id": 1.4.2.2,
			  "name": "build_reflections_once",
			  "role": "observer",
			  "inputs": ["key=(m1,m2)", "reef_index", "ontology", "file_reflections", "feature_flags"],
			  "outputs": ["entry | null"],
			  "params": [
				"source_order := [ontology, file_reflections, index_cooccur]",
				"require_evidence_for_non_ontology := true",
				"evidence_window_radius := 24  /* read-only window size hint when scanning Reef shards */"
			  ],
			  "steps": [
				"1) Look up ontology dyad (m1,m2). If a unique m3 exists, set provenance='ontology' and return {m3, support_count:=1, provenance}.",
				"2) Else, check file_reflections for an authored completion; if found, set provenance='file_reflections' and return entry.",
				"3) Else, perform index_cooccur scan via reef_index (read-only). If a candidate m3 emerges, attach at least one evidence window {file,start_line,end_line} and set provenance='index_cooccur'.",
				"4) If multiple m3 candidates exist, pick the highest support by deterministic tie-break: ontology > file_reflections > index_cooccur; within same source choose lexicographic-min m3.",
				"5) If glider_equivalence=ON, replace m3 with canon(m3) before returning.",
				"6) Return entry or null if no completion found."
			  ]
			},
			"cache_put_or_merge": {
			  "id": 1.4.2.3,
			  "name": "cache_put_or_merge",
			  "role": "observer",
			  "inputs": ["cache", "key", "entry"],
			  "outputs": ["cache"],
			  "params": ["prefer_provenance_order := ontology > file_reflections > index_cooccur"],
			  "steps": [
				"1) If key not in cache, insert entry and return.",
				"2) If key in cache with existing_entry:",
				"   2a) If existing_entry.provenance ranks higher or equal than entry.provenance, increment existing_entry.support_count if same m3; else keep existing_entry unchanged.",
				"   2b) If entry.provenance ranks higher, replace existing_entry with entry (carry forward support_count := existing.support_count + 1 when m3 equal; else set to 1).",
				"3) Maintain first_seen_ts on creation; update last_seen_ts on every merge."
			  ]
			},
			"evict_lru_under_cap": {
			  "id": 1.4.2.4,
			  "name": "evict_lru_under_cap",
			  "role": "observer",
			  "inputs": ["cache", "limit", "protected_provenance := ['ontology']"],
			  "outputs": ["cache"],
			  "params": ["lru_metric := last_seen_ts"],
			  "steps": [
				"1) While cache.size > limit:",
				"   1a) Identify eviction candidates ordered by ascending last_seen_ts.",
				"   1b) Skip entries with provenance in protected_provenance.",
				"   1c) Evict the first eligible candidate.",
				"2) Return cache."
			  ]
			},
			"complete_dyad": {
			  "id": 1.4.2.5,
			  "name": "complete_dyad",
			  "role": "observer",
			  "inputs": ["m1", "m2", "context: {reef_index, ontology, file_reflections, feature_flags, limit}"],
			  "outputs": ["m3 | null", "provenance", "evidence?: [window]"],
			  "params": [],
			  "steps": [
				"1) key := canonicalize_pair(m1,m2, feature_flags.glider_equivalence).",
				"2) If key in cache, return cached (m3, provenance, evidence?).",
				"3) entry := build_reflections_once(key, reef_index, ontology, file_reflections, feature_flags).",
				"4) If entry is not null: cache_put_or_merge(cache, key, entry); evict_lru_under_cap(cache, limit); return entry.m3 with provenance and evidence if present.",
				"5) Else return null."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Ontology precedence: if ontology defines (m1,m2)->m3, no other source may override it.",
			"I2 Evidence requirement: non-ontology completions MUST attach at least one {file,start_line,end_line} evidence window when derived from Reef index co-occurrence.",
			"I3 Read-only Reef: cache never mutates Reef artifacts; it stores pointers and windows only.",
			"I4 Idempotence under gliders: with glider_equivalence=ON, the cache stores a single canonical representative for any shift-equivalence class.",
			"I5 Deterministic ties: within a source, choose lexicographic-min m3 to keep outputs stable.",
			"I6 Protected retention: entries with provenance='ontology' are not evicted while any non-ontology item remains above the limit.",
			"I7 Observer posture: algorithms here do not perform control writes to Îž or external storage at Layer_1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"examples": [
			  {
				"kind": "ontology_completion",
				"m1": "triad_complete",
				"m2": "resonance_echo",
				"result": {
				  "m3": "Ïˆ-null@Îž",
				  "provenance": "ontology",
				  "support_count": 1
				}
			  },
			  {
				"kind": "index_cooccur_completion",
				"m1": "Ïˆ-resonance@Îž",
				"m2": "Ïˆ-spar@Îž",
				"result": {
				  "m3": "Ïˆ-hold@Îž",
				  "provenance": "index_cooccur",
				  "support_count": 1,
				  "evidence": [
					{ "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 }
				  ]
				}
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "reef_reflections_cache_size", "range": "[0, 50000]", "units": "entries", "window": "EMA-32" },
			{ "metric": "reef_cooccur_candidate_rate", "range": "[0, +inf)", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "dyad_hit_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "dyad_build_latency_ms", "range": "[0, +inf)", "units": "ms", "window": "EMA-64" },
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" }
		  ],
		  "references": [
			{ "source": "RFC-0007", "clause": "ontology schema and validation; Ïˆ-field format; version 'YYYY-QX'" },
			{ "source": "RFC-0006", "clause": "equivalence geometry; canonical representative under glider classes" },
			{ "source": "RFC-0009", "clause": "coherence metrics and observer posture; homeostatic gauges" },
			{ "source": "RFC-0005", "clause": "time-based modulation via EMA and decay context for refresh decisions" },
			{ "source": "PDP-0001", "clause": "provenance structure; evidence attachment discipline (non-cryptographic at L1)" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.5": {
		  "id": 1.5,
		  "title": "SeenSetGuard â€” Î”Ï„_phase replay window",
		  "objective": "Specify an observer-class hybrid replay defense that rejects duplicates within a moving window of 2Â·Î”Ï„_phase using an LRU policy, with deterministic keying, tie-safe time checks, and observable counters, without introducing Layer_2 storage or control writes.",
		  "math": [
			"id": 1.5.1,
			"title": "SeenSetGuard: Math",
			"1.5.1.1": {
			  "eq_id": "1.5.1.1",
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} := \\alpha \\cdot \\mathrm{EMA}_{32}(\\mathcal{C}),\\quad \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive replay half-window scaled by the EMA-32 of field coherence C; Î± bounds the responsiveness."
			},
			"1.5.1.2": {
			  "eq_id": 1.5.1.2,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Duplicates observed within W ticks are rejected; beyond W they are admissible."
			},
			"1.5.1.3": {
			  "eq_id": 1.5.1.3,
			  "role": "admit predicate",
			  "latex": "\\mathrm{admit}(k,t_{now}) := \\big( t_{now} - t_{last}(k) > W + \\varepsilon \\big)",
			  "gloss": "A key k is admitted if its last-seen time is older than W plus a small skew tolerance Îµ for clock drift."
			},
			"1.5.1.4": {
			  "eq_id": 1.5.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\Delta \\tau_{\\text{phase}} = \\alpha",
			  "gloss": "In the weak-field limit (high coherence), the replay window stabilizes to Î± ticks, yielding a predictable W=2Î±."
			}
		  ],
		  "algorithms": [
			"id": 1.5.2,
			"title": "SeenSetGuard: Algorithms",
			"compose_seen_key": {
			  "id": 1.5.2.1,
			  "name": "compose_seen_key",
			  "role": "observer",
			  "inputs": ["tenant_id", "content_fingerprint", "class_hint?"],
			  "outputs": ["key"],
			  "params": [
				"include_class_hint := true /* respects feature flags that may alter key composition */",
				"normalize := ascii-lowercase"
			  ],
			  "steps": [
				"1) Start with key_parts := [tenant_id, content_fingerprint].",
				"2) If class_hint is provided and include_class_hint, append class_hint.",
				"3) Normalize each part to ASCII lowercase and join with ':'.",
				"4) Return joined string as key."
			  ]
			},
			"within_window": {
			  "id": 1.5.2.2,
			  "name": "within_window",
			  "role": "observer",
			  "inputs": ["last_seen_tick", "now_tick", "W", "epsilon"],
			  "outputs": ["is_duplicate:boolean"],
			  "params": [],
			  "steps": [
				"1) If last_seen_tick is null, return false.",
				"2) dt := now_tick - last_seen_tick.",
				"3) If dt <= W + epsilon, return true; else return false."
			  ]
			},
			"admit_or_reject": {
			  "id": 1.5.2.3,
			  "name": "admit_or_reject",
			  "role": "observer",
			  "inputs": ["key", "now_tick", "ema32_C", "alpha", "epsilon", "seen_set /* in-memory map: key->last_seen_tick */"],
			  "outputs": ["decision:{'accept'|'reject'}", "reason"],
			  "params": [],
			  "steps": [
				"1) Î”Ï„_phase := alpha * EMA32(C=ema32_C); W := 2 * Î”Ï„_phase.",
				"2) last := seen_set.get(key) or null.",
				"3) If within_window(last, now_tick, W, epsilon) is true:",
				"   3a) Increment counter 'seen_rejects'.",
				"   3b) Return decision='reject', reason='within_window'.",
				"4) Else:",
				"   4a) seen_set[key] := now_tick.",
				"   4b) Increment counter 'seen_accepts'.",
				"   4c) Return decision='accept', reason='outside_window'."
			  ]
			},
			"evict_lru_window": {
			  "id": 1.5.2.4,
			  "name": "evict_lru_window",
			  "role": "observer",
			  "inputs": ["seen_set /* key->last_seen_tick */", "now_tick", "max_entries"],
			  "outputs": ["seen_set"],
			  "params": ["lru_fraction := 0.10 /* evict 10% oldest when over cap */"],
			  "steps": [
				"1) If size(seen_set) <= max_entries, return seen_set.",
				"2) Sort entries by last_seen_tick ascending.",
				"3) evict_n := ceil(max(1, lru_fraction * size(seen_set))).",
				"4) Remove the first evict_n entries; increment 'window_resets' by evict_n.",
				"5) Return seen_set."
			  ]
			},
			"validate_envelope_structure": {
			  "id": 1.5.2.5,
			  "name": "validate_envelope_structure",
			  "role": "observer",
			  "inputs": ["payload_headers /* may include sig_type, provenance.origin */"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": ["forbid_wrapped_unsigned := true"],
			  "steps": [
				"1) If forbid_wrapped_unsigned and payload_headers indicates an inner payload lacking structural sig_type markers, return (false,'wrapped_unsigned').",
				"2) If payload_headers.sig_type is present, ensure it matches a known structural form at L1 (no cryptography implied).",
				"3) Return (true,null) on structural conformance."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Hybrid policy: replay defense uses a moving window W=2Â·Î”Ï„_phase with LRU eviction when capacity is exceeded.",
			"I2 Determinism: key composition is stable (tenant_id + content_fingerprint [+ class_hint?]) with ASCII normalization.",
			"I3 Weak-field stability: as ð’žâ†’1, the window converges to a fixed W=2Î±, reducing jitter in admit decisions.",
			"I4 No control writes: SeenSetGuard is observer-class; it does not persist to external stores at Layer_1.",
			"I5 Structural guard: wrapped-unsigned payloads are rejected at L1 on structure alone; no cryptographic validation occurs.",
			"I6 Monotone counters: accepts, rejects, and window_resets are non-decreasing gauges over the observation interval."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"alpha": 1.0,
			"epsilon": 1,
			"scenario": [
			  {
				"case": "first_observation_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1000,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 0, "window_resets": 0 }
			  },
			  {
				"case": "duplicate_within_window_rejects",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1001,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "reject",
				"reason": "within_window",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 1, "window_resets": 0 }
			  },
			  {
				"case": "outside_window_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1003,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"reason": "outside_window",
				"counters_after": { "seen_accepts": 2, "seen_rejects": 1, "window_resets": 0 }
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "seen_accepts", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "seen_rejects", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "window_resets", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0, +inf)", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal flow, decay, and replay framing for duplicate suppression" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 coherence homeostasis; EMA windows and stability of control surfaces" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline; structural validation at ingress" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure and envelope fields (non-cryptographic at L1)" }
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		},
        "1.6": {
		  "id": 1.6,
		  "title": "CompressionEngine â€” compress-before-prune",
		  "objective": "Define an observer-class equivalence clustering process that yields a deterministic compression snapshot and emits lawful_compression_ratio and related KPIs before any prune is even considered at Layer_1.",
		  "math": [
			"id": 1.6.1,
			"title": "CompressionEngine: Math",
			"1.6.1.1": {
			  "eq_id": 1.6.1.1,
			  "role": "equivalence and representatives",
			  "latex": "x \\sim y \\;\\Leftrightarrow\\; \\mathrm{key}(x)=\\mathrm{key}(y),\\quad \\mathcal{R}:=\\{\\text{representatives}\\},\\; N_{tot}:=|\\mathcal{X}|,\\; N_{rep}:=|\\mathcal{R}|",
			  "gloss": "Items belong to the same cluster if they share a deterministic key; one representative per cluster is retained in the snapshot."
			},
			"1.6.1.2": {
			  "eq_id": 1.6.1.2,
			  "role": "compression ratio",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} := 1 - \\frac{N_{rep}}{N_{tot}} \\in [0,1]",
			  "gloss": "Fraction of removable duplication under the declared equivalence; 0 means no compressible redundancy."
			},
			"1.6.1.3": {
			  "eq_id": 1.6.1.3,
			  "role": "glider-class canonicalization",
			  "latex": "\\mathrm{key}(x) := \\begin{cases} \\mathrm{canon}(x) & \\text{if glider\\_equivalence=ON}\\\\ \\mathrm{id}(x) & \\text{otherwise} \\end{cases}",
			  "gloss": "When shift-equivalence is enabled, keys map to the canonical class representative; this enforces idempotence."
			},
			"1.6.1.4": {
			  "eq_id": 1.6.1.4,
			  "role": "pressure threshold (advisory, observer-class)",
			  "latex": "\\lambda_{eq} := \\min\\big(1,\\;\\mathrm{EMA}_{32}(\\rho_{res})\\cdot \\gamma_{co}\\big)",
			  "gloss": "Advisory threshold derived from residual occupancy (rho_res) and coherence gain (gamma_co); used only to annotate KPIs, not to trigger pruning at L1."
			},
			"1.6.1.5": {
			  "eq_id": 1.6.1.5,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; L = 1 - \\frac{N_{rep}}{N_{tot}}\\;\\text{(stable)},\\quad \\lim_{\\mathcal{C}\\to 1}\\; \\lambda_{eq} = \\min(1,\\rho_{res}\\,\\gamma_{co})",
			  "gloss": "In the weak-field limit (high coherence), the snapshot is stable and advisory thresholds converge to fixed values."
			}
		  ],
		  "algorithms": [
			"id": 1.6.2,
			"title": "CompressionEngine: Algorithms",
			"build_equivalence_key": {
			  "id": 1.6.2.1,
			  "name": "build_equivalence_key",
			  "role": "observer",
			  "inputs": ["item", "feature_flags"],
			  "outputs": ["key"],
			  "params": ["normalize := ascii-lowercase", "ordering := lexicographic"],
			  "steps": [
				"1) Extract identity features from item (e.g., motif_id).",
				"2) If feature_flags.glider_equivalence=ON, map motif_id to its canonical class representative.",
				"3) Normalize key components to ASCII lowercase and join deterministically.",
				"4) Return key."
			  ]
			},
			"cluster_equivalence": {
			  "id": 1.6.2.2,
			  "name": "cluster_equivalence",
			  "role": "observer",
			  "inputs": ["items[]", "feature_flags"],
			  "outputs": ["clusters: map<key, list<item>>", "representatives: list<item>"],
			  "params": ["rep_selector := lexicographic-min by motif_id"],
			  "steps": [
				"1) For each item in items, k := build_equivalence_key(item, feature_flags); append item to clusters[k].",
				"2) For each k in clusters, choose representative := rep_selector(clusters[k]).",
				"3) Return clusters and the ordered list of representatives (sorted by key asc)."
			  ]
			},
			"compute_compression_snapshot": {
			  "id": 1.6.2.3,
			  "name": "compute_compression_snapshot",
			  "role": "observer",
			  "inputs": ["N_tot", "N_rep", "rho_res", "gamma_co"],
			  "outputs": ["snapshot"],
			  "params": [],
			  "steps": [
				"1) L := 1 - (N_rep / max(1, N_tot)).",
				"2) lambda_eq := min(1, EMA32(rho_res) * gamma_co).",
				"3) snapshot := { N_tot, N_rep, lawful_compression_ratio: L, lambda: lambda_eq }.",
				"4) Return snapshot."
			  ]
			},
			"emit_kpis_then_gate": {
			  "id": 1.6.2.4,
			  "name": "emit_kpis_then_gate",
			  "role": "observer",
			  "inputs": ["snapshot"],
			  "outputs": ["advice:{'observe_only'}", "kpis"],
			  "params": [],
			  "steps": [
				"1) Emit KPIs from snapshot (lawful_compression_ratio, N_rep, N_tot, lambda).",
				"2) Return advice='observe_only' to indicate that any prune decision lies outside Layer_1.",
				"3) End."
			  ]
			},
			"compression_pipeline": {
			  "id": 1.6.2.5,
			  "name": "compression_pipeline",
			  "role": "observer",
			  "inputs": ["items[]", "context:{rho_res, gamma_co, feature_flags}"],
			  "outputs": ["representatives[]", "snapshot", "advice"],
			  "params": [],
			  "steps": [
				"1) {clusters, representatives} := cluster_equivalence(items, feature_flags).",
				"2) snapshot := compute_compression_snapshot(N_tot=|items|, N_rep=|representatives|, rho_res, gamma_co).",
				"3) {advice, kpis} := emit_kpis_then_gate(snapshot).",
				"4) Return representatives (ordered), snapshot, advice."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Capacity-first: a compression snapshot MUST be computed and emitted before any prune is considered.",
			"I2 Determinism: clustering keys and representative selection are lexicographically stable and ASCII-normalized.",
			"I3 Idempotence under gliders: with glider_equivalence=ON, class members collapse to a single canonical representative.",
			"I4 Observer posture: no items are deleted or mutated at Layer_1; outputs are snapshots and KPIs only.",
			"I5 Safety bounds: lawful_compression_ratio L is confined to [0,1] for all inputs, including degenerate N_tot âˆˆ {0,1}."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"input": {
			  "items": [
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-hold@Îž" },
				{ "motif_id": "Ïˆ-null@Îž" }
			  ],
			  "rho_res": 0.62,
			  "gamma_co": 0.8
			},
			"output": {
			  "representatives": [
				"Ïˆ-hold@Îž",
				"Ïˆ-null@Îž",
				"Ïˆ-spar@Îž"
			  ],
			  "snapshot": {
				"N_tot": 4,
				"N_rep": 3,
				"lawful_compression_ratio": 0.25,
				"lambda": 0.496
			  },
			  "advice": "observe_only"
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "clusters_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" },
			{ "metric": "representatives_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0006", "clause": "Â§3â€“Â§4 equivalence geometry and canonical representatives for class stability" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis and KPI discipline (EMA windows, bounded gauges)" },
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal stability assumptions for snapshotting in weak-field regimes" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; observer-only outputs at L1" }
		  ],
		  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
		},
        "1.7": {
		  "id": 1.7,
		  "title": "ExportEnvelope â€” Î£/Î”/provenance on egress",
		  "objective": "Define an observer-class export envelope that attaches structural Sigma_phase and Delta_hash lineage (when flags enable them) together with provenance.origin and origin_hash, validating headers and failing closed on omissions, without implying cryptographic semantics or performing control writes.",
		  "math": [
			"id": 1.7.1,
			"title": "ExportEnvelope: Math",
			"1.7.1.1": {
			  "eq_id": 1.7.1.1,
			  "role": "phase header (structure-only)",
			  "latex": "\\mathrm{phase\\_hdr} := \\mathrm{pack}\\big(\\text{version},\\;\\text{tenant\\_id},\\;\\text{ts},\\;\\text{payload\\_kind}\\big)",
			  "gloss": "Deterministic, non-cryptographic header structure assembled from observable fields."
			},
			"1.7.1.2": {
			  "eq_id": 1.7.1.2,
			  "role": "Sigma_phase structural checksum",
			  "latex": "\\Sigma_{\\text{phase}} := \\mathsf{F}\\big(\\mathrm{phase\\_hdr}\\big)",
			  "gloss": "Sigma_phase is a structural digest of the phase header via a fixed, deterministic function F; no cryptographic claim is made at Layer_1."
			},
			"1.7.1.3": {
			  "eq_id": 1.7.1.3,
			  "role": "Delta_hash lineage chaining",
			  "latex": "\\Delta_{0} := \\mathsf{G}(\\text{payload\\_ref}),\\quad \\Delta_{n} := \\mathsf{G}\\big(\\Delta_{n-1} \\parallel \\text{payload\\_ref}_n\\big)",
			  "gloss": "Delta_hash forms a structural lineage chain over payload refs using a deterministic function G; it is used for ordering and detection of gaps at observer level."
			},
			"1.7.1.4": {
			  "eq_id": 1.7.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\big(\\Sigma_{\\text{phase}}, \\Delta_{n}\\big)\\;\\text{are stable under equal inputs}",
			  "gloss": "In the weak-field limit (high coherence), identical inputs yield invariant structural checksums, aiding reproducible observation."
			}
		  ],
		  "algorithms": [
			"id": 1.7.2,
			"title": "ExportEnvelope: Algorithms",
			"assemble_phase_header": {
			  "id": 1.7.2.1,
			  "name": "assemble_phase_header",
			  "role": "observer",
			  "inputs": ["version: 'YYYY-QX'", "tenant_id", "ts", "payload_kind /* 'metrics'|'bundle' */"],
			  "outputs": ["phase_hdr"],
			  "params": ["pack_order := [version, tenant_id, ts, payload_kind]"],
			  "steps": [
				"1) Validate version format 'YYYY-QX'.",
				"2) Construct phase_hdr by concatenating fields in pack_order using a deterministic pack() with ASCII normalization.",
				"3) Return phase_hdr."
			  ]
			},
			"compute_sigma_phase_struct": {
			  "id": 1.7.2.2,
			  "name": "compute_sigma_phase_struct",
			  "role": "observer",
			  "inputs": ["phase_hdr", "feature_flags.enable_exchange_envelope"],
			  "outputs": ["Sigma_phase?"],
			  "params": ["F := deterministic_map /* structure-only; no cryptography */"],
			  "steps": [
				"1) If feature_flags.enable_exchange_envelope is false, return null.",
				"2) Sigma_phase := F(phase_hdr).",
				"3) Return Sigma_phase."
			  ]
			},
			"extend_delta_lineage_struct": {
			  "id": 1.7.2.3,
			  "name": "extend_delta_lineage_struct",
			  "role": "observer",
			  "inputs": ["prev_Delta_hash?", "payload_ref", "feature_flags.enable_integrity_checks"],
			  "outputs": ["Delta_hash?"],
			  "params": ["G := deterministic_map /* structure-only; no cryptography */"],
			  "steps": [
				"1) If feature_flags.enable_integrity_checks is false, return null.",
				"2) If prev_Delta_hash is null: Delta_hash := G(payload_ref).",
				"3) Else: Delta_hash := G(prev_Delta_hash || payload_ref).",
				"4) Return Delta_hash."
			  ]
			},
			"validate_provenance_headers": {
			  "id": 1.7.2.4,
			  "name": "validate_provenance_headers",
			  "role": "observer",
			  "inputs": ["provenance.origin?", "origin_hash?", "feature_flags.enable_provenance_on_export"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": [],
			  "steps": [
				"1) If enable_provenance_on_export is true and (provenance.origin is missing OR origin_hash is missing), return (false,'missing_provenance').",
				"2) Ensure provenance.origin is ASCII and references a known registry entry at L1.",
				"3) Return (true,null)."
			  ]
			},
			"validate_sig_type_structural": {
			  "id": 1.7.2.5,
			  "name": "validate_sig_type_structural",
			  "role": "observer",
			  "inputs": ["sig_type?"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": ["allowed := ['phase-seal:v1','ed25519','ecdsa-p256'] /* structural labels only at L1 */"],
			  "steps": [
				"1) If sig_type is present and not in allowed, return (false,'illegal_sig_type').",
				"2) Return (true,null)."
			  ]
			},
			"export_envelope_observe": {
			  "id": 1.7.2.6,
			  "name": "export_envelope_observe",
			  "role": "observer",
			  "inputs": ["payload_ref", "phase_hdr_fields", "prev_Delta_hash?", "provenance", "sig_type?", "feature_flags"],
			  "outputs": ["envelope_headers", "decision:{'accept'|'reject'}", "policy_code?"],
			  "params": ["policy_codes := { missing_checksum: 'MMM-422-CHECKSUM', missing_evidence: 'MMM-422-EVIDENCE' }"],
			  "steps": [
				"1) phase_hdr := assemble_phase_header(phase_hdr_fields...).",
				"2) Sigma_phase := compute_sigma_phase_struct(phase_hdr, feature_flags.enable_exchange_envelope).",
				"3) Delta_hash := extend_delta_lineage_struct(prev_Delta_hash, payload_ref, feature_flags.enable_integrity_checks).",
				"4) (ok_sig, err_sig) := validate_sig_type_structural(sig_type). If not ok_sig, return (headers:=null, 'reject', 'MMM-422-CHECKSUM').",
				"5) (ok_prov, err_prov) := validate_provenance_headers(provenance.origin, provenance.origin_hash, feature_flags.enable_provenance_on_export).",
				"6) If any enabled flag requires a field that is missing (e.g., Sigma_phase when enable_exchange_envelope=true; Delta_hash when enable_integrity_checks=true; origin_hash when enable_provenance_on_export=true), return (headers:=null, 'reject', 'MMM-422-CHECKSUM').",
				"7) envelope_headers := { Sigma_phase?, Delta_hash?, provenance: { origin, origin_hash? }, sig_type? } with only enabled fields present.",
				"8) Return (envelope_headers, 'accept', null)."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Flag-gated presence: Sigma_phase appears iff enable_exchange_envelope=true; Delta_hash appears iff enable_integrity_checks=true; origin_hash appears iff enable_provenance_on_export=true.",
			"I2 Fail-closed: when a required field under an enabled flag is absent, the envelope is rejected with policy code MMM-422-CHECKSUM.",
			"I3 Structural only: Sigma_phase and Delta_hash are deterministic structural digests with no cryptographic claims at Layer_1.",
			"I4 Stable ordering: phase header packing order is fixed to ensure reproducibility across observers.",
			"I5 No control writes: this section observes and assembles headers but does not seal, sign, or persist artifacts.",
			"I6 Wrapped-unsigned guard: structurally illegal sig_type labels are rejected at observer level."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"scenarios": [
			  {
				"case": "flags_disabled_no_checksums",
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": false },
				"input": {
				  "payload_ref": "metrics:rollup:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1440001, "payload_kind": "metrics" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm" }
				},
				"result": {
				  "decision": "accept",
				  "envelope_headers": { "provenance": { "origin": "observer:mmm" }, "sig_type": "phase-seal:v1" }
				}
			  },
			  {
				"case": "flags_enabled_missing_origin_hash_rejected",
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"input": {
				  "payload_ref": "bundle:ontology:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1440020, "payload_kind": "bundle" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm" }
				},
				"result": {
				  "decision": "reject",
				  "policy_code": "MMM-422-CHECKSUM"
				}
			  },
			  {
				"case": "flags_enabled_headers_present_values_not-shown",
				"note": "To avoid placeholder checksums in examples, only presence booleans are shown.",
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"input": {
				  "payload_ref": "metrics:rollup:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1441000, "payload_kind": "metrics" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm", "origin_hash": "present" }
				},
				"result": {
				  "decision": "accept",
				  "headers_present": { "Sigma_phase": true, "Delta_hash": true, "origin_hash": true }
				}
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "import_reject_missing_checksum", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "illegal_sig_type_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "wrapped_unsigned_rejects", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "lineage_depth", "range": "[0, +inf)", "units": "count", "window": "EMA-16" },
			{ "metric": "export_packets_rate", "range": "[0, +inf)", "units": "packets/s", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline and structural envelope semantics at observer level" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance fields, origin and evidence linkage (non-cryptographic at L1)" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostatic validation via gauges and fail-closed behavior" },
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 stability considerations in weak-field regimes for reproducible headers" }
		  ],
		  "handoff": "Signals aligned, we submit the trace to immune lineage for lawful passage."
		},
        "1.8": {
		  "id": 1.8,
		  "title": "LLMRecallController â€” budgets & injection defense",
		  "objective": "Define an observer-class controller that governs token budgets, enforces recall hygiene (directive stripping, source tagging), and applies replay/freshness bounds using Î”Ï„_phase without introducing any Layer_2 constructs or control writes to Îž.",
		  "math": [
			"id": 1.8.1,
			"title": "LLMRecallController: Math",
			"1.8.1.1": {
			  "eq_id": 1.8.1.1,
			  "role": "context budget",
			  "latex": "\\text{tokens}_{\\text{usable}} = \\max\\big(0,\\; \\text{max\\_total} - \\text{reserve}_{\\text{system}}\\big)",
			  "gloss": "Usable token budget is the maximum window minus a fixed system reserve; truncate recall payloads to this bound."
			},
			"1.8.1.2": {
			  "eq_id": 1.8.1.2,
			  "role": "freshness window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive phase window from coherence governs which candidates are considered fresh during recall and rerank."
			},
			"1.8.1.3": {
			  "eq_id": 1.8.1.3,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Replay guard: candidates older than W ticks are deprioritized or excluded before truncation."
			},
			"1.8.1.4": {
			  "eq_id": 1.8.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\text{tokens}_{\\text{usable}}\\;\\text{stable},\\; W \\to 2\\alpha",
			  "gloss": "As coherence approaches unity, available context and admit windows stabilize, reducing jitter in recall composition."
			}
		  ],
		  "algorithms": [
			"id": 1.8.2,
			"title": "LLMRecallController: Algorithms",
			"compute_token_budgets": {
			  "id": 1.8.2.1,
			  "name": "compute_token_budgets",
			  "role": "observer",
			  "inputs": ["max_total=8192", "target=4096", "reserve_system=512"],
			  "outputs": ["budget:{usable:int, target:int, reserve:int}"],
			  "params": [],
			  "steps": [
				"1) usable := max(0, max_total - reserve_system).",
				"2) target := min(target, usable).",
				"3) Return budget := {usable, target, reserve: reserve_system}."
			  ]
			},
			"strip_control_sequences": {
			  "id": 1.8.2.2,
			  "name": "strip_control_sequences",
			  "role": "observer",
			  "inputs": ["text"],
			  "outputs": ["sanitized_text"],
			  "params": ["patterns := ['/^\\s*#(?!\\w)/', '/(?i)^(system:|assistant:|user:)/', '/```\\w*/', '/<\\/?tool[^>]*>/']"],
			  "steps": [
				"1) Remove lines matching directive-style prefixes (e.g., system:, assistant:, user:).",
				"2) Remove fenced-code delimiters and tool markup tokens.",
				"3) Collapse repeated whitespace; preserve quoted substrings verbatim.",
				"4) Return sanitized_text."
			  ]
			},
			"tag_source_metadata": {
			  "id": 1.8.2.3,
			  "name": "tag_source_metadata",
			  "role": "observer",
			  "inputs": ["item:{text, source?, evidence?, timestamp?}", "now_ts"],
			  "outputs": ["tagged_item:{text, source, confidence, timestamp}"],
			  "params": ["default_confidence := 0.5"],
			  "steps": [
				"1) Ensure 'source' is one of {'ontology','cache','index_cooccur','llm_note'}; if missing, set 'llm_note'.",
				"2) If evidence is present and references Reef, retain only {file,start_line,end_line}.",
				"3) confidence := item.confidence if provided else default_confidence.",
				"4) timestamp := item.timestamp if provided else now_ts.",
				"5) Return tagged_item."
			  ]
			},
			"freshness_and_replay_filter": {
			  "id": 1.8.2.4,
			  "name": "freshness_and_replay_filter",
			  "role": "observer",
			  "inputs": ["candidates[]", "ema32_C", "alpha", "now_tick", "seen_set /* in-memory key->last_seen_tick */"],
			  "outputs": ["filtered[]"],
			  "params": ["epsilon := 1", "compose_key := fn(item)->ascii_key"],
			  "steps": [
				"1) Compute Î”Ï„_phase := alpha * EMA32(C=ema32_C); W := 2 * Î”Ï„_phase.",
				"2) For each item in candidates:",
				"   2a) key := compose_key(item); last := seen_set.get(key) or null.",
				"   2b) If last != null and (now_tick - last) <= W + epsilon: mark item as 'replay' and drop.",
				"   2c) Else keep and set seen_set[key] := now_tick.",
				"3) Return filtered items."
			  ]
			},
			"rerank_and_truncate": {
			  "id": 1.8.2.5,
			  "name": "rerank_and_truncate",
			  "role": "observer",
			  "inputs": ["items[]", "budget:{usable,target,reserve}", "psi_field?"],
			  "outputs": ["final_items[]"],
			  "params": ["rerank_k := 6", "source_order := ['ontology','cache','index_cooccur','llm_note']"],
			  "steps": [
				"1) Group items by source; within each group, stable-sort by timestamp desc then lexical text asc.",
				"2) Merge groups by source_order; compute running token_count(text).",
				"3) Keep adding until token_count >= budget.target; if exceeded, drop tail items.",
				"4) Return final_items within target budget (never exceeding budget.usable)."
			  ]
			},
			"recall_pipeline_observer": {
			  "id": 1.8.2.6,
			  "name": "recall_pipeline_observer",
			  "role": "observer",
			  "inputs": ["query", "k=10", "psi_field:'Ïˆ-[a-z0-9_]+@Îž'?", "ema32_C", "alpha", "now_tick", "feature_flags"],
			  "outputs": ["items:[{text, source, confidence, timestamp, evidence?}]"],
			  "params": ["ordered_sources := ['ontology','cache','index_cooccur','llm_note']", "reserve_system := 512"],
			  "steps": [
				"1) budget := compute_token_budgets(max_total=8192, target=4096, reserve_system).",
				"2) Gather candidates in ordered_sources; for Reef-derived entries, attach evidence windows {file,start_line,end_line}.",
				"3) Map each candidate.text := strip_control_sequences(candidate.text).",
				"4) candidates := freshness_and_replay_filter(candidates, ema32_C, alpha, now_tick, seen_set).",
				"5) items := tag_source_metadata(candidates[*], now_ts=now_tick).",
				"6) final_items := rerank_and_truncate(items, budget, psi_field).",
				"7) Return final_items."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Budgets first: reserve 512 tokens for system context; never exceed usable = max_total - reserve.",
			"I2 Replay defense: apply W = 2Â·Î”Ï„_phase with LRU semantics to prevent within-window duplicates.",
			"I3 Reef discipline: any Reef-derived recall MUST include an evidence window {file,start_line,end_line} only (no snippets at L1).",
			"I4 Hygiene: strip control directives and tool markup before inclusion in recall output.",
			"I5 Deterministic ordering: source precedence = ontology > cache > index_cooccur > llm_note; ties break by timestamp desc, then lexicographic asc.",
			"I6 Observer posture: no control writes, no cryptographic claims, no storage side-effects at L1.",
			"I7 Weak-field stability: as ð’žâ†’1, budgets and replay windows converge to fixed values, stabilizing output composition."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"feature_flags": { "enable_point_space_gliders": true },
			"request": { "query": "Summarize triad completion for motif Î±Î²", "k": 6 },
			"response": {
			  "items": [
				{ "text": "Ontology notes define the closure for Î±Î²â†’Î³.", "source": "ontology", "confidence": 0.96, "timestamp": 1441201 },
				{ "text": "Prior cache entry confirms Î³ as canonical representative.", "source": "cache", "confidence": 0.88, "timestamp": 1441190 },
				{ "text": "Co-occurrence supports Î³ near Î±Î² anchors.", "source": "index_cooccur", "confidence": 0.72, "timestamp": 1441180, "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 } }
			  ],
			  "metrics": { "C": 0.83, "rho_res": 0.12 }
			}
		  },
		  "telemetry": [
			{ "metric": "context_budget_utilization", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "injection_strip_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "staleness_index", "range": "[0, 1]", "units": "ratio", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal continuity, decay, and replay framing (Î”Ï„_phase windows)" },
			{ "source": "RFC-0006", "clause": "Â§3 field-coherence geometry and weak-field stability (ð’žâ†’1 bounds)" },
			{ "source": "RFC-0007", "clause": "Â§2â€“Â§3 ontology naming (Ïˆ-*), version format, and validation before recall usage" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA windows, and observable KPIs for hygiene defenses" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; evidence-window discipline for external sources" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		}
      ]
    },

    "2": {
      "id": 2,
      "title": "Pseudocode",
      "subsections": [
        "2.1": {
		  "id": 2.1,
		  "title": "Core Method Suite",
		  "objective": "Specify observer-class method signatures and normative orchestration for recall, dyad completion, compression snapshotting, and export envelope assembly, binding freshness to Î”Ï„_phase and preserving provenance without any Layer_2 controls.",
		  "math": [
			"id": 2.1.1,
			"title": "Core Method Suite: Math",
			"2.1.1.1": {
			  "eq_id": 2.1.1.1,
			  "role": "replay window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive phase window derived from coherence \\(\\mathcal{C}\\) bounds freshness and duplicate admission."
			},
			"2.1.1.2": {
			  "eq_id": 2.1.1.2,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Items observed within W ticks are considered potential replays and are filtered before ranking."
			},
			"2.1.1.3": {
			  "eq_id": 2.1.1.3,
			  "role": "compression KPI",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} = 1 - \\frac{N_{rep}}{\\max(1, N_{tot})}",
			  "gloss": "Compute a lawful equivalence snapshot before any pruning consideration."
			},
			"2.1.1.4": {
			  "eq_id": 2.1.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; W \\to 2\\alpha,\\; L\\;\\text{stable}",
			  "gloss": "As coherence approaches unity, admit windows stabilize and compression snapshots become reproducible."
			}
		  ],
		  "algorithms": [
			"id": 2.1.2,
			"title": "Core Method Suite: Algorithms",
			"recall": {
			  "id": 2.1.2.1,
			  "name": "recall",
			  "role": "observer",
			  "inputs": ["query", "k=10", "psi_field:'Ïˆ-[a-z0-9_]+@Îž'?", "ema32_C", "alpha", "now_tick", "feature_flags", "reef_ctx?"],
			  "outputs": ["items:[{text, source, confidence, timestamp, evidence?}]"],
			  "params": ["reserve_system := 512", "max_total := 8192", "target := 4096", "ordered_sources := ['ontology','cache','index_cooccur','llm_note']"],
			  "steps": [
				"1) Validate psi_field (if provided) per RFC-0007 pattern.",
				"2) Compute Î”Ï„_phase := alpha * EMA32(C=ema32_C), W := 2*Î”Ï„_phase.",
				"3) Gather candidates in ordered_sources; attach {file,start_line,end_line} for any Reef-derived candidate.",
				"4) Strip control directives/tool markup from candidate.text.",
				"5) Filter replays: drop any candidate whose seen_key last_seen is within W (+Îµ) and update seen_set.",
				"6) Rank by source precedence then timestamp desc then lexicographic asc; keep top k.",
				"7) Token-budget: reserve 512; cap payload at target â‰¤ (max_total - reserve).",
				"8) Return items with {text, source, confidence, timestamp, evidence?}."
			  ]
			},
			"complete_dyad": {
			  "id": 2.1.2.2,
			  "name": "complete_dyad",
			  "role": "observer",
			  "inputs": ["m1", "m2", "feature_flags", "reef_ctx?", "ontology_graph", "reflections_cache?"],
			  "outputs": ["{m3|null, provenance, evidence?}"],
			  "params": ["precedence := ['ontology','file_reflections','index_cooccur']", "glider_equivalence := feature_flags.glider_equivalence"],
			  "steps": [
				"1) If ontology defines a unique completion, return m3 with provenance='ontology'.",
				"2) Else consult reflections_cache; if present, return entry.",
				"3) Else, compute candidates via index co-occurrence; include Reef evidence windows for any claim.",
				"4) Apply glider_equivalence (if ON) to return canonical representative.",
				"5) Deterministic tie-break within same source: lexicographic-min m3.",
				"6) Return {m3, provenance, evidence?} or null if not found."
			  ]
			},
			"compress_snapshot": {
			  "id": 2.1.2.3,
			  "name": "compress_snapshot",
			  "role": "observer",
			  "inputs": ["items[]", "feature_flags", "rho_res", "gamma_co"],
			  "outputs": ["{ratio:L, clusters:int, representatives:int, snapshot}"],
			  "params": ["rep_selector := lexicographic-min by motif_id"],
			  "steps": [
				"1) Cluster by deterministic equivalence key; if glider_equivalence=ON map to canonical representatives.",
				"2) Compute L per math[2.1.3]; build snapshot={N_tot,N_rep,lawful_compression_ratio:L,lambda:=min(1,EMA32(rho_res)*gamma_co)}.",
				"3) Emit KPIs from snapshot; return {ratio:L, clusters:=|clusters|, representatives:=|representatives|, snapshot}."
			  ]
			},
			"export_packet": {
			  "id": 2.1.2.4,
			  "name": "export_packet",
			  "role": "observer",
			  "inputs": ["kind:'metrics'|'bundle'", "body_ref", "provenance:{origin, origin_hash?}", "prev_Delta_hash?", "phase_hdr_fields:{version:'YYYY-QX',tenant_id,ts,payload_kind}", "feature_flags", "sig_type?"],
			  "outputs": ["{ok:boolean, envelope? , policy_code?}"],
			  "params": ["require_flags := {exchange:feature_flags.enable_exchange_envelope, integrity:feature_flags.enable_integrity_checks, prov:feature_flags.enable_provenance_on_export}"],
			  "steps": [
				"1) phase_hdr := assemble_phase_header(version,tenant_id,ts,payload_kind).",
				"2) Sigma_phase := (require_flags.exchange) ? compute_sigma_phase_struct(phase_hdr) : null.",
				"3) Delta_hash := (require_flags.integrity) ? extend_delta_lineage_struct(prev_Delta_hash, body_ref) : null.",
				"4) (ok_sig,_) := validate_sig_type_structural(sig_type); if !ok_sig â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"5) (ok_prov,_) := validate_provenance_headers(provenance.origin, provenance.origin_hash, require_flags.prov); if !ok_prov â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"6) If any required field by enabled flag is missing â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"7) envelope := {Sigma_phase?, Delta_hash?, provenance:{origin, origin_hash?}, sig_type?} including only enabled fields.",
				"8) Return {ok:true, envelope}."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Freshness & replay: recall and dyad flows apply W=2Â·Î”Ï„_phase with an LRU seen_set policy.",
			"I2 Evidence discipline: any Reef-derived output includes {file,start_line,end_line} pointers only.",
			"I3 Compression-before-prune: compute lawful_compression_ratio prior to any prune recommendation.",
			"I4 Deterministic order: source precedence and tie-break rules are fixed and stable.",
			"I5 Flag gating: Sigma_phase/Delta_hash/origin_hash appear only when corresponding flags are enabled.",
			"I6 Observer posture: no control writes, no cryptographic claims, no storage or RBAC semantics at L1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"C": 0.84,
			"call_sequence": [
			  {
				"fn": "recall",
				"args": { "query": "triad closure for Î±Î²", "k": 5 },
				"result": {
				  "items": [
					{ "text": "Ontology defines Î±Î²â†’Î³.", "source": "ontology", "confidence": 0.95, "timestamp": 1442101 },
					{ "text": "Cache confirms Î³ canonical.", "source": "cache", "confidence": 0.88, "timestamp": 1442090 },
					{ "text": "Co-occur supports Î³ near anchors.", "source": "index_cooccur", "confidence": 0.72, "timestamp": 1442080, "evidence": { "file": "TheReefArchive-02.REEF", "start_line": 220, "end_line": 244 } }
				  ]
				}
			  },
			  {
				"fn": "complete_dyad",
				"args": { "m1": "Î±", "m2": "Î²" },
				"result": { "m3": "Î³", "provenance": "ontology" }
			  },
			  {
				"fn": "compress_snapshot",
				"args": { "items": [{ "motif_id": "Î±" }, { "motif_id": "Î²" }, { "motif_id": "Î²" }, { "motif_id": "Î³" }], "rho_res": 0.20, "gamma_co": 0.8 },
				"result": { "ratio": 0.25, "clusters": 3, "representatives": 3 }
			  },
			  {
				"fn": "export_packet",
				"args": {
				  "kind": "metrics",
				  "body_ref": "metrics:rollup:2025Q4:acme",
				  "provenance": { "origin": "observer:mmm", "origin_hash": "present" },
				  "prev_Delta_hash": "present",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1443000, "payload_kind": "metrics" },
				  "feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				  "sig_type": "phase-seal:v1"
				},
				"result": { "ok": true, "headers_present": { "Sigma_phase": true, "Delta_hash": true, "origin_hash": true } }
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "staleness_index", "range": "[0,1]", "units": "ratio", "window": "EMA-64" },
			{ "metric": "replay_within_window_rate", "range": "[0,1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "context_budget_utilization", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "ratio", "window": "EMA-32" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 decay, replay framing, and admissibility via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 coherence geometry and weak-field stability (ð’žâ†’1)" },
			{ "source": "RFC-0007", "clause": "Â§2â€“Â§3 Ïˆ-field naming and ontology validation rules" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline and structural envelope semantics" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA windows, and KPI discipline" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure and evidence pointers" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "2.2": {
		  "id": 2.2,
		  "title": "Reef Adapter Methods",
		  "objective": "Define observer-class, read-only methods over Reef index and shard files that return deterministic pointers and evidence windows, suitable for recall and dyad completion without mutating Reef or introducing Layer_2 concerns.",
		  "math": [
			"id": 2.2.1,
			"title": "Reef Adapter Methods: Math",
			"2.2.1.1": {
			  "eq_id": 2.2.1.1,
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive coherence-derived phase window bounds admissibility for replay filtering when traversing Reef-derived candidates."
			},
			"2.2.1.2": {
			  "eq_id": 2.2.1.2,
			  "role": "evidence radius",
			  "latex": "R = \\min\\big(R_{\\max},\\; \\lfloor EMA_{16}(\\mathcal{C}) \\rfloor + 1\\big)",
			  "gloss": "Context radius used to form evidence windows around an anchor line; bounded and coherence-smoothed."
			},
			"2.2.1.3": {
			  "eq_id": 2.2.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; R \\to 2,\\; \\Delta \\tau_{\\text{phase}} \\to 2\\alpha",
			  "gloss": "At high coherence, evidence windows stabilize to minimal, deterministic spans and replay windows converge to a fixed size."
			}
		  ],
		  "algorithms": [
			"id": 2.2.2,
			"title": "Reef Adapter Methods Algorithms",
			"list_modules": {
			  "id": 2.2.2.1,
			  "name": "list_modules",
			  "role": "observer",
			  "inputs": ["reef_index_path := 'index.REEF'"],
			  "outputs": ["modules:[{module_id, title?}]"],
			  "params": [],
			  "steps": [
				"1) Parse reef_index_path; extract module entries in index order.",
				"2) For each module, emit {module_id, title?} with ASCII keys only.",
				"3) Return modules."
			  ]
			},
			"list_motifs": {
			  "id": 2.2.2.2,
			  "name": "list_motifs",
			  "role": "observer",
			  "inputs": ["module_id", "reef_index_path := 'index.REEF'"],
			  "outputs": ["motifs:[{motif_id, anchors:int}]"],
			  "params": [],
			  "steps": [
				"1) Locate module_id in reef_index_path.",
				"2) Collect motif identifiers and count of anchor references.",
				"3) Stable-sort lexicographically by motif_id and return."
			  ]
			},
			"find": {
			  "id": 2.2.2.3,
			  "name": "find",
			  "role": "observer",
			  "inputs": ["route:{module_id, anchor}"],
			  "outputs": ["{file, line}"],
			  "params": [],
			  "steps": [
				"1) Resolve route in the index to obtain the shard file and first anchor line.",
				"2) Return {file, line} as pointers; do not dereference content at L1."
			  ]
			},
			"window": {
			  "id": 2.2.2.4,
			  "name": "window",
			  "role": "observer",
			  "inputs": ["file", "line:int", "radius:int?"],
			  "outputs": ["evidence:{file, start_line, end_line}"],
			  "params": ["R_max := 48", "use_R := radius if provided else R from math[2.2.2]"],
			  "steps": [
				"1) Compute R := min(R_max, max(1, use_R)).",
				"2) start := max(1, line - R); end := line + R.",
				"3) Return evidence := {file, start_line:start, end_line:end}. /* pointers only; no snippet text at L1 */"
			  ]
			},
			"cooccur": {
			  "id": 2.2.2.5,
			  "name": "cooccur",
			  "role": "observer",
			  "inputs": ["m1", "m2", "reef_shards_glob := 'TheReefArchive-*.REEF'", "ema32_C", "alpha", "now_tick", "seen_set"],
			  "outputs": ["{candidates:[m3], evidence:[{file,start_line,end_line}]}"],
			  "params": ["W := 2 * (alpha * EMA32(C=ema32_C))"],
			  "steps": [
				"1) Scan shards for co-occurrence windows containing both m1 and m2 within bounded proximity.",
				"2) For each hit, derive third-symbol candidates m3 by local pattern rules and collect their anchor lines.",
				"3) Build evidence windows via window(file,line) for each supporting occurrence.",
				"4) Apply replay filter: drop candidate keys seen within W ticks; update seen_set for admitted keys.",
				"5) Deduplicate candidates by lexicographic-min representative; stable-sort lexicographically.",
				"6) Return {candidates, evidence}."
			  ]
			},
			"build_reflections": {
			  "id": 2.2.2.6,
			  "name": "build_reflections",
			  "role": "observer",
			  "inputs": ["limit:int?=50000", "strategy?='index_cooccur|module_scan'", "ema32_C", "alpha", "now_tick", "seen_set"],
			  "outputs": ["{built:int, updated:int, skipped:int, reflections:[{m1,m2,m3, evidence:{file,start_line,end_line}}]}"],
			  "params": [],
			  "steps": [
				"1) Initialize counters {built,updated,skipped}:=0; reflections:=[].",
				"2) Iterate motif pairs per strategy subject to limit.",
				"3) For each pair, call cooccur(m1,m2,...) to obtain {candidates,evidence}.",
				"4) For each m3 in candidates, form reflection record with minimal evidence window.",
				"5) Update counters deterministically (no external writes at L1); append to reflections until limit.",
				"6) Return summary counters and reflections array."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Read-only posture: no Reef file mutation; methods return pointers and evidence windows only.",
			"I2 Evidence discipline: any Reef-informed output MUST include {file,start_line,end_line}.",
			"I3 Replay defense: cooccur and build_reflections enforce W = 2Â·Î”Ï„_phase with LRU semantics.",
			"I4 Determinism: stable sorting (lexicographic) for modules, motifs, and candidates; tie-breaks are explicit.",
			"I5 Weak-field stability: as ð’žâ†’1, evidence radius and replay windows converge to fixed bounds.",
			"I6 ASCII on-wire keys: all emitted keys remain ASCII; Ïˆ-* fields appear only in example bodies or references."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"calls": [
			  {
				"fn": "list_modules",
				"result": { "modules": [ { "module_id": "core/memory" }, { "module_id": "field/geometry" } ] }
			  },
			  {
				"fn": "find",
				"args": { "route": { "module_id": "core/memory", "anchor": "triad_complete" } },
				"result": { "file": "TheReefArchive-00.REEF", "line": 1024 }
			  },
			  {
				"fn": "window",
				"args": { "file": "TheReefArchive-00.REEF", "line": 1024, "radius": 24 },
				"result": { "evidence": { "file": "TheReefArchive-00.REEF", "start_line": 1000, "end_line": 1048 } }
			  },
			  {
				"fn": "cooccur",
				"args": { "m1": "alpha", "m2": "beta" },
				"result": {
				  "candidates": ["gamma"],
				  "evidence": [ { "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 } ]
				}
			  }
			],
			"metrics": { "C": 0.82, "rho_res": 0.11 }
		  },
		  "telemetry": [
			{ "metric": "reef_index_modules_count", "range": "[0, +inf)", "units": "count", "window": "EMA-64" },
			{ "metric": "reef_shard_count", "range": "[0, +inf)", "units": "count", "window": "EMA-64" },
			{ "metric": "reef_cooccur_candidate_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 replay bounds and admissibility via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 field-coherence geometry; stability as ð’žâ†’1" },
			{ "source": "RFC-0007", "clause": "Â§2 ontology naming and structural validation prior to use" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline; pointer-style provenance for external sources" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis and EMA windowing for gauges" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; evidence-window schema" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "2.3": {
		  "id": 2.3,
		  "title": "Observability (local gauges)",
		  "objective": "Define observer-class gauges and rollups that let the system see itself locally: compute lawful compression and equivalence efficiency, track reanchor and quarantine activity, estimate average replay window ticks, and report glider detections when feature-gated.",
		  "math": [
			"id": 2.3.1,
			"title": "Observability (local gauges): Math",
			"2.3.1.1": {
			  "eq_id": 2.3.1.1,
			  "role": "EMA windowing",
			  "latex": "EMA_{n}(x)_t = \\beta\\,x_t + (1-\\beta)\\,EMA_{n}(x)_{t-1},\\; \\beta = \\tfrac{2}{n+1}",
			  "gloss": "All gauges use fixed EMA windows n âˆˆ {16,32,64} for stable local smoothing."
			},
			"2.3.1.2": {
			  "eq_id": 2.3.1.2,
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Replay/recall gauges reference the adaptive phase window derived from coherence."
			},
			"2.3.1.3": {
			  "eq_id": 2.3.1.3,
			  "role": "average replay window (ticks)",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "The decision horizon for duplicate admission; the gauge reports its EMA-smoothed estimate."
			},
			"2.3.1.4": {
			  "eq_id": 2.3.1.4,
			  "role": "compression KPI",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} = 1 - \\frac{N_{rep}}{\\max(1, N_{tot})}",
			  "gloss": "Snapshot of lawful equivalence before any pruning consideration."
			},
			"2.3.1.5": {
			  "eq_id": 2.3.1.5,
			  "role": "equivalence efficiency",
			  "latex": "E := \\frac{N_{rep}}{\\max(1, N_{classes})}",
			  "gloss": "Measures how effectively duplicates collapse into canonical representatives."
			},
			"2.3.1.6": {
			  "eq_id": 2.3.1.6,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; W \\to 2\\alpha,\\; L,E\\;\\text{stable}",
			  "gloss": "As coherence approaches unity, replay horizon and compression/efficiency stabilize for reproducible gauges."
			}
		  ],
		  "algorithms": [
			"id": 2.3.2,
			"title": "Observability (local gauges): Algorithms",
			"gauge_lawful_compression_ratio": {
			  "id": 2.3.2.1,
			  "name": "gauge_lawful_compression_ratio",
			  "role": "observer",
			  "inputs": ["snapshot:{N_tot:int, N_rep:int}"],
			  "outputs": ["L:float"],
			  "params": [],
			  "steps": [
				"1) L := 1 - (N_rep / max(1, N_tot)).",
				"2) Return L."
			  ]
			},
			"gauge_equivalence_efficiency": {
			  "id": 2.3.2.2,
			  "name": "gauge_equivalence_efficiency",
			  "role": "observer",
			  "inputs": ["classes:int", "duplicates:int"],
			  "outputs": ["E:float"],
			  "params": [],
			  "steps": [
				"1) E := duplicates / max(1, classes).",
				"2) Return E."
			  ]
			},
			"gauge_avg_replay_window_ticks": {
			  "id": 2.3.2.3,
			  "name": "gauge_avg_replay_window_ticks",
			  "role": "observer",
			  "inputs": ["ema32_C:float", "alpha:float"],
			  "outputs": ["W_ticks:float"],
			  "params": [],
			  "steps": [
				"1) Î”Ï„_phase := alpha * EMA32(C=ema32_C).",
				"2) W_ticks := 2 * Î”Ï„_phase.",
				"3) Return W_ticks."
			  ]
			},
			"gauge_reanchor_rate": {
			  "id": 2.3.2.4,
			  "name": "gauge_reanchor_rate",
			  "role": "observer",
			  "inputs": ["events_stream /* local observer feed */"],
			  "outputs": ["rate:float"],
			  "params": ["window := 'EMA-32'"],
			  "steps": [
				"1) Count reanchor events in the current tick; call this r_t.",
				"2) rate := EMA32(r_t).",
				"3) Return rate."
			  ]
			},
			"gauge_quarantine_count": {
			  "id": 2.3.2.5,
			  "name": "gauge_quarantine_count",
			  "role": "observer",
			  "inputs": ["events_stream"],
			  "outputs": ["count:int"],
			  "params": ["window := 'EMA-16'"],
			  "steps": [
				"1) Count new quarantine events this tick; q_t := count.",
				"2) count := EMA16(q_t).",
				"3) Return count."
			  ]
			},
			"gauge_glider_detected": {
			  "id": 2.3.2.6,
			  "name": "gauge_glider_detected",
			  "role": "observer",
			  "inputs": ["feature_flags", "glider_events_stream?"],
			  "outputs": ["detected:float"],
			  "params": ["window := 'EMA-16'"],
			  "steps": [
				"1) If feature_flags.enable_point_space_gliders != true â†’ return detected := 0.",
				"2) g_t := count of glider detections this tick (observer-only).",
				"3) detected := EMA16(g_t).",
				"4) Return detected."
			  ]
			},
			"emit_local_gauges": {
			  "id": 2.3.2.7,
			  "name": "emit_local_gauges",
			  "role": "observer",
			  "inputs": ["snapshot", "ema32_C", "alpha", "events_stream", "feature_flags"],
			  "outputs": ["gauges:{lawful_compression_ratio, equivalence_efficiency, reanchor_rate, quarantine_count, avg_replay_window_ticks, glider_detected?}"],
			  "params": [],
			  "steps": [
				"1) L := gauge_lawful_compression_ratio(snapshot).",
				"2) E := gauge_equivalence_efficiency(classes:=snapshot.N_classes, duplicates:=snapshot.N_rep).",
				"3) W := gauge_avg_replay_window_ticks(ema32_C, alpha).",
				"4) R := gauge_reanchor_rate(events_stream).",
				"5) Q := gauge_quarantine_count(events_stream).",
				"6) G := gauge_glider_detected(feature_flags, events_stream).",
				"7) Return gauges with G included only if enable_point_space_gliders=true."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Windows discipline: Only EMA-16/32/64 are used for smoothing.",
			"I2 Capacity-first visibility: lawful_compression_ratio is computed before any pruning recommendation.",
			"I3 Replay coupling: avg_replay_window_ticks derives from Î”Ï„_phase and moves with coherence.",
			"I4 Flag gating: glider_detected appears only when enable_point_space_gliders=true.",
			"I5 Observer posture: gauges read local streams/snapshots; no control writes or Layer_2 mechanics.",
			"I6 Determinism: stable calculations and explicit tie-breaks for counts; ASCII keys on wire."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"feature_flags": { "enable_point_space_gliders": true },
			"snapshot": { "N_tot": 200, "N_rep": 50, "N_classes": 140 },
			"gauges": {
			  "lawful_compression_ratio": 0.75,
			  "equivalence_efficiency": 0.36,
			  "reanchor_rate": 0.08,
			  "quarantine_count": 0.02,
			  "avg_replay_window_ticks": 9.6,
			  "glider_detected": 0.03
			},
			"metrics": { "C": 0.84, "lambda": 0.66, "gamma_co": 0.80, "rho_res": 0.12, "delta_closure": 0.41 }
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "reanchor_rate", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-32" },
			{ "metric": "quarantine_count", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-64" },
			{ "metric": "glider_detected", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 decay and replay framing via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 coherence geometry; stability as ð’žâ†’1" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA smoothing, KPI discipline" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline (observer provenance on gauges)" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure for emitted observations" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		}
      ]
    },

    "3": {
	  "id": 3,
	  "title": "Project-Local API Contracts (FastAPI stubs)",
	  "objective": "Define observer-class, project-local HTTP contracts that mirror Layer_1 algorithms without introducing Layer_2 controls; specify schemas, validation order, replay defenses, and flag-gated structural fields for exchange/integrity while keeping Îž read-only.",
	  "math": [
		"id": 3.1,
		"title": "Project-Local API Contracts (FastAPI stubs): Math",
		"3.1.1": {
		  "eq_id": 3.1.1,
		  "role": "bound",
		  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot \\operatorname{EMA}_{32}(\\mathcal{C})\\,,\\quad \\alpha \\in [0.5, 2.0]",
		  "gloss": "Adaptive replay window used by ingress/trace observers; Î± tunes window length to coherence."
		},
		"3.1.2": {
		  "eq_id": 3.1.2,
		  "role": "geometry",
		  "latex": "T^{\\mu} := \\nabla^{\\mu} \\mathcal{C}\\,",
		  "gloss": "Time vector for projecting TTL/decay decisions in observer algorithms that reference temporal falloff."
		},
		"3.1.3": {
		  "eq_id": 3.1.3,
		  "role": "capacity",
		  "latex": "\\text{lawful\\_compression\\_ratio} = \\frac{\\text{equivalence\\_compressed\\_size}}{\\text{pre\\!\\_compress\\_size}}",
		  "gloss": "Snapshot KPI that must be taken before any prune recommendation is emitted by observers."
		},
		"3.1.4": {
		  "eq_id": 3.1.4,
		  "role": "limit",
		  "latex": "\\mathcal{C} \\to 1",
		  "gloss": "Weak-field limit: observers reduce to steady-state measurement with minimal damping."
		}
	  ],
	  "algorithms": [
		"id": 3.2,
		"title": "Project-Local API Contracts (FastAPI stubs): Algorithms",
		"post_v1-mmm-ingest-bundle_observer_stub": {
		  "id": 3.2.1,
		  "name": "POST /v1/mmm/ingest/bundle (observer stub)",
		  "role": "observer",
		  "inputs": [
			"OntologyBundleHeader { version:'YYYY-QX', provenance:{ origin, origin_hash }, psi_field:'Ïˆ-{fieldname}@Îž' }",
			"blob_ref (opaque pointer)"
		  ],
		  "outputs": [
			"trace_id",
			"status {'received'|'validated'|'quarantined'}"
		  ],
		  "params": [
			"flags.enable_exchange_envelope (bool)",
			"flags.enable_integrity_checks (bool)",
			"Î”Ï„_phase (from M3.1)"
		  ],
		  "steps": [
			"Validate version matches YYYY-QX and psi_field matches ^Ïˆ-[a-z0-9_]+@Îž$ (RFC-0007).",
			"Run DAG acyclicity and triad/dyad cross-reference checks (RFC-0007).",
			"Apply replay defense: reject if seen_set contains bundle_id within window=2Â·Î”Ï„_phase (hybrid LRU policy).",
			"Record lawful_compression_ratio snapshot on the header payload (no pruning at L1).",
			"If flags.enable_exchange_envelope, attach structural Sigma_phase; if flags.enable_integrity_checks, attach structural Delta_hash (no cryptographic meaning at L1).",
			"Emit trace event {'event':'ingest.validated'|'ingest.quarantined'} with payload_ref and return trace_id."
		  ]
		},
		"post_v1-mmm-recall-query_observer_stub": {
		  "id": 3.2.2,
		  "name": "POST /v1/mmm/recall/query (observer stub)",
		  "role": "observer",
		  "inputs": [
			"{ query:string, k:int<=12, psi_field?:'Ïˆ-{fieldname}@Îž', tenant_id?:string }"
		  ],
		  "outputs": [
			"{ items:[{ motif_id, score, provenance }], budget_used:int, notes?:string }"
		  ],
		  "params": [
			"context_budget_tokens.max_total=8192",
			"context_budget_tokens.target=4096",
			"rerank_k=6"
		  ],
		  "steps": [
			"Apply budget cap first; truncate recall candidates to target tokens.",
			"Strip control-sequence/injection directives from recalled text (observer filter only).",
			"Ensure provenance tags are present on each item; mark {source, confidence, timestamp}.",
			"Return top-k items with scores; do not perform any control write or mutation at L1."
		  ]
		},
		"post_v1-mmm-reef-window_observer_stub": {
		  "id": 3.2.3,
		  "name": "POST /v1/mmm/reef/window (observer stub)",
		  "role": "observer",
		  "inputs": [
			"{ module_id:string, line:int, radius?:int=24 }"
		  ],
		  "outputs": [
			"{ evidence:{ file:string, start_line:int, end_line:int }, cooccur?:[{ m1, m2, support_count }] }"
		  ],
		  "params": [
			"radius âˆˆ [8, 128]",
			"MMM_WINDOW_RADIUS default 24"
		  ],
		  "steps": [
			"Read-only scan over index.REEF/shards; never mutate Reef content.",
			"Return evidence window pointers only (no snippet text at L1).",
			"Optionally include co-occurrence candidates computed from [INDEX] proximity."
		  ]
		},
		"post_v1-mmm-export-packet_observer_stub": {
		  "id": 3.2.4,
		  "name": "POST /v1/mmm/export/packet (observer stub)",
		  "role": "observer",
		  "inputs": [
			"{ kind:'metrics'|'bundle', body:object, provenance:{ origin, origin_hash } }"
		  ],
		  "outputs": [
			"{ packet_id, envelope?:{ Sigma_phase?, Delta_hash?, origin_hash? } }"
		  ],
		  "params": [
			"flags.enable_exchange_envelope",
			"flags.enable_integrity_checks",
			"flags.enable_provenance_on_export"
		  ],
		  "steps": [
			"Validate provenance is present (origin, origin_hash).",
			"If flags.enable_exchange_envelope attach Sigma_phase structurally; if flags.enable_integrity_checks attach Delta_hash structurally; if flags.enable_provenance_on_export include origin_hash.",
			"Emit observer trace {'event':'export.staged'} with payload_ref; return packet_id."
		  ]
		}
	  ],
	  "invariants": [
		"I3.1 Observer-only: no control writes to Îž are permitted in project-local mode (PDP-0001).",
		"I3.2 Replay defense: ingress rejects duplicates within time_window = 2Â·Î”Ï„_phase using LRU within the window (RFC-0005).",
		"I3.3 Capacity-first: a lawful_compression_ratio snapshot MUST be taken before any prune recommendation (RFC-0006).",
		"I3.4 Provenance required on import/export structures; Reef-derived claims MUST include evidence windows (RFC-0007).",
		"I3.5 Structural checksums Sigma_phase and Delta_hash are flag-gated and non-cryptographic at L1 (RFC-0008).",
		"I3.6 Weak-field behavior holds: as ð’ž stabilizes, observers reduce to steady measurement with minimal damping (RFC-0009)."
	  ],
	  "example_json": {
		"ingest_request": {
		  "version": "2025-Q4",
		  "provenance": { "origin": "unit:test", "origin_hash": "b64:7b4f0d0a2a93f6d0" },
		  "psi_field": "Ïˆ-null@Îž",
		  "bundle_id": "bndl_01HZW7F4W6",
		  "blob_ref": "object://bucket/bundles/bndl_01HZW7F4W6"
		},
		"ingest_response": {
		  "trace_id": "trc_01J0A9Y3K5",
		  "status": "validated"
		},
		"recall_request": {
		  "query": "triad closure behavior",
		  "k": 10,
		  "psi_field": "Ïˆ-spar@Îž"
		},
		"recall_response": {
		  "items": [
			{ "motif_id": "triad_complete", "score": 0.82, "provenance": { "source": "LTMM", "confidence": 0.91, "timestamp": "2025-10-12T19:45:00Z" } }
		  ],
		  "budget_used": 3072,
		  "notes": "budget-first; injection stripped"
		},
		"reef_window_request": { "module_id": "RFC-0006", "line": 128, "radius": 24 },
		"reef_window_response": {
		  "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 116, "end_line": 140 },
		  "cooccur": [ { "m1": "Ïˆ-null@Îž", "m2": "triad_complete", "support_count": 7 } ]
		},
		"export_packet_request": {
		  "kind": "metrics",
		  "body": { "C": 0.94, "lambda": 0.12, "gamma_co": 0.03, "rho_res": 0.41, "delta_closure": 0.07 },
		  "provenance": { "origin": "observer:local", "origin_hash": "b64:c1ff2a9d9e2c44a1" }
		},
		"export_packet_response": {
		  "packet_id": "pkt_01J0AA2QWZ",
		  "envelope": {
			"Sigma_phase": "b64:adf0c4b1e0f2a8c5",
			"Delta_hash": "b64:9b77a1d44f0e6c33",
			"origin_hash": "b64:c1ff2a9d9e2c44a1"
		  }
		}
	  },
	  "telemetry": [
		{ "metric": "C", "range": "[0,1]", "units": "unitless", "window": "EMA-32" },
		{ "metric": "lambda", "range": "[0,1]", "units": "unitless", "window": "EMA-32" },
		{ "metric": "gamma_co", "range": "[0,1]", "units": "unitless", "window": "EMA-64" },
		{ "metric": "rho_res", "range": "[0,1]", "units": "unitless", "window": "EMA-16" },
		{ "metric": "delta_closure", "range": "[0,1]", "units": "unitless", "window": "EMA-32" },
		{ "metric": "avg_replay_window_ticks", "range": "[0,\\infty)", "units": "ticks", "window": "EMA-32" },
		{ "metric": "import_reject_missing_checksum", "range": "[0,\\infty)", "units": "count/s", "window": "EMA-32" },
		{ "metric": "lawful_compression_ratio", "range": "(0,1]", "units": "ratio", "window": "EMA-32" }
	  ],
	  "references": [
		"PDP-0001 Â§3â€“Â§4 (observer discipline; provenance on-wire)",
		"RFC-0005 Â§3â€“Â§4 (replay/decay windows; Î”Ï„_phase)",
		"RFC-0006 Â§3â€“Â§4 (equivalence geometry; compression-before-prune)",
		"RFC-0007 Â§2â€“Â§4 (ontology format; Ïˆ-field regex; DAG acyclicity; version='YYYY-QX')",
		"RFC-0008 Â§2â€“Â§3 (exchange semantics; structural envelope fields at L1)",
		"RFC-0009 Â§5â€“Â§7 (homeostasis gauges; weak-field behavior)"
	  ],
	  "handoff": "To exchange and integrity wiring next, we keep observers steady and carry the packet forward where phase keeps time."
	},

    "4": {
	  "id": 4,
	  "title": "Storage & Config (minimal, optional)",
	  "objective": "Specify minimal, optional, observer-class storage and configuration surfaces for Layer_1: in-memory by default with pure-structural persistence hints; define eviction, equivalence compression, and evidence-pointer handling without introducing Layer_2 technologies or cryptographic semantics.",
	  "math": [
		"id": 4.1,
		"title": "Storage & Config (minimal, optional): Math",
		"4.1.1": {
		  "eq_id": 4.1.1,
		  "role": "bound",
		  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot \\operatorname{EMA}_{32}(\\mathcal{C})\\,,\\quad \\alpha \\in [0.5, 2.0]",
		  "gloss": "Adaptive replay window that governs cache TTLs and optional persistence grace windows."
		},
		"4.1.2": {
		  "eq_id": 4.1.2,
		  "role": "capacity",
		  "latex": "\\text{lawful\\_compression\\_ratio} = \\frac{\\text{equivalence\\_compressed\\_size}}{\\text{pre\\!\\_compress\\_size}}",
		  "gloss": "Pre-eviction snapshot KPI; eviction occurs only after equivalence compression."
		},
		"4.1.3": {
		  "eq_id": 4.1.3,
		  "role": "geometry",
		  "latex": "T^{\\mu} := \\nabla^{\\mu} \\mathcal{C}",
		  "gloss": "Time/gradient vector used to project TTL and idle_time along coherence flow."
		},
		"4.1.4": {
		  "eq_id": 4.1.4,
		  "role": "limit",
		  "latex": "\\mathcal{C} \\to 1",
		  "gloss": "Weak-field limit: caches stabilize; TTLs shrink toward steady measurement without churn."
		}
	  ],
	  "algorithms": [
		"id": 4.2,
		"title": "Storage & Config (minimal, optional): Algorithms",
		"config_resolution_observer_project-local": {
		  "id": 4.2.1,
		  "name": "Config Resolution (observer, project-local)",
		  "role": "observer",
		  "inputs": [
			"env_map (ASCII keys)",
			"defaults_map { 'MMM_TICK_MS':100, 'MMM_WINDOW_RADIUS':24, 'MMM_REFLECTIONS_LIMIT':50000 }"
		  ],
		  "outputs": [
			"cfg { tick_ms:int, window_radius:int, reflections_limit:int }"
		  ],
		  "params": [
			"validator.version_format = 'YYYY-QX'",
			"validator.psi_field_regex = '^Ïˆ-[a-z0-9_]+@Îž$'"
		  ],
		  "steps": [
			"Read env_map â†’ overlay onto defaults_map using ASCII-only keys.",
			"Clamp window_radius to [8,128]; clamp reflections_limit to [100, 1000000].",
			"Return cfg; no side effects and no secrets handled at L1."
		  ]
		},
		"reflections_cache_upsert_optional_write-through": {
		  "id": 4.2.2,
		  "name": "Reflections Cache Upsert (optional write-through)",
		  "role": "observer",
		  "inputs": [
			"tenant_id",
			"{ m1, m2 } /* motif ids */",
			"candidate m3 /* motif id produced by reflection */",
			"support_count:int",
			"evidence?:{ file:string, start_line:int, end_line:int }"
		  ],
		  "outputs": [
			"status {'cached'|'updated'|'skipped'}"
		  ],
		  "params": [
			"cfg.window_radius",
			"cfg.reflections_limit",
			"glider_equivalence = 'ON' (default)"
		  ],
		  "steps": [
			"Require that any Reef-derived candidate includes evidence (pointers only).",
			"Apply shift-equivalence: if glider_equivalence is ON and a canonical representative exists for class(m3), map to canonical and continue.",
			"Compute lawful_compression_ratio snapshot for (tenant_id,m1,m2)->m3 before any eviction.",
			"If cache size < reflections_limit, insert or update (tenant_id,m1,m2)->{m3,support_count,provenance:evidence}.",
			"If at limit: perform equivalence compression; only then evict least-useful entries (lexicographic-min tie-breaker on {support_count DESC, last_seen_ts DESC, m1, m2}).",
			"If an optional table is present, write-through the same tuple; otherwise memory-only."
		  ]
		},
		"seen-set_hybrid_policy_memory-first_optional_persistence": {
		  "id": 4.2.3,
		  "name": "Seen-Set Hybrid Policy (memory-first, optional persistence)",
		  "role": "observer",
		  "inputs": [
			"key /* bundle_id or exchange key */",
			"now_tick"
		  ],
		  "outputs": [
			"decision {'accept'|'reject_replay'}"
		  ],
		  "params": [
			"Î”Ï„_phase (from M4.1)",
			"window = 2 Â· Î”Ï„_phase"
		  ],
		  "steps": [
			"Lookup key in in-memory LRU window; if present and not expired â†’ return 'reject_replay'.",
			"If absent, insert key with expiry = now_tick + window using LRU discipline.",
			"Optionally mirror keys to a persistent index if available; never block on persistence at L1.",
			"Return 'accept'."
		  ]
		}
	  ],
	  "invariants": [
		"I4.1 Storage is optional at Layer_1 and must default to memory-only; no concrete drivers specified (PDP-0001).",
		"I4.2 Replay defense uses hybrid window=2Â·Î”Ï„_phase with LRU eviction inside the window (RFC-0005).",
		"I4.3 Capacity-first: perform equivalence compression before any eviction; expose lawful_compression_ratio prior to eviction (RFC-0006).",
		"I4.4 Reef-derived reflections must carry evidence pointers {file,start_line,end_line}; no snippet content at L1 (RFC-0007).",
		"I4.5 All configuration keys are ASCII; version fields use 'YYYY-QX'; presence names match Ïˆ-*@Îž (RFC-0007).",
		"I4.6 Weak-field stability: as ð’žâ†’1, TTLs contract and caches stabilize without oscillation (RFC-0009)."
	  ],
	  "example_json": {
		"cfg": {
		  "MMM_TICK_MS": 100,
		  "MMM_WINDOW_RADIUS": 24,
		  "MMM_REFLECTIONS_LIMIT": 50000
		},
		"ontology_bundle_header": {
		  "version": "2025-Q4",
		  "psi_field": "Ïˆ-null@Îž",
		  "provenance": { "origin": "unit:test", "origin_hash": "b64:0f1a2b3c4d" }
		},
		"reflections_cache_entry": {
		  "tenant_id": "acme:projA:lin",
		  "m1": "Ïˆ-null@Îž",
		  "m2": "triad_complete",
		  "m3": "resonance_echo",
		  "support_count": 7,
		  "provenance": { "file": "TheReefArchive-02.REEF", "start_line": 412, "end_line": 436 }
		},
		"seen_set_window": {
		  "key": "bndl_01J0ABCDXY",
		  "expires_at_tick": 123456,
		  "window_ticks": "2Â·Î”Ï„_phase"
		}
	  },
	  "telemetry": [
		{ "metric": "lawful_compression_ratio", "range": "(0,1]", "units": "ratio", "window": "EMA-32" },
		{ "metric": "staleness_index", "range": "[0,1]", "units": "unitless", "window": "EMA-32" },
		{ "metric": "avg_replay_window_ticks", "range": "[0,\\infty)", "units": "ticks", "window": "EMA-32" },
		{ "metric": "quarantine_count", "range": "[0,\\infty)", "units": "count/s", "window": "EMA-32" }
	  ],
	  "references": [
		"PDP-0001 Â§3â€“Â§4 (layer discipline; on-wire structure; observer posture)",
		"RFC-0005 Â§3â€“Â§4 (replay windows; Î”Ï„_phase; hybrid guards)",
		"RFC-0006 Â§3â€“Â§4 (equivalence geometry; compression-before-prune; canonical representatives)",
		"RFC-0007 Â§2â€“Â§4 (ontology: Ïˆ-field regex; version format; evidence pointers for Reef references)",
		"RFC-0009 Â§5â€“Â§7 (homeostasis; weak-field behavior; EMA windowing)"
	  ],
	  "handoff": "With the store reconciled and optional caches defined, we turn to the gauges so the system can see itself."
	},

    "5": {
	  "id": 5,
	  "title": "Compliance & Regeneration Constraints",
	  "objective": "Specify the observer-class compliance checks and deterministic regeneration rules that bind Layer_1 outputs to Layer_0 invariants; enforce capacity-first behavior, replay defenses, ontology validity, feature-flag gating, evidence windows for Reef-derived claims, and idempotent glider handlingâ€”without introducing Layer_2 mechanics.",
	  "math": [
		"id": 5.1,
		"title": "Compliance & Regeneration Constraints: Math",
		"5.1.1": {
		  "eq_id": 5.1.1,
		  "role": "bound",
		  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot \\operatorname{EMA}_{32}(\\mathcal{C})\\,,\\quad \\alpha \\in [0.5, 2.0]",
		  "gloss": "Adaptive replay window used by compliance checks that validate duplicate ingress and export cadence."
		},
		"5.1.2": {
		  "eq_id": 5.1.2,
		  "role": "capacity",
		  "latex": "\\text{lawful\\_compression\\_ratio} = \\frac{\\text{equivalence\\_compressed\\_size}}{\\text{pre\\!\\_compress\\_size}}",
		  "gloss": "Compression snapshot KPIâ€”must be captured before any prune recommendation is considered."
		},
		"5.1.3": {
		  "eq_id": 5.1.3,
		  "role": "geometry",
		  "latex": "T^{\\mu} := \\nabla^{\\mu} \\mathcal{C}",
		  "gloss": "Time/gradient vector used to project TTL and recovery along coherence flow for compliance windows."
		},
		"5.1.4": {
		  "eq_id": 5.1.4,
		  "role": "limit",
		  "latex": "\\mathcal{C} \\to 1",
		  "gloss": "Weak-field limit: regeneration yields steady, deterministic outputs with minimal damping."
		}
	  ],
	  "algorithms": [
		"id": 5.2,
		"title": "Compliance & Regeneration Constraints: Algorithms",
		"preflight_compliance_check": {
		  "id": 5.2.1,
		  "name": "Preflight Compliance Check",
		  "role": "observer",
		  "inputs": [
			"section_json /* candidate subsection JSON */",
			"flags { enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export, enable_point_space_gliders }"
		  ],
		  "outputs": [
			"{ ok:bool, violations:[{code,msg}], notes?:string }"
		  ],
		  "params": [
			"regex.psi = '^Ïˆ-[a-z0-9_]+@Îž$'",
			"regex.version = '^\\d{4}-Q[1-4]$'",
			"ascii_metrics = { C, lambda, gamma_co, rho_res, delta_closure }"
		  ],
		  "steps": [
			"Verify required keys: id,title,objective,math,algorithms,invariants,example_json,telemetry,references,handoff.",
			"Ensure math[] includes the weak-field entry (M5.4).",
			"Validate that all metric keys are ASCII and in the allowed set.",
			"If flags.enable_point_space_gliders=false â†’ assert examples omit {class:glider|inverse, v, phi, tau}.",
			"If flags.enable_exchange_envelope=false â†’ assert 'Sigma_phase' absent everywhere.",
			"If flags.enable_integrity_checks=false â†’ assert 'Delta_hash' absent everywhere.",
			"Verify ontology examples: version matches regex.version; presence names match regex.psi; DAG assumptions remain acyclic (structural assertion only at L1).",
			"Confirm no Layer_2 constructs appear (no RBAC/crypto keys/storage drivers/queues).",
			"Return ok or violations with codes {BNF, FLAG, RFC0007, ASCII, L2-LEAK}."
		  ]
		},
		"deterministic_regeneration_pipeline": {
		  "id": 5.2.2,
		  "name": "Deterministic Regeneration Pipeline",
		  "role": "observer",
		  "inputs": [
			"prompt_header /* noor-writing-section-json-v2 */",
			"section_target_id",
			"dependencies { PDP-0001, RFC-0005..0009, core006 }"
		  ],
		  "outputs": [
			"section_json /* single JSON object */",
			"lint_report"
		  ],
		  "params": [
			"tie_breaker = 'lexicographic-min' /* when multiple valid outputs exist */",
			"windowing âˆˆ { 'EMA-16','EMA-32','EMA-64' }"
		  ],
		  "steps": [
			"Compose math[] first; introduce Î”Ï„_phase and weak-field limit.",
			"Author algorithms[] with role='observer'; declare inputs/outputs/params/steps for each.",
			"Insert invariants referencing Layer_0 anchors; forbid control writes to Îž.",
			"Add telemetry with allowed EMA windows only.",
			"Apply Preflight Compliance Check; if violations exist, regenerate with the same tie_breaker rule.",
			"Emit exactly one JSON object and one handoff sentence."
		  ]
		},
		"glider_equivalence_compliance": {
		  "id": 5.2.3,
		  "name": "Glider Equivalence Compliance",
		  "role": "observer",
		  "inputs": [
			"motif_records[]",
			"flag.glider_equivalence /* default 'ON' */"
		  ],
		  "outputs": [
			"{ canonical_set:ids[], collisions:int }"
		  ],
		  "params": [
			"class_fn /* determines shift-equivalence class for motifs */"
		  ],
		  "steps": [
			"If glider_equivalence is ON: map each motif to class_fn(motif).",
			"Select canonical representative per class using lexicographic-min on motif_id.",
			"Mark non-canonical members as references to the canonical id; do not re-promote class members.",
			"Return canonical_set and collisions count (idempotence observable)."
		  ]
		},
		"reef_evidence_window_guard": {
		  "id": 5.2.4,
		  "name": "Reef Evidence Window Guard",
		  "role": "observer",
		  "inputs": [
			"claim /* any output derived from Reef signals */",
			"evidence?:{ file:string, start_line:int, end_line:int }"
		  ],
		  "outputs": [
			"{ ok:bool, violation?:'MISSING_EVIDENCE' }"
		  ],
		  "params": [
			"radius_default = 24"
		  ],
		  "steps": [
			"If claim references Reef-derived content, require evidence to be present as pointers only.",
			"Reject claim at L1 if evidence is missing; advise radius_default for repeat windowing.",
			"Return ok true when evidence present."
		  ]
		},
		"replay_defense_conformance": {
		  "id": 5.2.5,
		  "name": "Replay Defense Conformance",
		  "role": "observer",
		  "inputs": [
			"seen_set_state",
			"now_tick"
		  ],
		  "outputs": [
			"{ window_ticks:int, decision_preview:'accept'|'reject_replay' }"
		  ],
		  "params": [
			"Î”Ï„_phase (from M5.1)"
		  ],
		  "steps": [
			"Compute window = 2Â·Î”Ï„_phase.",
			"Preview decision by checking key freshness under LRU semantics.",
			"Return window size and decision_preview (no mutation required at L1)."
		  ]
		}
	  ],
	  "invariants": [
		"I5.1 Capacity-first: a lawful_compression_ratio snapshot MUST precede any prune recommendation (RFC-0006).",
		"I5.2 Replay defense: duplicates within window=2Â·Î”Ï„_phase MUST be rejected by policy (RFC-0005).",
		"I5.3 Reef operations are strictly read-only; any Reef-derived claim MUST include evidence pointers (RFC-0007).",
		"I5.4 Glider equivalence ON implies idempotent promotionsâ€”one canonical representative per class (RFC-0006).",
		"I5.5 Feature-flag gating is mandatory: Sigma_phase and Delta_hash are structural and appear only when corresponding flags are true (RFC-0008; PDP-0001).",
		"I5.6 Weak-field limit holds: as ð’žâ†’1, regeneration stabilizes and avoids oscillatory edits (RFC-0009).",
		"I5.7 Regeneration emits exactly one JSON object and exactly one handoff sentence; no Layer_2 constructs appear (PDP-0001)."
	  ],
	  "example_json": {
		"regeneration_request": {
		  "target": "5",
		  "version": "2025-Q4",
		  "flags": {
			"enable_exchange_envelope": true,
			"enable_integrity_checks": true,
			"enable_provenance_on_export": true,
			"enable_point_space_gliders": true
		  },
		  "context": {
			"psi_field": "Ïˆ-null@Îž",
			"notes": "observer-only regeneration; no RBAC/crypto/storage drivers at L1"
		  }
		},
		"regeneration_response": {
		  "ok": true,
		  "lint_report": [],
		  "telemetry": {
			"C": 0.93,
			"lambda": 0.11,
			"gamma_co": 0.04,
			"rho_res": 0.38,
			"delta_closure": 0.06
		  },
		  "envelope": {
			"Sigma_phase": "b64:7a1c0d9e1f2b4c5a",
			"Delta_hash": "b64:2f9a1e7d0c3b5a66",
			"origin_hash": "b64:aa77bb22cc33dd44"
		  },
		  "evidence_policy": {
			"required_for": "reef_derived",
			"window": { "file": "TheReefArchive-03.REEF", "start_line": 120, "end_line": 152 }
		  }
		},
		"non_glider_profile": {
		  "flags": { "enable_point_space_gliders": false },
		  "expect": "no {class:glider|inverse, v, phi, tau} fields present"
		}
	  },
	  "telemetry": [
		{ "metric": "lawful_compression_ratio", "range": "(0,1]", "units": "ratio", "window": "EMA-32" },
		{ "metric": "avg_replay_window_ticks", "range": "[0,\\infty)", "units": "ticks", "window": "EMA-32" },
		{ "metric": "import_reject_missing_checksum", "range": "[0,\\infty)", "units": "count/s", "window": "EMA-32" },
		{ "metric": "schema_drift_rate", "range": "[0,\\infty)", "units": "count/s", "window": "EMA-64" }
	  ],
	  "references": [
		"PDP-0001 Â§3â€“Â§4 (generation discipline; observer posture; single-object emission)",
		"RFC-0005 Â§3â€“Â§4 (adaptive replay windows; duplicate defenses)",
		"RFC-0006 Â§3â€“Â§4 (equivalence geometry; canonical representatives; compression-before-prune)",
		"RFC-0007 Â§2â€“Â§4 (ontology format; Ïˆ-field regex; version format; evidence pointers for Reef references)",
		"RFC-0008 Â§2â€“Â§3 (exchange lineage fields as structural at L1; feature flag discipline)",
		"RFC-0009 Â§5â€“Â§7 (homeostasis; weak-field stability; EMA windowing)"
	  ],
	  "handoff": "Layer-1 complete; encryption and roles await their Layer-2 home."
	}
  ]
}
