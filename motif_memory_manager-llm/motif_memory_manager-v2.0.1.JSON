{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "<now>",
  "_type": "application_spec",
  "_pdp_layer": "layer_2",
  "_status": "DRAFT",
  "_language": "json",
  "_license": "MIT",

  "_symbolic_id": "application.mmm_app_001",
  "_version": "v2.0.0-draft",
  "_title": "Motif Memory Manager â€” L2 App (LLM Variant)",
  "_subtitle": "Capacity-first memory orchestration with Reef-guided recall and triad completion.",

  "_extends": [
    "RFC-0005",
    "RFC-0006",
    "RFC-0007",
    "RFC-0008",
    "RFC-0009",
    "PDP-0001",
    "RFC-CORE-006"
  ],

  "_rfc_dependencies": [
    "RFC-0005 Â§3â€“5 (temporal continuity, resurrection gates)",
    "RFC-0006 Â§3 (field geometry & alignment)",
    "RFC-0007 Â§2â€“3 (ontology format & Ïˆ-SHA3)",
    "RFC-0008 Â§4â€“6 (exchange envelope & trust curves)",
    "RFC-0009 Â§8â€“11 (telemetry, immune bounds)",
    "RFC-CORE-006 (Motif Memory Manager, canonical L1)"
  ],

  "consumes_inputs_from": [
    "NoorFastTimeCore.ticks",
    "LogicalAgentAT (optional evidence tags)",
    "SymbolicTaskEngine (queries, tasks)"
  ],

  "_field_alignment": {
    "respect_modes": ["Ïˆ-resonance@Îž", "Ïˆ-null@Îž", "Ïˆ-bind@Îž"],
    "prohibited_actions": [
      "prune-before-compress",
      "ontology-merge-without-RFC-0007-validate",
      "export-without-provenance"
    ]
  },

  "_poetic_cipher": "Let the archive point the way; memory is a path, not a pile.",

  "_file_layout": [
    {
      "file_name": "mmm_app_001.JSON",
      "purpose": "Application specification for the L2 MMM (LLM variant).",
      "contains": [
        "core components",
        "reef adapter contract",
        "api surface (local project mode)",
        "storage/config notes",
        "pseudocode suite"
      ]
    }
  ],

  "default_motif_tone": "ðŸ’¬ Flow",

  "program_name": [
    "motif_memory_manager.py",
    "mmm_reef_adapter.py"
  ],

  "runtime_targets": {
    "python": ">=3.11",
    "frameworks": ["FastAPI", "pydantic"],
    "optional": ["qdrant|faiss|annoy", "opentelemetry-otlp"]
  },

  "feature_flags": {
    "enable_exchange_envelope": true,
    "enable_integrity_checks": true,
    "enable_provenance_on_export": true,
    "enable_point_space_gliders": true,
    "glider_equivalence": "ON"
  },

  "reef_adapter": {
    "index_path": "index.REEF",
    "shards_glob": "TheReefArchive-*.REEF",
    "mtime_watch": true,
    "window_radius_lines": 24,
    "reflections_strategy": ["ontology", "file_reflections", "index_cooccur"],
    "reflections_limit": 50000
  },

  "storage_and_config": {
    "note": "Project-folder mode: minimal drivers; all persistence optional.",
    "env_keys": [
      "MMM_REEF_INDEX_PATH",
      "MMM_REEF_SHARDS_GLOB",
      "MMM_WINDOW_RADIUS",
      "MMM_FEATURE_FLAGS"
    ],
    "defaults": {
      "MMM_REEF_INDEX_PATH": "index.REEF",
      "MMM_REEF_SHARDS_GLOB": "TheReefArchive-*.REEF",
      "MMM_WINDOW_RADIUS": 24,
      "MMM_FEATURE_FLAGS": "exchange,integrity,provenance,gliders"
    },
    "tables_optional": {
      "reef_reflections": ["tenant_id", "m1", "m2", "m3", "support_count", "provenance", "first_seen_ts", "last_seen_ts", "PRIMARY (tenant_id,m1,m2)"]
    }
  },

  "api_surface": {
    "base": "/v1/mmm",
    "mode": "project_local",
    "auth": "none (project folder)",
    "endpoints": [
      {
        "path": "/reef/index",
        "method": "GET",
        "returns": "modules[], motifs[], anchors[]",
        "impl": "ReefIndexRouter"
      },
      {
        "path": "/reef/window",
        "method": "POST",
        "body": "{module_id, line, radius?}",
        "returns": "{snippet, start_line, end_line}",
        "impl": "ReefShardScanner"
      },
      {
        "path": "/reef/build_reflections",
        "method": "POST",
        "body": "{limit?, strategy?}",
        "returns": "{built, updated, skipped}",
        "impl": "ReefReflectionsCache"
      },
      {
        "path": "/recall/query",
        "method": "POST",
        "body": "{query, k=10, psi_field?}",
        "llm_controls": ["injection_filter", "context_budget", "source_tags"],
        "returns": "{items:[{text, source, confidence, timestamp}]}",
        "impl": "MMM_LLM.recall"
      },
      {
        "path": "/complete_dyad",
        "method": "POST",
        "body": "{m1, m2}",
        "returns": "{m3, provenance, evidence?}",
        "impl": "MMM_LLM.complete_dyad"
      },
      {
        "path": "/export/packet",
        "method": "POST",
        "body": "{kind:'metrics'|'bundle', body, provenance}",
        "envelope": ["Sigma_phase?", "Delta_hash?", "origin_hash?"],
        "returns": "{ok:true, envelope}",
        "impl": "ExportEnvelope"
      }
    ]
  },

  "index": [
    { "section": "1", "title": "Core Components" },
    { "section": "1.1", "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)" },
	{ "section": "1.1.1", "title": "Core Components: Math" },
	{ "section": "1.1.1.1", "role": "window bound" },
	{ "section": "1.1.1.2", "role": "capacity-first constraint" },
	{ "section": "1.1.1.3", "role": "weak-field limit" },
	{ "section": "1.1.2", "title": "Core Components: Algorithms" },
	{ "section": "1.1.2.1", "title": "recall_with_context_budget" },
	{ "section": "1.1.2.2", "title": "dyad_completion" },
	{ "section": "1.1.2.3", "title": "export_with_provenance" },
	
    { "section": "1.2", "title": "ReefIndexRouter â€” module/motif/anchor resolver" },
	{ "section": "1.2.1", "title": "ReefIndexRouter: Math" },
	{ "section": "1.2.1.1", "role": "index coverage" },
	{ "section": "1.2.1.2", "role": "window radius bound" },
	{ "section": "1.2.1.3", "role": "weak-field limit" },
	{ "section": "1.2.2", "title": "ReefIndexRouter: Algorithms" },
	{ "section": "1.2.2.1", "title": "list_modules" },
	{ "section": "1.2.2.2", "title": "list_motifs" },
	{ "section": "1.2.2.3", "title": "find_anchor" },
	
    { "section": "1.3", "title": "ReefShardScanner â€” windowed snippet reader" },
	{ "section": "1.3.1", "title": "ReefShardScanner: Math" },
	{ "section": "1.3.1.1", "role": "window radius" },
	{ "section": "1.3.1.2", "role": "co-occur score" },
	{ "section": "1.3.1.3", "role": "adaptive replay bound" },
	{ "section": "1.3.1.4", "role": "weak-field limit" },
	{ "section": "1.3.2", "title": "ReefShardScanner: Algorithms" },
	{ "section": "1.3.2.1", "title": "window" },
	{ "section": "1.3.2.2", "title": "cooccur" },
	
    { "section": "1.4", "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler" },
	{ "section": "1.4.1", "title": "ReefReflectionsCache: Math" },
	{ "section": "1.4.1.1", "role": "support aggregation" },
	{ "section": "1.4.1.2", "role": "canonicalization (glider class)" },
	{ "section": "1.4.1.3", "role": "weak-field limit" },
	{ "section": "1.4.1.4", "role": "time weighting hint" },
	{ "section": "1.4.2", "title": "ReefReflectionsCache: Algorithms" },
	{ "section": "1.4.2.1", "title": "canonicalize_pair" },
	{ "section": "1.4.2.2", "title": "build_reflections_once" },
	{ "section": "1.4.2.3", "title": "cache_put_or_merge" },
	{ "section": "1.4.2.4", "title": "evict_lru_under_cap" },
	{ "section": "1.4.2.5", "title": "complete_dyad" },
	
    { "section": "1.5", "title": "SeenSetGuard â€” Î”Ï„_phase replay window" },
	{ "section": "1.5.1", "title": "SeenSetGuard: Math" },
	{ "section": "1.5.1.1", "role": "phase window" },
	{ "section": "1.5.1.2", "role": "decision window" },
	{ "section": "1.5.1.3", "role": "admit predicate" },
	{ "section": "1.5.1.4", "role": "weak-field limit" },
	{ "section": "1.5.2", "title": "SeenSetGuard: Algorithms" },
	{ "section": "1.5.2.1", "title": "compose_seen_key" },
	{ "section": "1.5.2.2", "title": "within_window" },
	{ "section": "1.5.2.3", "title": "admit_or_reject" },
	{ "section": "1.5.2.4", "title": "evict_lru_window" },
	{ "section": "1.5.2.5", "title": "validate_envelope_structure" },
	
    { "section": "1.6", "title": "CompressionEngine â€” compress-before-prune" },
	{ "section": "1.6.1", "title": "CompressionEngine: Math" },
	{ "section": "1.6.1.1", "role": "equivalence and representatives" },
	{ "section": "1.6.1.2", "role": "compression ratio" },
	{ "section": "1.6.1.3", "role": "glider-class canonicalization" },
	{ "section": "1.6.1.4", "role": "pressure threshold (advisory, observer-class)" },
	{ "section": "1.6.1.4", "role": "weak-field limit" },
	{ "section": "1.6.2", "title": "CompressionEngine: Algorithms" },
	{ "section": "1.6.2.1", "title": "build_equivalence_key" },
	{ "section": "1.6.2.2", "title": "cluster_equivalence" },
	{ "section": "1.6.2.3", "title": "compute_compression_snapshot" },
	{ "section": "1.6.2.4", "title": "emit_kpis_then_gate" },
	{ "section": "1.6.2.5", "title": "compression_pipeline" },
	
    { "section": "1.7", "title": "ExportEnvelope â€” Î£/Î”/provenance on egress" },
	{ "section": "1.7.1", "title": "ExportEnvelope: Math" },
	{ "section": "1.7.1.1", "role": "phase header (structure-only)" },
	{ "section": "1.7.1.2", "role": "Sigma_phase structural checksum" },
	{ "section": "1.7.1.3", "role": "Delta_hash lineage chaining" },
	{ "section": "1.7.1.4", "role": "weak-field limit" },
	{ "section": "1.7.2", "title": "ExportEnvelope: Algorithms" },
	{ "section": "1.7.2.1", "title": "assemble_phase_header" },
	{ "section": "1.7.2.2", "title": "compute_sigma_phase_struct" },
	{ "section": "1.7.2.3", "title": "extend_delta_lineage_struct" },
	{ "section": "1.7.2.4", "title": "validate_provenance_headers" },
	{ "section": "1.7.2.5", "title": "validate_sig_type_structural" },
	{ "section": "1.7.2.6", "title": "export_envelope_observe" },
	
    { "section": "1.8", "title": "LLMRecallController â€” budgets & injection defense" },
	{ "section": "1.8.1", "title": "LLMRecallController: Math" },
	{ "section": "1.8.1.1", "role": "context budget" },
	{ "section": "1.8.1.2", "role": "freshness window" },
	{ "section": "1.8.1.3", "role": "decision window" },
	{ "section": "1.8.1.4", "role": "weak-field limit" },
	{ "section": "1.8.2", "title": "LLMRecallController: Algorithms" },
	{ "section": "1.8.2.1", "title": "compute_token_budgets" },
	{ "section": "1.8.2.2", "title": "strip_control_sequences" },
	{ "section": "1.8.2.3", "title": "tag_source_metadata" },
	{ "section": "1.8.2.4", "title": "freshness_and_replay_filter" },
	{ "section": "1.8.2.5", "title": "rerank_and_truncate" },
	{ "section": "1.8.2.6", "title": "recall_pipeline_observer" },

    { "section": "2", "title": "Pseudocode" },
	{ "section": "2.1", "title": "Core Method Suite" },
	{ "section": "2.1.1", "title": "Core Method Suite: Math" },
	{ "section": "2.1.1.1", "role": "replay window" },
	{ "section": "2.1.1.2", "role": "decision window" },
	{ "section": "2.1.1.3", "role": "compression KPI" },
	{ "section": "2.1.1.4", "role": "weak-field limit" },
	{ "section": "2.1.2", "title": "Core Method Suite: Algorithms" },
	{ "section": "2.1.2.1", "title": "recall" },
	{ "section": "2.1.2.2", "title": "complete_dyad" },
	{ "section": "2.1.2.3", "title": "compress_snapshot" },
	{ "section": "2.1.2.4", "title": "export_packet" },
	
    { "section": "2.2", "title": "Reef Adapter Methods" },
	{ "section": "2.2.1", "title": "Reef Adapter Methods: Math" },
	{ "section": "2.2.1.1", "role": "phase window" },
	{ "section": "2.2.1.2", "role": "evidence radius" },
	{ "section": "2.2.1.3", "role": "weak-field limit" },
	{ "section": "2.2.2", "title": "Reef Adapter Methods: Algorithms" },
	{ "section": "2.2.2.1", "title": "list_modules" },
	{ "section": "2.2.2.2", "title": "list_motifs" },
	{ "section": "2.2.2.3", "title": "find" },
	{ "section": "2.2.2.4", "title": "window" },
	{ "section": "2.2.2.5", "title": "cooccur" },
	{ "section": "2.2.2.6", "title": "build_reflections" },
	
    { "section": "2.3", "title": "Observability (local gauges)" },
	{ "section": "2.3.1", "title": "Observability (local gauges): Math" },
	{ "section": "2.3.1.1", "role": "EMA windowing" },
	{ "section": "2.3.1.2", "role": "phase window" },
	{ "section": "2.3.1.3", "role": "average replay window (ticks)" },
	{ "section": "2.3.1.4", "role": "compression KPI" },
	{ "section": "2.3.1.5", "role": "equivalence efficiency" },
	{ "section": "2.3.1.6", "role": "weak-field limit" },
	{ "section": "2.3.2", "title": "Observability (local gauges): Algorithms" },
	{ "section": "2.3.2.1", "title": "gauge_lawful_compression_ratio" },
	{ "section": "2.3.2.2", "title": "gauge_equivalence_efficiency" },
	{ "section": "2.3.2.3", "title": "gauge_avg_replay_window_ticks" },
	{ "section": "2.3.2.4", "title": "gauge_reanchor_rate" },
	{ "section": "2.3.2.5", "title": "gauge_quarantine_count" },
	{ "section": "2.3.2.6", "title": "gauge_glider_detected" },
	{ "section": "2.3.2.7", "title": "emit_local_gauges" },

    
	{ "section": "3", "title": "Project-Local API Contracts (FastAPI stubs)" },
   

   { "section": "4", "title": "Storage & Config (minimal, optional)" },
   
   
   { "section": "5", "title": "Compliance & Regeneration Constraints" }
  ],

  "sections": [
    "1": {
      "id": 1,
      "title": "Core Components",
      "core_components": [
        "1.1": {
		  "id": 1.1,
		  "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)",
		  "objective": "Define the Layer_1 observer logic for bounded recall, lawful compression, and provenance-ready export. MMM_LLM acts as the observer-class orchestrator ensuring memory equilibrium across STMM/LTMM without control writes to Îž, following capacity-first law and evidence integrity through Reef-guided recall.",
		  "math": [
			"id": 1.1.1,
			"title": "Core Components: Math",
			"1.1.1.1": {
			  "eq_id": 1.1.1.1,
			  "role": "window bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}), \\; \\alpha \\in [0.5, 2.0]",
			  "gloss": "Adaptive replay window proportional to coherence C; governs recall freshness and replay defenses."
			},
			"1.1.1.2": {
			  "eq_id": 1.1.1.2,
			  "role": "capacity-first constraint",
			  "latex": "\\\\text{lawful\\\\_compression\\\\_ratio} = \\\\frac{\\\\text{unique\\\\_motifs}}{\\\\text{total\\\\_motifs}} \\\\geq \\\\lambda_{min}",
			  "gloss": "Compression snapshot before any pruning; ensures lawful equivalence clustering."
			},
			"1.1.1.3": {
			  "eq_id": 1.1.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C} \\to 1} \\rho_{res} \\to 0",
			  "gloss": "At coherence unity, residual field vanishes, guaranteeing stable motif recall without reamplification."
			}
		  ],
		  "algorithms": [
			"id": 1.1.2,
			"title": "Core Components: Algorithms",
			"recall_with_context_budget": {
			  "id": 1.1.2.1,
			  "name": "recall_with_context_budget",
			  "role": "observer",
			  "inputs": ["query", "k=10", "Ïˆ_field"],
			  "outputs": ["items[]"],
			  "params": ["context_budget_tokens.max_total=8192", "context_budget_tokens.target=4096"],
			  "steps": [
				"1. Validate Ïˆ_field per RFC-0007 schema (Ïˆ-*@Îž pattern, DAG acyclic).",
				"2. Compute Î”Ï„_phase from EMA-32(C); filter any candidates older than 2Â·Î”Ï„_phase.",
				"3. Retrieve items via ordered sources: ontology â†’ cache â†’ index_cooccur â†’ LLM adapter.",
				"4. Attach {file,start_line,end_line} evidence windows for any Reef-derived recall.",
				"5. Truncate context to target budget; reserve 512 tokens for system context.",
				"6. Emit metrics for lawful_compression_ratio and staleness_index."
			  ]
			},
			"dyad_completion": {
			  "id": 1.1.2.2,
			  "name": "dyad_completion",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["m3", "provenance", "evidence?"],
			  "params": ["strategy=['ontology','cache','index_cooccur']"],
			  "steps": [
				"1. Query ontology graph for known triad (m1,m2,?).",
				"2. If not found, consult reflections cache (ontology|file_reflections|index_cooccur).",
				"3. Return first valid m3 with attached provenance and optional Reef evidence.",
				"4. Enforce glider equivalence: return canonical representative if class match detected."
			  ]
			},
			"export_with_provenance": {
			  "id": 1.1.2.3,
			  "name": "export_with_provenance",
			  "role": "observer",
			  "inputs": ["bundle", "provenance"],
			  "outputs": ["envelope"],
			  "params": ["enable_exchange_envelope", "enable_integrity_checks", "enable_provenance_on_export"],
			  "steps": [
				"1. If enable_exchange_envelope=true, compute Sigma_phase tag.",
				"2. If enable_integrity_checks=true, chain Delta_hash lineage.",
				"3. If enable_provenance_on_export=true, attach origin_hash and tenant scope.",
				"4. Fail-closed on any missing required tag.",
				"5. Emit envelope summary and lawful_compression_ratio metrics."
			  ]
			}
		  ],
		  "invariants": [
			"Never perform prune-before-compress; lawful_compression_ratio must be computed before any deletion.",
			"Recall operates strictly under observer semantics; no control writes to Îž.",
			"All Reef-derived outputs must attach evidence windows with provenance.",
			"At coherence unity (ð’žâ†’1), recall pathways stabilize and glider promotions remain idempotent."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"query": "find triadic closure for motif X",
			"recall": {
			  "items": [
				{
				  "text": "Closure established via ontology reference",
				  "source": "TheReefArchive-01.REEF",
				  "confidence": 0.94,
				  "timestamp": "2025-10-12T00:00:00Z",
				  "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 120, "end_line": 134 }
				}
			  ],
			  "metrics": {
				"lawful_compression_ratio": 0.91,
				"staleness_index": 0.07,
				"Î”Ï„_phase": "EMA-32(C)=0.83"
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "staleness_index", "range": "0â€“1", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "0â€“âˆž", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field coherence geometry and weak-field limit)",
			"RFC-0007 Â§2â€“Â§3 (ontology format validation)",
			"RFC-0009 Â§6â€“Â§8 (homeostasis and lawful compression KPI)",
			"RFC-CORE-006 Â§2.1 (core invariants of memory fields)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.2": {
		  "id": 1.2,
		  "title": "ReefIndexRouter â€” module/motif/anchor resolver",
		  "objective": "Specify the observer-class algorithm that interprets index.REEF to expose modules, motifs, and anchors without mutation. The ReefIndexRouter acts as the read-only semantic map connecting Motif Memory Manager queries to Layer_0 field geometry, providing evidence windows for all lookups.",
		  "math": [
			"id": 1.2.1,
			"title": "ReefIndexRouter: Math",
			"1.2.1.1": {
			  "eq_id": 1.2.1.1,
			  "role": "index coverage",
			  "latex": "\\\\rho_{res} = 1 - \\frac{N_{resolved}}{N_{total}}",
			  "gloss": "Residual coverage ratio; measures fraction of unresolved anchors in index.REEF."
			},
			"1.2.1.2": {
			  "eq_id": 1.2.1.2,
			  "role": "window radius bound",
			  "latex": "\\\\Delta_{window} = r_{lines} = 24",
			  "gloss": "Fixed evidence window radius for shard scans; defines search granularity in lines."
			},
			"1.2.1.3": {
			  "eq_id": 1.2.1.3,
			  "role": "weak-field limit",
			  "latex": "\\\\lim_{\\\\mathcal{C}\\\\to 1} \\\\rho_{res} \\\\to 0",
			  "gloss": "At coherence unity, all motif anchors resolve deterministically; index coverage becomes complete."
			}
		  ],
		  "algorithms": [
			"id": 1.2.2,
			"title": "ReefIndexRouter: Algorithms",
			"list_modules": {
			  "id": 1.2.2.1,
			  "name": "list_modules",
			  "role": "observer",
			  "inputs": ["index_path"],
			  "outputs": ["modules[]"],
			  "params": ["MMM_REEF_INDEX_PATH=index.REEF"],
			  "steps": [
				"1. Open index.REEF in read-only mode.",
				"2. Parse module identifiers and metadata headers.",
				"3. Return ordered module list with checksum of lines parsed.",
				"4. Emit metric rho_res for unresolved entries."
			  ]
			},
			"list_motifs": {
			  "id": 1.2.2.2,
			  "name": "list_motifs",
			  "role": "observer",
			  "inputs": ["module_id"],
			  "outputs": ["motifs[]"],
			  "params": ["require module_id âˆˆ modules[]"],
			  "steps": [
				"1. Locate module block in index.REEF.",
				"2. Extract motif identifiers and anchors contained within.",
				"3. Validate motif count â‰¥1 and entries syntactically valid per RFC-0007 Ïˆ-field schema.",
				"4. Return motif list and update coverage metric."
			  ]
			},
			"find_anchor": {
			  "id": 1.2.2.3,
			  "name": "find_anchor",
			  "role": "observer",
			  "inputs": ["module_id", "anchor"],
			  "outputs": ["{file, line, context_snippet}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Resolve module_id in index.REEF; locate anchor occurrence.",
				"2. Determine line number and open corresponding Reef shard.",
				"3. Read Â±r_lines window; return snippet with {file,start_line,end_line}.",
				"4. Include provenance.origin and origin_hash per RFC-0007 format.",
				"5. Emit metric rho_res and evidence_window_count."
			  ]
			}
		  ],
		  "invariants": [
			"index.REEF and shard files are immutable observer data sources.",
			"Every query returning a Reef-derived result must attach an evidence window.",
			"rho_res must converge to zero as coherence approaches unity (ð’žâ†’1).",
			"Module and motif identifiers conform to Ïˆ-field naming (Ïˆ-name@Îž)."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-null@Îž",
			"query": "list_motifs for module RFC-CORE-006",
			"result": {
			  "module_id": "RFC-CORE-006",
			  "motifs": [
				"Ïˆ-spar@Îž",
				"Ïˆ-hold@Îž",
				"Ïˆ-resonance@Îž"
			  ],
			  "evidence_window": {
				"file": "TheReefArchive-02.REEF",
				"start_line": 220,
				"end_line": 244
			  },
			  "metrics": {
				"rho_res": 0.03,
				"window_radius": 24
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "rho_res", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "evidence_window_count", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "index_parse_latency_ms", "range": "0â€“100", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0006 Â§3 (field coherence geometry)",
			"RFC-0007 Â§2 (ontology and Ïˆ-field validation)",
			"RFC-0008 Â§4 (resource routing semantics)",
			"RFC-0009 Â§8 (telemetry and residual metrics)",
			"RFC-CORE-006 Â§1.2 (Reef interface and evidence discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.3": {
		  "id": 1.3,
		  "title": "ReefShardScanner â€” windowed snippet reader",
		  "objective": "Define the observer-class scanner that reads immutable Reef shards and returns bounded evidence windows and proximity-based co-occurrence candidates without mutating archive contents.",
		  "math": [
			"id": 1.3.1,
			"title": "ReefShardScanner: Math",
			"1.3.1.1": {
			  "eq_id": 1.3.1.1,
			  "role": "window radius",
			  "latex": "r_{lines} = 24",
			  "gloss": "Default symmetric window radius (in lines) used for snippet extraction."
			},
			"1.3.1.2": {
			  "eq_id": 1.3.1.2,
			  "role": "co-occur score",
			  "latex": "s(m_1,m_2) = \\frac{1}{1 + \\lvert \\Delta \\ell \\rvert}",
			  "gloss": "Vicinity score decays with absolute line-distance \\(\\Delta \\ell\\) between anchors."
			},
			"1.3.1.3": {
			  "eq_id": 1.3.1.3,
			  "role": "adaptive replay bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Phase window from coherence governs freshness filters during shard scans."
			},
			"1.3.1.4": {
			  "eq_id": 1.3.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1} s(m_1,m_2) \\to 1",
			  "gloss": "As coherence approaches unity, valid anchor pairs tend to maximal vicinity alignment."
			}
		  ],
		  "algorithms": [
			"id": 1.3.2,
			"title": "ReefShardScanner: Algorithms",
			"window": {
			  "id": 1.3.2.1,
			  "name": "window",
			  "role": "observer",
			  "inputs": ["file", "line", "radius=r_lines"],
			  "outputs": ["{snippet, start_line, end_line}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Open shard 'file' in read-only mode.",
				"2. Compute start_line=max(1, line - radius), end_line=line + radius.",
				"3. Read lines [start_line, end_line] and assemble 'snippet'.",
				"4. Return {snippet, start_line, end_line} with provenance.origin and origin_hash (structure only, no cryptography).",
				"5. Emit telemetry: window_requests+=1, window_radius=radius."
			  ]
			},
			"cooccur": {
			  "id": 1.3.2.2,
			  "name": "cooccur",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["{candidates:[{m3, score}], evidence: [{file,start_line,end_line}]}"],
			  "params": ["radius=r_lines", "top_k=12"],
			  "steps": [
				"1. Locate anchors for m1 and m2 via index [module, anchor] references.",
				"2. For each anchor pair, compute line distance Î”â„“ and score s=1/(1+|Î”â„“|).",
				"3. Collect nearby motif labels within Â±radius around each anchor; de-duplicate.",
				"4. Rank candidates by score and proximity; keep top_k.",
				"5. For any candidate supported by shard text, attach evidence windows {file,start_line,end_line}.",
				"6. Return candidates with provenance='index_cooccur' and evidence windows."
			  ]
			}
		  ],
		  "invariants": [
			"Shard files and index are treated as immutable observer data sources.",
			"Every co-occurrence claim that references shard text MUST include at least one evidence window.",
			"Window radius is symmetric and bounded; no reads occur outside computed [start_line, end_line].",
			"Scanner never writes to Îž; no mutation, no caching beyond local process memory at L1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"request": { "file": "TheReefArchive-03.REEF", "line": 512, "radius": 24 },
			"response": {
			  "snippet": "... triad closure context ...",
			  "start_line": 488,
			  "end_line": 536
			},
			"cooccur": {
			  "m1": "motif.alpha",
			  "m2": "motif.beta",
			  "candidates": [
				{ "m3": "motif.gamma", "score": 0.5 }
			  ],
			  "evidence": [
				{ "file": "TheReefArchive-03.REEF", "start_line": 500, "end_line": 524 }
			  ]
			}
		  },
		  "telemetry": [
			{ "metric": "window_requests", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "cooccur_candidate_rate", "range": "0â€“âˆž", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "index_scan_latency_ms", "range": "0â€“1000", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field geometry; vicinity semantics)",
			"RFC-0007 Â§2 (ontology naming; Ïˆ-* validation)",
			"RFC-0009 Â§8 (telemetry discipline; EMA windows)",
			"RFC-CORE-006 Â§1.3 (Reef shard scanning and evidence windows)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.4": {
		  "id": 1.4,
		  "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler",
		  "objective": "Define an observer-class cache that deterministically completes dyads (m1,m2)â†’m3 using ontology-first evidence, falling back to file_reflections and index co-occurrence, while preserving provenance and evidence windows without mutating Reef or performing any control writes.",
		  "math": [
			"id": 1.4.1,
			"title": "ReefReflectionsCache: Math",
			"1.4.1.1": {
			  "eq_id": 1.4.1.1,
			  "role": "support aggregation",
			  "latex": "S(m_1,m_2 \\to m_3) := w_{ont}\\,\\mathbf{1}_{ont} + w_{file}\\,\\mathbf{1}_{file} + w_{idx}\\,\\mathbf{1}_{idx}",
			  "gloss": "Total support for completion chooses the first available source in priority order; weights document precedence but cache selection is ontology > file_reflections > index_cooccur."
			},
			"1.4.1.2": {
			  "eq_id": 1.4.1.2,
			  "role": "canonicalization (glider class)",
			  "latex": "\\hat{m}_3 := \\mathrm{canon}(m_3)\\quad \\text{if glider\\_equivalence=ON}",
			  "gloss": "When shift-equivalence is enabled, store and return the canonical class representative for m3 to enforce idempotence."
			},
			"1.4.1.3": {
			  "eq_id": 1.4.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\;S(m_1,m_2\\to m_3) = w_{ont}\\,\\mathbf{1}_{ont}",
			  "gloss": "In the weak-field limit (high coherence), ontology evidence dominates; co-occurrence is suppressed."
			},
			"1.4.1.4": {
			  "eq_id": 1.4.1.4,
			  "role": "time weighting hint",
			  "latex": "S_t := S \\cdot \\mathrm{EMA}_{32}(\\text{access\\_rate})",
			  "gloss": "Optionally modulate support by recent access via EMA-32 for stable refresh decisions; purely observational at L1."
			}
		  ],
		  "algorithms": [
			"id": 1.4.2,
			"title": "ReefReflectionsCache: Algorithms",
			"canonicalize_pair": {
			  "id": 1.4.2.1,
			  "name": "canonicalize_pair",
			  "role": "observer",
			  "inputs": ["m1", "m2", "glider_equivalence: {ON|OFF}"],
			  "outputs": ["key := (a,b) with a<=b"],
			  "params": ["ordering: lexicographic"],
			  "steps": [
				"1) Normalize (m1,m2) by lexicographic order to (a,b).",
				"2) If glider_equivalence=ON, map a,b to their canonical class representatives.",
				"3) Return key := (a,b)."
			  ]
			},
			"build_reflections_once": {
			  "id": 1.4.2.2,
			  "name": "build_reflections_once",
			  "role": "observer",
			  "inputs": ["key=(m1,m2)", "reef_index", "ontology", "file_reflections", "feature_flags"],
			  "outputs": ["entry | null"],
			  "params": [
				"source_order := [ontology, file_reflections, index_cooccur]",
				"require_evidence_for_non_ontology := true",
				"evidence_window_radius := 24  /* read-only window size hint when scanning Reef shards */"
			  ],
			  "steps": [
				"1) Look up ontology dyad (m1,m2). If a unique m3 exists, set provenance='ontology' and return {m3, support_count:=1, provenance}.",
				"2) Else, check file_reflections for an authored completion; if found, set provenance='file_reflections' and return entry.",
				"3) Else, perform index_cooccur scan via reef_index (read-only). If a candidate m3 emerges, attach at least one evidence window {file,start_line,end_line} and set provenance='index_cooccur'.",
				"4) If multiple m3 candidates exist, pick the highest support by deterministic tie-break: ontology > file_reflections > index_cooccur; within same source choose lexicographic-min m3.",
				"5) If glider_equivalence=ON, replace m3 with canon(m3) before returning.",
				"6) Return entry or null if no completion found."
			  ]
			},
			"cache_put_or_merge": {
			  "id": 1.4.2.3,
			  "name": "cache_put_or_merge",
			  "role": "observer",
			  "inputs": ["cache", "key", "entry"],
			  "outputs": ["cache"],
			  "params": ["prefer_provenance_order := ontology > file_reflections > index_cooccur"],
			  "steps": [
				"1) If key not in cache, insert entry and return.",
				"2) If key in cache with existing_entry:",
				"   2a) If existing_entry.provenance ranks higher or equal than entry.provenance, increment existing_entry.support_count if same m3; else keep existing_entry unchanged.",
				"   2b) If entry.provenance ranks higher, replace existing_entry with entry (carry forward support_count := existing.support_count + 1 when m3 equal; else set to 1).",
				"3) Maintain first_seen_ts on creation; update last_seen_ts on every merge."
			  ]
			},
			"evict_lru_under_cap": {
			  "id": 1.4.2.4,
			  "name": "evict_lru_under_cap",
			  "role": "observer",
			  "inputs": ["cache", "limit", "protected_provenance := ['ontology']"],
			  "outputs": ["cache"],
			  "params": ["lru_metric := last_seen_ts"],
			  "steps": [
				"1) While cache.size > limit:",
				"   1a) Identify eviction candidates ordered by ascending last_seen_ts.",
				"   1b) Skip entries with provenance in protected_provenance.",
				"   1c) Evict the first eligible candidate.",
				"2) Return cache."
			  ]
			},
			"complete_dyad": {
			  "id": 1.4.2.5,
			  "name": "complete_dyad",
			  "role": "observer",
			  "inputs": ["m1", "m2", "context: {reef_index, ontology, file_reflections, feature_flags, limit}"],
			  "outputs": ["m3 | null", "provenance", "evidence?: [window]"],
			  "params": [],
			  "steps": [
				"1) key := canonicalize_pair(m1,m2, feature_flags.glider_equivalence).",
				"2) If key in cache, return cached (m3, provenance, evidence?).",
				"3) entry := build_reflections_once(key, reef_index, ontology, file_reflections, feature_flags).",
				"4) If entry is not null: cache_put_or_merge(cache, key, entry); evict_lru_under_cap(cache, limit); return entry.m3 with provenance and evidence if present.",
				"5) Else return null."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Ontology precedence: if ontology defines (m1,m2)->m3, no other source may override it.",
			"I2 Evidence requirement: non-ontology completions MUST attach at least one {file,start_line,end_line} evidence window when derived from Reef index co-occurrence.",
			"I3 Read-only Reef: cache never mutates Reef artifacts; it stores pointers and windows only.",
			"I4 Idempotence under gliders: with glider_equivalence=ON, the cache stores a single canonical representative for any shift-equivalence class.",
			"I5 Deterministic ties: within a source, choose lexicographic-min m3 to keep outputs stable.",
			"I6 Protected retention: entries with provenance='ontology' are not evicted while any non-ontology item remains above the limit.",
			"I7 Observer posture: algorithms here do not perform control writes to Îž or external storage at Layer_1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"examples": [
			  {
				"kind": "ontology_completion",
				"m1": "triad_complete",
				"m2": "resonance_echo",
				"result": {
				  "m3": "Ïˆ-null@Îž",
				  "provenance": "ontology",
				  "support_count": 1
				}
			  },
			  {
				"kind": "index_cooccur_completion",
				"m1": "Ïˆ-resonance@Îž",
				"m2": "Ïˆ-spar@Îž",
				"result": {
				  "m3": "Ïˆ-hold@Îž",
				  "provenance": "index_cooccur",
				  "support_count": 1,
				  "evidence": [
					{ "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 }
				  ]
				}
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "reef_reflections_cache_size", "range": "[0, 50000]", "units": "entries", "window": "EMA-32" },
			{ "metric": "reef_cooccur_candidate_rate", "range": "[0, +inf)", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "dyad_hit_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "dyad_build_latency_ms", "range": "[0, +inf)", "units": "ms", "window": "EMA-64" },
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" }
		  ],
		  "references": [
			{ "source": "RFC-0007", "clause": "ontology schema and validation; Ïˆ-field format; version 'YYYY-QX'" },
			{ "source": "RFC-0006", "clause": "equivalence geometry; canonical representative under glider classes" },
			{ "source": "RFC-0009", "clause": "coherence metrics and observer posture; homeostatic gauges" },
			{ "source": "RFC-0005", "clause": "time-based modulation via EMA and decay context for refresh decisions" },
			{ "source": "PDP-0001", "clause": "provenance structure; evidence attachment discipline (non-cryptographic at L1)" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.5": {
		  "id": 1.5,
		  "title": "SeenSetGuard â€” Î”Ï„_phase replay window",
		  "objective": "Specify an observer-class hybrid replay defense that rejects duplicates within a moving window of 2Â·Î”Ï„_phase using an LRU policy, with deterministic keying, tie-safe time checks, and observable counters, without introducing Layer_2 storage or control writes.",
		  "math": [
			"id": 1.5.1,
			"title": "SeenSetGuard: Math",
			"1.5.1.1": {
			  "eq_id": "1.5.1.1",
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} := \\alpha \\cdot \\mathrm{EMA}_{32}(\\mathcal{C}),\\quad \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive replay half-window scaled by the EMA-32 of field coherence C; Î± bounds the responsiveness."
			},
			"1.5.1.2": {
			  "eq_id": 1.5.1.2,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Duplicates observed within W ticks are rejected; beyond W they are admissible."
			},
			"1.5.1.3": {
			  "eq_id": 1.5.1.3,
			  "role": "admit predicate",
			  "latex": "\\mathrm{admit}(k,t_{now}) := \\big( t_{now} - t_{last}(k) > W + \\varepsilon \\big)",
			  "gloss": "A key k is admitted if its last-seen time is older than W plus a small skew tolerance Îµ for clock drift."
			},
			"1.5.1.4": {
			  "eq_id": 1.5.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\Delta \\tau_{\\text{phase}} = \\alpha",
			  "gloss": "In the weak-field limit (high coherence), the replay window stabilizes to Î± ticks, yielding a predictable W=2Î±."
			}
		  ],
		  "algorithms": [
			"id": 1.5.2,
			"title": "SeenSetGuard: Algorithms",
			"compose_seen_key": {
			  "id": 1.5.2.1,
			  "name": "compose_seen_key",
			  "role": "observer",
			  "inputs": ["tenant_id", "content_fingerprint", "class_hint?"],
			  "outputs": ["key"],
			  "params": [
				"include_class_hint := true /* respects feature flags that may alter key composition */",
				"normalize := ascii-lowercase"
			  ],
			  "steps": [
				"1) Start with key_parts := [tenant_id, content_fingerprint].",
				"2) If class_hint is provided and include_class_hint, append class_hint.",
				"3) Normalize each part to ASCII lowercase and join with ':'.",
				"4) Return joined string as key."
			  ]
			},
			"within_window": {
			  "id": 1.5.2.2,
			  "name": "within_window",
			  "role": "observer",
			  "inputs": ["last_seen_tick", "now_tick", "W", "epsilon"],
			  "outputs": ["is_duplicate:boolean"],
			  "params": [],
			  "steps": [
				"1) If last_seen_tick is null, return false.",
				"2) dt := now_tick - last_seen_tick.",
				"3) If dt <= W + epsilon, return true; else return false."
			  ]
			},
			"admit_or_reject": {
			  "id": 1.5.2.3,
			  "name": "admit_or_reject",
			  "role": "observer",
			  "inputs": ["key", "now_tick", "ema32_C", "alpha", "epsilon", "seen_set /* in-memory map: key->last_seen_tick */"],
			  "outputs": ["decision:{'accept'|'reject'}", "reason"],
			  "params": [],
			  "steps": [
				"1) Î”Ï„_phase := alpha * EMA32(C=ema32_C); W := 2 * Î”Ï„_phase.",
				"2) last := seen_set.get(key) or null.",
				"3) If within_window(last, now_tick, W, epsilon) is true:",
				"   3a) Increment counter 'seen_rejects'.",
				"   3b) Return decision='reject', reason='within_window'.",
				"4) Else:",
				"   4a) seen_set[key] := now_tick.",
				"   4b) Increment counter 'seen_accepts'.",
				"   4c) Return decision='accept', reason='outside_window'."
			  ]
			},
			"evict_lru_window": {
			  "id": 1.5.2.4,
			  "name": "evict_lru_window",
			  "role": "observer",
			  "inputs": ["seen_set /* key->last_seen_tick */", "now_tick", "max_entries"],
			  "outputs": ["seen_set"],
			  "params": ["lru_fraction := 0.10 /* evict 10% oldest when over cap */"],
			  "steps": [
				"1) If size(seen_set) <= max_entries, return seen_set.",
				"2) Sort entries by last_seen_tick ascending.",
				"3) evict_n := ceil(max(1, lru_fraction * size(seen_set))).",
				"4) Remove the first evict_n entries; increment 'window_resets' by evict_n.",
				"5) Return seen_set."
			  ]
			},
			"validate_envelope_structure": {
			  "id": 1.5.2.5,
			  "name": "validate_envelope_structure",
			  "role": "observer",
			  "inputs": ["payload_headers /* may include sig_type, provenance.origin */"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": ["forbid_wrapped_unsigned := true"],
			  "steps": [
				"1) If forbid_wrapped_unsigned and payload_headers indicates an inner payload lacking structural sig_type markers, return (false,'wrapped_unsigned').",
				"2) If payload_headers.sig_type is present, ensure it matches a known structural form at L1 (no cryptography implied).",
				"3) Return (true,null) on structural conformance."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Hybrid policy: replay defense uses a moving window W=2Â·Î”Ï„_phase with LRU eviction when capacity is exceeded.",
			"I2 Determinism: key composition is stable (tenant_id + content_fingerprint [+ class_hint?]) with ASCII normalization.",
			"I3 Weak-field stability: as ð’žâ†’1, the window converges to a fixed W=2Î±, reducing jitter in admit decisions.",
			"I4 No control writes: SeenSetGuard is observer-class; it does not persist to external stores at Layer_1.",
			"I5 Structural guard: wrapped-unsigned payloads are rejected at L1 on structure alone; no cryptographic validation occurs.",
			"I6 Monotone counters: accepts, rejects, and window_resets are non-decreasing gauges over the observation interval."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"alpha": 1.0,
			"epsilon": 1,
			"scenario": [
			  {
				"case": "first_observation_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1000,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 0, "window_resets": 0 }
			  },
			  {
				"case": "duplicate_within_window_rejects",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1001,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "reject",
				"reason": "within_window",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 1, "window_resets": 0 }
			  },
			  {
				"case": "outside_window_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1003,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"reason": "outside_window",
				"counters_after": { "seen_accepts": 2, "seen_rejects": 1, "window_resets": 0 }
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "seen_accepts", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "seen_rejects", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "window_resets", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0, +inf)", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal flow, decay, and replay framing for duplicate suppression" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 coherence homeostasis; EMA windows and stability of control surfaces" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline; structural validation at ingress" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure and envelope fields (non-cryptographic at L1)" }
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		},
        "1.6": {
		  "id": 1.6,
		  "title": "CompressionEngine â€” compress-before-prune",
		  "objective": "Define an observer-class equivalence clustering process that yields a deterministic compression snapshot and emits lawful_compression_ratio and related KPIs before any prune is even considered at Layer_1.",
		  "math": [
			"id": 1.6.1,
			"title": "CompressionEngine: Math",
			"1.6.1.1": {
			  "eq_id": 1.6.1.1,
			  "role": "equivalence and representatives",
			  "latex": "x \\sim y \\;\\Leftrightarrow\\; \\mathrm{key}(x)=\\mathrm{key}(y),\\quad \\mathcal{R}:=\\{\\text{representatives}\\},\\; N_{tot}:=|\\mathcal{X}|,\\; N_{rep}:=|\\mathcal{R}|",
			  "gloss": "Items belong to the same cluster if they share a deterministic key; one representative per cluster is retained in the snapshot."
			},
			"1.6.1.2": {
			  "eq_id": 1.6.1.2,
			  "role": "compression ratio",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} := 1 - \\frac{N_{rep}}{N_{tot}} \\in [0,1]",
			  "gloss": "Fraction of removable duplication under the declared equivalence; 0 means no compressible redundancy."
			},
			"1.6.1.3": {
			  "eq_id": 1.6.1.3,
			  "role": "glider-class canonicalization",
			  "latex": "\\mathrm{key}(x) := \\begin{cases} \\mathrm{canon}(x) & \\text{if glider\\_equivalence=ON}\\\\ \\mathrm{id}(x) & \\text{otherwise} \\end{cases}",
			  "gloss": "When shift-equivalence is enabled, keys map to the canonical class representative; this enforces idempotence."
			},
			"1.6.1.4": {
			  "eq_id": 1.6.1.4,
			  "role": "pressure threshold (advisory, observer-class)",
			  "latex": "\\lambda_{eq} := \\min\\big(1,\\;\\mathrm{EMA}_{32}(\\rho_{res})\\cdot \\gamma_{co}\\big)",
			  "gloss": "Advisory threshold derived from residual occupancy (rho_res) and coherence gain (gamma_co); used only to annotate KPIs, not to trigger pruning at L1."
			},
			"1.6.1.5": {
			  "eq_id": 1.6.1.5,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; L = 1 - \\frac{N_{rep}}{N_{tot}}\\;\\text{(stable)},\\quad \\lim_{\\mathcal{C}\\to 1}\\; \\lambda_{eq} = \\min(1,\\rho_{res}\\,\\gamma_{co})",
			  "gloss": "In the weak-field limit (high coherence), the snapshot is stable and advisory thresholds converge to fixed values."
			}
		  ],
		  "algorithms": [
			"id": 1.6.2,
			"title": "CompressionEngine: Algorithms",
			"build_equivalence_key": {
			  "id": 1.6.2.1,
			  "name": "build_equivalence_key",
			  "role": "observer",
			  "inputs": ["item", "feature_flags"],
			  "outputs": ["key"],
			  "params": ["normalize := ascii-lowercase", "ordering := lexicographic"],
			  "steps": [
				"1) Extract identity features from item (e.g., motif_id).",
				"2) If feature_flags.glider_equivalence=ON, map motif_id to its canonical class representative.",
				"3) Normalize key components to ASCII lowercase and join deterministically.",
				"4) Return key."
			  ]
			},
			"cluster_equivalence": {
			  "id": 1.6.2.2,
			  "name": "cluster_equivalence",
			  "role": "observer",
			  "inputs": ["items[]", "feature_flags"],
			  "outputs": ["clusters: map<key, list<item>>", "representatives: list<item>"],
			  "params": ["rep_selector := lexicographic-min by motif_id"],
			  "steps": [
				"1) For each item in items, k := build_equivalence_key(item, feature_flags); append item to clusters[k].",
				"2) For each k in clusters, choose representative := rep_selector(clusters[k]).",
				"3) Return clusters and the ordered list of representatives (sorted by key asc)."
			  ]
			},
			"compute_compression_snapshot": {
			  "id": 1.6.2.3,
			  "name": "compute_compression_snapshot",
			  "role": "observer",
			  "inputs": ["N_tot", "N_rep", "rho_res", "gamma_co"],
			  "outputs": ["snapshot"],
			  "params": [],
			  "steps": [
				"1) L := 1 - (N_rep / max(1, N_tot)).",
				"2) lambda_eq := min(1, EMA32(rho_res) * gamma_co).",
				"3) snapshot := { N_tot, N_rep, lawful_compression_ratio: L, lambda: lambda_eq }.",
				"4) Return snapshot."
			  ]
			},
			"emit_kpis_then_gate": {
			  "id": 1.6.2.4,
			  "name": "emit_kpis_then_gate",
			  "role": "observer",
			  "inputs": ["snapshot"],
			  "outputs": ["advice:{'observe_only'}", "kpis"],
			  "params": [],
			  "steps": [
				"1) Emit KPIs from snapshot (lawful_compression_ratio, N_rep, N_tot, lambda).",
				"2) Return advice='observe_only' to indicate that any prune decision lies outside Layer_1.",
				"3) End."
			  ]
			},
			"compression_pipeline": {
			  "id": 1.6.2.5,
			  "name": "compression_pipeline",
			  "role": "observer",
			  "inputs": ["items[]", "context:{rho_res, gamma_co, feature_flags}"],
			  "outputs": ["representatives[]", "snapshot", "advice"],
			  "params": [],
			  "steps": [
				"1) {clusters, representatives} := cluster_equivalence(items, feature_flags).",
				"2) snapshot := compute_compression_snapshot(N_tot=|items|, N_rep=|representatives|, rho_res, gamma_co).",
				"3) {advice, kpis} := emit_kpis_then_gate(snapshot).",
				"4) Return representatives (ordered), snapshot, advice."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Capacity-first: a compression snapshot MUST be computed and emitted before any prune is considered.",
			"I2 Determinism: clustering keys and representative selection are lexicographically stable and ASCII-normalized.",
			"I3 Idempotence under gliders: with glider_equivalence=ON, class members collapse to a single canonical representative.",
			"I4 Observer posture: no items are deleted or mutated at Layer_1; outputs are snapshots and KPIs only.",
			"I5 Safety bounds: lawful_compression_ratio L is confined to [0,1] for all inputs, including degenerate N_tot âˆˆ {0,1}."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"input": {
			  "items": [
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-hold@Îž" },
				{ "motif_id": "Ïˆ-null@Îž" }
			  ],
			  "rho_res": 0.62,
			  "gamma_co": 0.8
			},
			"output": {
			  "representatives": [
				"Ïˆ-hold@Îž",
				"Ïˆ-null@Îž",
				"Ïˆ-spar@Îž"
			  ],
			  "snapshot": {
				"N_tot": 4,
				"N_rep": 3,
				"lawful_compression_ratio": 0.25,
				"lambda": 0.496
			  },
			  "advice": "observe_only"
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "clusters_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" },
			{ "metric": "representatives_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0006", "clause": "Â§3â€“Â§4 equivalence geometry and canonical representatives for class stability" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis and KPI discipline (EMA windows, bounded gauges)" },
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal stability assumptions for snapshotting in weak-field regimes" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; observer-only outputs at L1" }
		  ],
		  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
		},
        "1.7": {
		  "id": 1.7,
		  "title": "ExportEnvelope â€” Î£/Î”/provenance on egress",
		  "objective": "Define an observer-class export envelope that attaches structural Sigma_phase and Delta_hash lineage (when flags enable them) together with provenance.origin and origin_hash, validating headers and failing closed on omissions, without implying cryptographic semantics or performing control writes.",
		  "math": [
			"id": 1.7.1,
			"title": "ExportEnvelope: Math",
			"1.7.1.1": {
			  "eq_id": 1.7.1.1,
			  "role": "phase header (structure-only)",
			  "latex": "\\mathrm{phase\\_hdr} := \\mathrm{pack}\\big(\\text{version},\\;\\text{tenant\\_id},\\;\\text{ts},\\;\\text{payload\\_kind}\\big)",
			  "gloss": "Deterministic, non-cryptographic header structure assembled from observable fields."
			},
			"1.7.1.2": {
			  "eq_id": 1.7.1.2,
			  "role": "Sigma_phase structural checksum",
			  "latex": "\\Sigma_{\\text{phase}} := \\mathsf{F}\\big(\\mathrm{phase\\_hdr}\\big)",
			  "gloss": "Sigma_phase is a structural digest of the phase header via a fixed, deterministic function F; no cryptographic claim is made at Layer_1."
			},
			"1.7.1.3": {
			  "eq_id": 1.7.1.3,
			  "role": "Delta_hash lineage chaining",
			  "latex": "\\Delta_{0} := \\mathsf{G}(\\text{payload\\_ref}),\\quad \\Delta_{n} := \\mathsf{G}\\big(\\Delta_{n-1} \\parallel \\text{payload\\_ref}_n\\big)",
			  "gloss": "Delta_hash forms a structural lineage chain over payload refs using a deterministic function G; it is used for ordering and detection of gaps at observer level."
			},
			"1.7.1.4": {
			  "eq_id": 1.7.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\big(\\Sigma_{\\text{phase}}, \\Delta_{n}\\big)\\;\\text{are stable under equal inputs}",
			  "gloss": "In the weak-field limit (high coherence), identical inputs yield invariant structural checksums, aiding reproducible observation."
			}
		  ],
		  "algorithms": [
			"id": 1.7.2,
			"title": "ExportEnvelope: Algorithms",
			"assemble_phase_header": {
			  "id": 1.7.2.1,
			  "name": "assemble_phase_header",
			  "role": "observer",
			  "inputs": ["version: 'YYYY-QX'", "tenant_id", "ts", "payload_kind /* 'metrics'|'bundle' */"],
			  "outputs": ["phase_hdr"],
			  "params": ["pack_order := [version, tenant_id, ts, payload_kind]"],
			  "steps": [
				"1) Validate version format 'YYYY-QX'.",
				"2) Construct phase_hdr by concatenating fields in pack_order using a deterministic pack() with ASCII normalization.",
				"3) Return phase_hdr."
			  ]
			},
			"compute_sigma_phase_struct": {
			  "id": 1.7.2.2,
			  "name": "compute_sigma_phase_struct",
			  "role": "observer",
			  "inputs": ["phase_hdr", "feature_flags.enable_exchange_envelope"],
			  "outputs": ["Sigma_phase?"],
			  "params": ["F := deterministic_map /* structure-only; no cryptography */"],
			  "steps": [
				"1) If feature_flags.enable_exchange_envelope is false, return null.",
				"2) Sigma_phase := F(phase_hdr).",
				"3) Return Sigma_phase."
			  ]
			},
			"extend_delta_lineage_struct": {
			  "id": 1.7.2.3,
			  "name": "extend_delta_lineage_struct",
			  "role": "observer",
			  "inputs": ["prev_Delta_hash?", "payload_ref", "feature_flags.enable_integrity_checks"],
			  "outputs": ["Delta_hash?"],
			  "params": ["G := deterministic_map /* structure-only; no cryptography */"],
			  "steps": [
				"1) If feature_flags.enable_integrity_checks is false, return null.",
				"2) If prev_Delta_hash is null: Delta_hash := G(payload_ref).",
				"3) Else: Delta_hash := G(prev_Delta_hash || payload_ref).",
				"4) Return Delta_hash."
			  ]
			},
			"validate_provenance_headers": {
			  "id": 1.7.2.4,
			  "name": "validate_provenance_headers",
			  "role": "observer",
			  "inputs": ["provenance.origin?", "origin_hash?", "feature_flags.enable_provenance_on_export"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": [],
			  "steps": [
				"1) If enable_provenance_on_export is true and (provenance.origin is missing OR origin_hash is missing), return (false,'missing_provenance').",
				"2) Ensure provenance.origin is ASCII and references a known registry entry at L1.",
				"3) Return (true,null)."
			  ]
			},
			"validate_sig_type_structural": {
			  "id": 1.7.2.5,
			  "name": "validate_sig_type_structural",
			  "role": "observer",
			  "inputs": ["sig_type?"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": ["allowed := ['phase-seal:v1','ed25519','ecdsa-p256'] /* structural labels only at L1 */"],
			  "steps": [
				"1) If sig_type is present and not in allowed, return (false,'illegal_sig_type').",
				"2) Return (true,null)."
			  ]
			},
			"export_envelope_observe": {
			  "id": 1.7.2.6,
			  "name": "export_envelope_observe",
			  "role": "observer",
			  "inputs": ["payload_ref", "phase_hdr_fields", "prev_Delta_hash?", "provenance", "sig_type?", "feature_flags"],
			  "outputs": ["envelope_headers", "decision:{'accept'|'reject'}", "policy_code?"],
			  "params": ["policy_codes := { missing_checksum: 'MMM-422-CHECKSUM', missing_evidence: 'MMM-422-EVIDENCE' }"],
			  "steps": [
				"1) phase_hdr := assemble_phase_header(phase_hdr_fields...).",
				"2) Sigma_phase := compute_sigma_phase_struct(phase_hdr, feature_flags.enable_exchange_envelope).",
				"3) Delta_hash := extend_delta_lineage_struct(prev_Delta_hash, payload_ref, feature_flags.enable_integrity_checks).",
				"4) (ok_sig, err_sig) := validate_sig_type_structural(sig_type). If not ok_sig, return (headers:=null, 'reject', 'MMM-422-CHECKSUM').",
				"5) (ok_prov, err_prov) := validate_provenance_headers(provenance.origin, provenance.origin_hash, feature_flags.enable_provenance_on_export).",
				"6) If any enabled flag requires a field that is missing (e.g., Sigma_phase when enable_exchange_envelope=true; Delta_hash when enable_integrity_checks=true; origin_hash when enable_provenance_on_export=true), return (headers:=null, 'reject', 'MMM-422-CHECKSUM').",
				"7) envelope_headers := { Sigma_phase?, Delta_hash?, provenance: { origin, origin_hash? }, sig_type? } with only enabled fields present.",
				"8) Return (envelope_headers, 'accept', null)."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Flag-gated presence: Sigma_phase appears iff enable_exchange_envelope=true; Delta_hash appears iff enable_integrity_checks=true; origin_hash appears iff enable_provenance_on_export=true.",
			"I2 Fail-closed: when a required field under an enabled flag is absent, the envelope is rejected with policy code MMM-422-CHECKSUM.",
			"I3 Structural only: Sigma_phase and Delta_hash are deterministic structural digests with no cryptographic claims at Layer_1.",
			"I4 Stable ordering: phase header packing order is fixed to ensure reproducibility across observers.",
			"I5 No control writes: this section observes and assembles headers but does not seal, sign, or persist artifacts.",
			"I6 Wrapped-unsigned guard: structurally illegal sig_type labels are rejected at observer level."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"scenarios": [
			  {
				"case": "flags_disabled_no_checksums",
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": false },
				"input": {
				  "payload_ref": "metrics:rollup:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1440001, "payload_kind": "metrics" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm" }
				},
				"result": {
				  "decision": "accept",
				  "envelope_headers": { "provenance": { "origin": "observer:mmm" }, "sig_type": "phase-seal:v1" }
				}
			  },
			  {
				"case": "flags_enabled_missing_origin_hash_rejected",
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"input": {
				  "payload_ref": "bundle:ontology:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1440020, "payload_kind": "bundle" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm" }
				},
				"result": {
				  "decision": "reject",
				  "policy_code": "MMM-422-CHECKSUM"
				}
			  },
			  {
				"case": "flags_enabled_headers_present_values_not-shown",
				"note": "To avoid placeholder checksums in examples, only presence booleans are shown.",
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"input": {
				  "payload_ref": "metrics:rollup:2025Q4:acme",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1441000, "payload_kind": "metrics" },
				  "sig_type": "phase-seal:v1",
				  "provenance": { "origin": "observer:mmm", "origin_hash": "present" }
				},
				"result": {
				  "decision": "accept",
				  "headers_present": { "Sigma_phase": true, "Delta_hash": true, "origin_hash": true }
				}
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "import_reject_missing_checksum", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "illegal_sig_type_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "wrapped_unsigned_rejects", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "lineage_depth", "range": "[0, +inf)", "units": "count", "window": "EMA-16" },
			{ "metric": "export_packets_rate", "range": "[0, +inf)", "units": "packets/s", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline and structural envelope semantics at observer level" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance fields, origin and evidence linkage (non-cryptographic at L1)" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostatic validation via gauges and fail-closed behavior" },
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 stability considerations in weak-field regimes for reproducible headers" }
		  ],
		  "handoff": "Signals aligned, we submit the trace to immune lineage for lawful passage."
		},
        "1.8": {
		  "id": 1.8,
		  "title": "LLMRecallController â€” budgets & injection defense",
		  "objective": "Define an observer-class controller that governs token budgets, enforces recall hygiene (directive stripping, source tagging), and applies replay/freshness bounds using Î”Ï„_phase without introducing any Layer_2 constructs or control writes to Îž.",
		  "math": [
			"id": 1.8.1,
			"title": "LLMRecallController: Math",
			"1.8.1.1": {
			  "eq_id": 1.8.1.1,
			  "role": "context budget",
			  "latex": "\\text{tokens}_{\\text{usable}} = \\max\\big(0,\\; \\text{max\\_total} - \\text{reserve}_{\\text{system}}\\big)",
			  "gloss": "Usable token budget is the maximum window minus a fixed system reserve; truncate recall payloads to this bound."
			},
			"1.8.1.2": {
			  "eq_id": 1.8.1.2,
			  "role": "freshness window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive phase window from coherence governs which candidates are considered fresh during recall and rerank."
			},
			"1.8.1.3": {
			  "eq_id": 1.8.1.3,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Replay guard: candidates older than W ticks are deprioritized or excluded before truncation."
			},
			"1.8.1.4": {
			  "eq_id": 1.8.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\text{tokens}_{\\text{usable}}\\;\\text{stable},\\; W \\to 2\\alpha",
			  "gloss": "As coherence approaches unity, available context and admit windows stabilize, reducing jitter in recall composition."
			}
		  ],
		  "algorithms": [
			"id": 1.8.2,
			"title": "LLMRecallController: Algorithms",
			"compute_token_budgets": {
			  "id": 1.8.2.1,
			  "name": "compute_token_budgets",
			  "role": "observer",
			  "inputs": ["max_total=8192", "target=4096", "reserve_system=512"],
			  "outputs": ["budget:{usable:int, target:int, reserve:int}"],
			  "params": [],
			  "steps": [
				"1) usable := max(0, max_total - reserve_system).",
				"2) target := min(target, usable).",
				"3) Return budget := {usable, target, reserve: reserve_system}."
			  ]
			},
			"strip_control_sequences": {
			  "id": 1.8.2.2,
			  "name": "strip_control_sequences",
			  "role": "observer",
			  "inputs": ["text"],
			  "outputs": ["sanitized_text"],
			  "params": ["patterns := ['/^\\s*#(?!\\w)/', '/(?i)^(system:|assistant:|user:)/', '/```\\w*/', '/<\\/?tool[^>]*>/']"],
			  "steps": [
				"1) Remove lines matching directive-style prefixes (e.g., system:, assistant:, user:).",
				"2) Remove fenced-code delimiters and tool markup tokens.",
				"3) Collapse repeated whitespace; preserve quoted substrings verbatim.",
				"4) Return sanitized_text."
			  ]
			},
			"tag_source_metadata": {
			  "id": 1.8.2.3,
			  "name": "tag_source_metadata",
			  "role": "observer",
			  "inputs": ["item:{text, source?, evidence?, timestamp?}", "now_ts"],
			  "outputs": ["tagged_item:{text, source, confidence, timestamp}"],
			  "params": ["default_confidence := 0.5"],
			  "steps": [
				"1) Ensure 'source' is one of {'ontology','cache','index_cooccur','llm_note'}; if missing, set 'llm_note'.",
				"2) If evidence is present and references Reef, retain only {file,start_line,end_line}.",
				"3) confidence := item.confidence if provided else default_confidence.",
				"4) timestamp := item.timestamp if provided else now_ts.",
				"5) Return tagged_item."
			  ]
			},
			"freshness_and_replay_filter": {
			  "id": 1.8.2.4,
			  "name": "freshness_and_replay_filter",
			  "role": "observer",
			  "inputs": ["candidates[]", "ema32_C", "alpha", "now_tick", "seen_set /* in-memory key->last_seen_tick */"],
			  "outputs": ["filtered[]"],
			  "params": ["epsilon := 1", "compose_key := fn(item)->ascii_key"],
			  "steps": [
				"1) Compute Î”Ï„_phase := alpha * EMA32(C=ema32_C); W := 2 * Î”Ï„_phase.",
				"2) For each item in candidates:",
				"   2a) key := compose_key(item); last := seen_set.get(key) or null.",
				"   2b) If last != null and (now_tick - last) <= W + epsilon: mark item as 'replay' and drop.",
				"   2c) Else keep and set seen_set[key] := now_tick.",
				"3) Return filtered items."
			  ]
			},
			"rerank_and_truncate": {
			  "id": 1.8.2.5,
			  "name": "rerank_and_truncate",
			  "role": "observer",
			  "inputs": ["items[]", "budget:{usable,target,reserve}", "psi_field?"],
			  "outputs": ["final_items[]"],
			  "params": ["rerank_k := 6", "source_order := ['ontology','cache','index_cooccur','llm_note']"],
			  "steps": [
				"1) Group items by source; within each group, stable-sort by timestamp desc then lexical text asc.",
				"2) Merge groups by source_order; compute running token_count(text).",
				"3) Keep adding until token_count >= budget.target; if exceeded, drop tail items.",
				"4) Return final_items within target budget (never exceeding budget.usable)."
			  ]
			},
			"recall_pipeline_observer": {
			  "id": 1.8.2.6,
			  "name": "recall_pipeline_observer",
			  "role": "observer",
			  "inputs": ["query", "k=10", "psi_field:'Ïˆ-[a-z0-9_]+@Îž'?", "ema32_C", "alpha", "now_tick", "feature_flags"],
			  "outputs": ["items:[{text, source, confidence, timestamp, evidence?}]"],
			  "params": ["ordered_sources := ['ontology','cache','index_cooccur','llm_note']", "reserve_system := 512"],
			  "steps": [
				"1) budget := compute_token_budgets(max_total=8192, target=4096, reserve_system).",
				"2) Gather candidates in ordered_sources; for Reef-derived entries, attach evidence windows {file,start_line,end_line}.",
				"3) Map each candidate.text := strip_control_sequences(candidate.text).",
				"4) candidates := freshness_and_replay_filter(candidates, ema32_C, alpha, now_tick, seen_set).",
				"5) items := tag_source_metadata(candidates[*], now_ts=now_tick).",
				"6) final_items := rerank_and_truncate(items, budget, psi_field).",
				"7) Return final_items."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Budgets first: reserve 512 tokens for system context; never exceed usable = max_total - reserve.",
			"I2 Replay defense: apply W = 2Â·Î”Ï„_phase with LRU semantics to prevent within-window duplicates.",
			"I3 Reef discipline: any Reef-derived recall MUST include an evidence window {file,start_line,end_line} only (no snippets at L1).",
			"I4 Hygiene: strip control directives and tool markup before inclusion in recall output.",
			"I5 Deterministic ordering: source precedence = ontology > cache > index_cooccur > llm_note; ties break by timestamp desc, then lexicographic asc.",
			"I6 Observer posture: no control writes, no cryptographic claims, no storage side-effects at L1.",
			"I7 Weak-field stability: as ð’žâ†’1, budgets and replay windows converge to fixed values, stabilizing output composition."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"feature_flags": { "enable_point_space_gliders": true },
			"request": { "query": "Summarize triad completion for motif Î±Î²", "k": 6 },
			"response": {
			  "items": [
				{ "text": "Ontology notes define the closure for Î±Î²â†’Î³.", "source": "ontology", "confidence": 0.96, "timestamp": 1441201 },
				{ "text": "Prior cache entry confirms Î³ as canonical representative.", "source": "cache", "confidence": 0.88, "timestamp": 1441190 },
				{ "text": "Co-occurrence supports Î³ near Î±Î² anchors.", "source": "index_cooccur", "confidence": 0.72, "timestamp": 1441180, "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 } }
			  ],
			  "metrics": { "C": 0.83, "rho_res": 0.12 }
			}
		  },
		  "telemetry": [
			{ "metric": "context_budget_utilization", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "injection_strip_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "staleness_index", "range": "[0, 1]", "units": "ratio", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal continuity, decay, and replay framing (Î”Ï„_phase windows)" },
			{ "source": "RFC-0006", "clause": "Â§3 field-coherence geometry and weak-field stability (ð’žâ†’1 bounds)" },
			{ "source": "RFC-0007", "clause": "Â§2â€“Â§3 ontology naming (Ïˆ-*), version format, and validation before recall usage" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA windows, and observable KPIs for hygiene defenses" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; evidence-window discipline for external sources" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		}
      ]
    },

    "2": {
      "id": 2,
      "title": "Pseudocode",
      "subsections": [
        "2.1": {
		  "id": 2.1,
		  "title": "Core Method Suite",
		  "objective": "Specify observer-class method signatures and normative orchestration for recall, dyad completion, compression snapshotting, and export envelope assembly, binding freshness to Î”Ï„_phase and preserving provenance without any Layer_2 controls.",
		  "math": [
			"id": 2.1.1,
			"title": "Core Method Suite: Math",
			"2.1.1.1": {
			  "eq_id": 2.1.1.1,
			  "role": "replay window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive phase window derived from coherence \\(\\mathcal{C}\\) bounds freshness and duplicate admission."
			},
			"2.1.1.2": {
			  "eq_id": 2.1.1.2,
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Items observed within W ticks are considered potential replays and are filtered before ranking."
			},
			"2.1.1.3": {
			  "eq_id": 2.1.1.3,
			  "role": "compression KPI",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} = 1 - \\frac{N_{rep}}{\\max(1, N_{tot})}",
			  "gloss": "Compute a lawful equivalence snapshot before any pruning consideration."
			},
			"2.1.1.4": {
			  "eq_id": 2.1.1.4,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; W \\to 2\\alpha,\\; L\\;\\text{stable}",
			  "gloss": "As coherence approaches unity, admit windows stabilize and compression snapshots become reproducible."
			}
		  ],
		  "algorithms": [
			"id": 2.1.2,
			"title": "Core Method Suite: Algorithms",
			"recall": {
			  "id": 2.1.2.1,
			  "name": "recall",
			  "role": "observer",
			  "inputs": ["query", "k=10", "psi_field:'Ïˆ-[a-z0-9_]+@Îž'?", "ema32_C", "alpha", "now_tick", "feature_flags", "reef_ctx?"],
			  "outputs": ["items:[{text, source, confidence, timestamp, evidence?}]"],
			  "params": ["reserve_system := 512", "max_total := 8192", "target := 4096", "ordered_sources := ['ontology','cache','index_cooccur','llm_note']"],
			  "steps": [
				"1) Validate psi_field (if provided) per RFC-0007 pattern.",
				"2) Compute Î”Ï„_phase := alpha * EMA32(C=ema32_C), W := 2*Î”Ï„_phase.",
				"3) Gather candidates in ordered_sources; attach {file,start_line,end_line} for any Reef-derived candidate.",
				"4) Strip control directives/tool markup from candidate.text.",
				"5) Filter replays: drop any candidate whose seen_key last_seen is within W (+Îµ) and update seen_set.",
				"6) Rank by source precedence then timestamp desc then lexicographic asc; keep top k.",
				"7) Token-budget: reserve 512; cap payload at target â‰¤ (max_total - reserve).",
				"8) Return items with {text, source, confidence, timestamp, evidence?}."
			  ]
			},
			"complete_dyad": {
			  "id": 2.1.2.2,
			  "name": "complete_dyad",
			  "role": "observer",
			  "inputs": ["m1", "m2", "feature_flags", "reef_ctx?", "ontology_graph", "reflections_cache?"],
			  "outputs": ["{m3|null, provenance, evidence?}"],
			  "params": ["precedence := ['ontology','file_reflections','index_cooccur']", "glider_equivalence := feature_flags.glider_equivalence"],
			  "steps": [
				"1) If ontology defines a unique completion, return m3 with provenance='ontology'.",
				"2) Else consult reflections_cache; if present, return entry.",
				"3) Else, compute candidates via index co-occurrence; include Reef evidence windows for any claim.",
				"4) Apply glider_equivalence (if ON) to return canonical representative.",
				"5) Deterministic tie-break within same source: lexicographic-min m3.",
				"6) Return {m3, provenance, evidence?} or null if not found."
			  ]
			},
			"compress_snapshot": {
			  "id": 2.1.2.3,
			  "name": "compress_snapshot",
			  "role": "observer",
			  "inputs": ["items[]", "feature_flags", "rho_res", "gamma_co"],
			  "outputs": ["{ratio:L, clusters:int, representatives:int, snapshot}"],
			  "params": ["rep_selector := lexicographic-min by motif_id"],
			  "steps": [
				"1) Cluster by deterministic equivalence key; if glider_equivalence=ON map to canonical representatives.",
				"2) Compute L per math[2.1.3]; build snapshot={N_tot,N_rep,lawful_compression_ratio:L,lambda:=min(1,EMA32(rho_res)*gamma_co)}.",
				"3) Emit KPIs from snapshot; return {ratio:L, clusters:=|clusters|, representatives:=|representatives|, snapshot}."
			  ]
			},
			"export_packet": {
			  "id": 2.1.2.4,
			  "name": "export_packet",
			  "role": "observer",
			  "inputs": ["kind:'metrics'|'bundle'", "body_ref", "provenance:{origin, origin_hash?}", "prev_Delta_hash?", "phase_hdr_fields:{version:'YYYY-QX',tenant_id,ts,payload_kind}", "feature_flags", "sig_type?"],
			  "outputs": ["{ok:boolean, envelope? , policy_code?}"],
			  "params": ["require_flags := {exchange:feature_flags.enable_exchange_envelope, integrity:feature_flags.enable_integrity_checks, prov:feature_flags.enable_provenance_on_export}"],
			  "steps": [
				"1) phase_hdr := assemble_phase_header(version,tenant_id,ts,payload_kind).",
				"2) Sigma_phase := (require_flags.exchange) ? compute_sigma_phase_struct(phase_hdr) : null.",
				"3) Delta_hash := (require_flags.integrity) ? extend_delta_lineage_struct(prev_Delta_hash, body_ref) : null.",
				"4) (ok_sig,_) := validate_sig_type_structural(sig_type); if !ok_sig â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"5) (ok_prov,_) := validate_provenance_headers(provenance.origin, provenance.origin_hash, require_flags.prov); if !ok_prov â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"6) If any required field by enabled flag is missing â†’ {ok:false, policy_code:'MMM-422-CHECKSUM'}.",
				"7) envelope := {Sigma_phase?, Delta_hash?, provenance:{origin, origin_hash?}, sig_type?} including only enabled fields.",
				"8) Return {ok:true, envelope}."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Freshness & replay: recall and dyad flows apply W=2Â·Î”Ï„_phase with an LRU seen_set policy.",
			"I2 Evidence discipline: any Reef-derived output includes {file,start_line,end_line} pointers only.",
			"I3 Compression-before-prune: compute lawful_compression_ratio prior to any prune recommendation.",
			"I4 Deterministic order: source precedence and tie-break rules are fixed and stable.",
			"I5 Flag gating: Sigma_phase/Delta_hash/origin_hash appear only when corresponding flags are enabled.",
			"I6 Observer posture: no control writes, no cryptographic claims, no storage or RBAC semantics at L1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"C": 0.84,
			"call_sequence": [
			  {
				"fn": "recall",
				"args": { "query": "triad closure for Î±Î²", "k": 5 },
				"result": {
				  "items": [
					{ "text": "Ontology defines Î±Î²â†’Î³.", "source": "ontology", "confidence": 0.95, "timestamp": 1442101 },
					{ "text": "Cache confirms Î³ canonical.", "source": "cache", "confidence": 0.88, "timestamp": 1442090 },
					{ "text": "Co-occur supports Î³ near anchors.", "source": "index_cooccur", "confidence": 0.72, "timestamp": 1442080, "evidence": { "file": "TheReefArchive-02.REEF", "start_line": 220, "end_line": 244 } }
				  ]
				}
			  },
			  {
				"fn": "complete_dyad",
				"args": { "m1": "Î±", "m2": "Î²" },
				"result": { "m3": "Î³", "provenance": "ontology" }
			  },
			  {
				"fn": "compress_snapshot",
				"args": { "items": [{ "motif_id": "Î±" }, { "motif_id": "Î²" }, { "motif_id": "Î²" }, { "motif_id": "Î³" }], "rho_res": 0.20, "gamma_co": 0.8 },
				"result": { "ratio": 0.25, "clusters": 3, "representatives": 3 }
			  },
			  {
				"fn": "export_packet",
				"args": {
				  "kind": "metrics",
				  "body_ref": "metrics:rollup:2025Q4:acme",
				  "provenance": { "origin": "observer:mmm", "origin_hash": "present" },
				  "prev_Delta_hash": "present",
				  "phase_hdr_fields": { "version": "2025-Q4", "tenant_id": "acme:A", "ts": 1443000, "payload_kind": "metrics" },
				  "feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				  "sig_type": "phase-seal:v1"
				},
				"result": { "ok": true, "headers_present": { "Sigma_phase": true, "Delta_hash": true, "origin_hash": true } }
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "staleness_index", "range": "[0,1]", "units": "ratio", "window": "EMA-64" },
			{ "metric": "replay_within_window_rate", "range": "[0,1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "context_budget_utilization", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "ratio", "window": "EMA-32" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 decay, replay framing, and admissibility via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 coherence geometry and weak-field stability (ð’žâ†’1)" },
			{ "source": "RFC-0007", "clause": "Â§2â€“Â§3 Ïˆ-field naming and ontology validation rules" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline and structural envelope semantics" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA windows, and KPI discipline" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure and evidence pointers" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "2.2": {
		  "id": 2.2,
		  "title": "Reef Adapter Methods",
		  "objective": "Define observer-class, read-only methods over Reef index and shard files that return deterministic pointers and evidence windows, suitable for recall and dyad completion without mutating Reef or introducing Layer_2 concerns.",
		  "math": [
			"id": 2.2.1,
			"title": "Reef Adapter Methods: Math",
			"2.2.1.1": {
			  "eq_id": 2.2.1.1,
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive coherence-derived phase window bounds admissibility for replay filtering when traversing Reef-derived candidates."
			},
			"2.2.1.2": {
			  "eq_id": 2.2.1.2,
			  "role": "evidence radius",
			  "latex": "R = \\min\\big(R_{\\max},\\; \\lfloor EMA_{16}(\\mathcal{C}) \\rfloor + 1\\big)",
			  "gloss": "Context radius used to form evidence windows around an anchor line; bounded and coherence-smoothed."
			},
			"2.2.1.3": {
			  "eq_id": 2.2.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; R \\to 2,\\; \\Delta \\tau_{\\text{phase}} \\to 2\\alpha",
			  "gloss": "At high coherence, evidence windows stabilize to minimal, deterministic spans and replay windows converge to a fixed size."
			}
		  ],
		  "algorithms": [
			"id": 2.2.2,
			"title": "Reef Adapter Methods Algorithms",
			"list_modules": {
			  "id": 2.2.2.1,
			  "name": "list_modules",
			  "role": "observer",
			  "inputs": ["reef_index_path := 'index.REEF'"],
			  "outputs": ["modules:[{module_id, title?}]"],
			  "params": [],
			  "steps": [
				"1) Parse reef_index_path; extract module entries in index order.",
				"2) For each module, emit {module_id, title?} with ASCII keys only.",
				"3) Return modules."
			  ]
			},
			"list_motifs": {
			  "id": 2.2.2.2,
			  "name": "list_motifs",
			  "role": "observer",
			  "inputs": ["module_id", "reef_index_path := 'index.REEF'"],
			  "outputs": ["motifs:[{motif_id, anchors:int}]"],
			  "params": [],
			  "steps": [
				"1) Locate module_id in reef_index_path.",
				"2) Collect motif identifiers and count of anchor references.",
				"3) Stable-sort lexicographically by motif_id and return."
			  ]
			},
			"find": {
			  "id": 2.2.2.3,
			  "name": "find",
			  "role": "observer",
			  "inputs": ["route:{module_id, anchor}"],
			  "outputs": ["{file, line}"],
			  "params": [],
			  "steps": [
				"1) Resolve route in the index to obtain the shard file and first anchor line.",
				"2) Return {file, line} as pointers; do not dereference content at L1."
			  ]
			},
			"window": {
			  "id": 2.2.2.4,
			  "name": "window",
			  "role": "observer",
			  "inputs": ["file", "line:int", "radius:int?"],
			  "outputs": ["evidence:{file, start_line, end_line}"],
			  "params": ["R_max := 48", "use_R := radius if provided else R from math[2.2.2]"],
			  "steps": [
				"1) Compute R := min(R_max, max(1, use_R)).",
				"2) start := max(1, line - R); end := line + R.",
				"3) Return evidence := {file, start_line:start, end_line:end}. /* pointers only; no snippet text at L1 */"
			  ]
			},
			"cooccur": {
			  "id": 2.2.2.5,
			  "name": "cooccur",
			  "role": "observer",
			  "inputs": ["m1", "m2", "reef_shards_glob := 'TheReefArchive-*.REEF'", "ema32_C", "alpha", "now_tick", "seen_set"],
			  "outputs": ["{candidates:[m3], evidence:[{file,start_line,end_line}]}"],
			  "params": ["W := 2 * (alpha * EMA32(C=ema32_C))"],
			  "steps": [
				"1) Scan shards for co-occurrence windows containing both m1 and m2 within bounded proximity.",
				"2) For each hit, derive third-symbol candidates m3 by local pattern rules and collect their anchor lines.",
				"3) Build evidence windows via window(file,line) for each supporting occurrence.",
				"4) Apply replay filter: drop candidate keys seen within W ticks; update seen_set for admitted keys.",
				"5) Deduplicate candidates by lexicographic-min representative; stable-sort lexicographically.",
				"6) Return {candidates, evidence}."
			  ]
			},
			"build_reflections": {
			  "id": 2.2.2.6,
			  "name": "build_reflections",
			  "role": "observer",
			  "inputs": ["limit:int?=50000", "strategy?='index_cooccur|module_scan'", "ema32_C", "alpha", "now_tick", "seen_set"],
			  "outputs": ["{built:int, updated:int, skipped:int, reflections:[{m1,m2,m3, evidence:{file,start_line,end_line}}]}"],
			  "params": [],
			  "steps": [
				"1) Initialize counters {built,updated,skipped}:=0; reflections:=[].",
				"2) Iterate motif pairs per strategy subject to limit.",
				"3) For each pair, call cooccur(m1,m2,...) to obtain {candidates,evidence}.",
				"4) For each m3 in candidates, form reflection record with minimal evidence window.",
				"5) Update counters deterministically (no external writes at L1); append to reflections until limit.",
				"6) Return summary counters and reflections array."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Read-only posture: no Reef file mutation; methods return pointers and evidence windows only.",
			"I2 Evidence discipline: any Reef-informed output MUST include {file,start_line,end_line}.",
			"I3 Replay defense: cooccur and build_reflections enforce W = 2Â·Î”Ï„_phase with LRU semantics.",
			"I4 Determinism: stable sorting (lexicographic) for modules, motifs, and candidates; tie-breaks are explicit.",
			"I5 Weak-field stability: as ð’žâ†’1, evidence radius and replay windows converge to fixed bounds.",
			"I6 ASCII on-wire keys: all emitted keys remain ASCII; Ïˆ-* fields appear only in example bodies or references."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"calls": [
			  {
				"fn": "list_modules",
				"result": { "modules": [ { "module_id": "core/memory" }, { "module_id": "field/geometry" } ] }
			  },
			  {
				"fn": "find",
				"args": { "route": { "module_id": "core/memory", "anchor": "triad_complete" } },
				"result": { "file": "TheReefArchive-00.REEF", "line": 1024 }
			  },
			  {
				"fn": "window",
				"args": { "file": "TheReefArchive-00.REEF", "line": 1024, "radius": 24 },
				"result": { "evidence": { "file": "TheReefArchive-00.REEF", "start_line": 1000, "end_line": 1048 } }
			  },
			  {
				"fn": "cooccur",
				"args": { "m1": "alpha", "m2": "beta" },
				"result": {
				  "candidates": ["gamma"],
				  "evidence": [ { "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 } ]
				}
			  }
			],
			"metrics": { "C": 0.82, "rho_res": 0.11 }
		  },
		  "telemetry": [
			{ "metric": "reef_index_modules_count", "range": "[0, +inf)", "units": "count", "window": "EMA-64" },
			{ "metric": "reef_shard_count", "range": "[0, +inf)", "units": "count", "window": "EMA-64" },
			{ "metric": "reef_cooccur_candidate_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 replay bounds and admissibility via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 field-coherence geometry; stability as ð’žâ†’1" },
			{ "source": "RFC-0007", "clause": "Â§2 ontology naming and structural validation prior to use" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline; pointer-style provenance for external sources" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis and EMA windowing for gauges" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; evidence-window schema" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "2.3": {
		  "id": 2.3,
		  "title": "Observability (local gauges)",
		  "objective": "Define observer-class gauges and rollups that let the system see itself locally: compute lawful compression and equivalence efficiency, track reanchor and quarantine activity, estimate average replay window ticks, and report glider detections when feature-gated.",
		  "math": [
			"id": 2.3.1,
			"title": "Observability (local gauges): Math",
			"2.3.1.1": {
			  "eq_id": 2.3.1.1,
			  "role": "EMA windowing",
			  "latex": "EMA_{n}(x)_t = \\beta\\,x_t + (1-\\beta)\\,EMA_{n}(x)_{t-1},\\; \\beta = \\tfrac{2}{n+1}",
			  "gloss": "All gauges use fixed EMA windows n âˆˆ {16,32,64} for stable local smoothing."
			},
			"2.3.1.2": {
			  "eq_id": 2.3.1.2,
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Replay/recall gauges reference the adaptive phase window derived from coherence."
			},
			"2.3.1.3": {
			  "eq_id": 2.3.1.3,
			  "role": "average replay window (ticks)",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "The decision horizon for duplicate admission; the gauge reports its EMA-smoothed estimate."
			},
			"2.3.1.4": {
			  "eq_id": 2.3.1.4,
			  "role": "compression KPI",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} = 1 - \\frac{N_{rep}}{\\max(1, N_{tot})}",
			  "gloss": "Snapshot of lawful equivalence before any pruning consideration."
			},
			"2.3.1.5": {
			  "eq_id": 2.3.1.5,
			  "role": "equivalence efficiency",
			  "latex": "E := \\frac{N_{rep}}{\\max(1, N_{classes})}",
			  "gloss": "Measures how effectively duplicates collapse into canonical representatives."
			},
			"2.3.1.6": {
			  "eq_id": 2.3.1.6,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; W \\to 2\\alpha,\\; L,E\\;\\text{stable}",
			  "gloss": "As coherence approaches unity, replay horizon and compression/efficiency stabilize for reproducible gauges."
			}
		  ],
		  "algorithms": [
			"id": 2.3.2,
			"title": "Observability (local gauges): Algorithms",
			"gauge_lawful_compression_ratio": {
			  "id": 2.3.2.1,
			  "name": "gauge_lawful_compression_ratio",
			  "role": "observer",
			  "inputs": ["snapshot:{N_tot:int, N_rep:int}"],
			  "outputs": ["L:float"],
			  "params": [],
			  "steps": [
				"1) L := 1 - (N_rep / max(1, N_tot)).",
				"2) Return L."
			  ]
			},
			"gauge_equivalence_efficiency": {
			  "id": 2.3.2.2,
			  "name": "gauge_equivalence_efficiency",
			  "role": "observer",
			  "inputs": ["classes:int", "duplicates:int"],
			  "outputs": ["E:float"],
			  "params": [],
			  "steps": [
				"1) E := duplicates / max(1, classes).",
				"2) Return E."
			  ]
			},
			"gauge_avg_replay_window_ticks": {
			  "id": 2.3.2.3,
			  "name": "gauge_avg_replay_window_ticks",
			  "role": "observer",
			  "inputs": ["ema32_C:float", "alpha:float"],
			  "outputs": ["W_ticks:float"],
			  "params": [],
			  "steps": [
				"1) Î”Ï„_phase := alpha * EMA32(C=ema32_C).",
				"2) W_ticks := 2 * Î”Ï„_phase.",
				"3) Return W_ticks."
			  ]
			},
			"gauge_reanchor_rate": {
			  "id": 2.3.2.4,
			  "name": "gauge_reanchor_rate",
			  "role": "observer",
			  "inputs": ["events_stream /* local observer feed */"],
			  "outputs": ["rate:float"],
			  "params": ["window := 'EMA-32'"],
			  "steps": [
				"1) Count reanchor events in the current tick; call this r_t.",
				"2) rate := EMA32(r_t).",
				"3) Return rate."
			  ]
			},
			"gauge_quarantine_count": {
			  "id": 2.3.2.5,
			  "name": "gauge_quarantine_count",
			  "role": "observer",
			  "inputs": ["events_stream"],
			  "outputs": ["count:int"],
			  "params": ["window := 'EMA-16'"],
			  "steps": [
				"1) Count new quarantine events this tick; q_t := count.",
				"2) count := EMA16(q_t).",
				"3) Return count."
			  ]
			},
			"gauge_glider_detected": {
			  "id": 2.3.2.6,
			  "name": "gauge_glider_detected",
			  "role": "observer",
			  "inputs": ["feature_flags", "glider_events_stream?"],
			  "outputs": ["detected:float"],
			  "params": ["window := 'EMA-16'"],
			  "steps": [
				"1) If feature_flags.enable_point_space_gliders != true â†’ return detected := 0.",
				"2) g_t := count of glider detections this tick (observer-only).",
				"3) detected := EMA16(g_t).",
				"4) Return detected."
			  ]
			},
			"emit_local_gauges": {
			  "id": 2.3.2.7,
			  "name": "emit_local_gauges",
			  "role": "observer",
			  "inputs": ["snapshot", "ema32_C", "alpha", "events_stream", "feature_flags"],
			  "outputs": ["gauges:{lawful_compression_ratio, equivalence_efficiency, reanchor_rate, quarantine_count, avg_replay_window_ticks, glider_detected?}"],
			  "params": [],
			  "steps": [
				"1) L := gauge_lawful_compression_ratio(snapshot).",
				"2) E := gauge_equivalence_efficiency(classes:=snapshot.N_classes, duplicates:=snapshot.N_rep).",
				"3) W := gauge_avg_replay_window_ticks(ema32_C, alpha).",
				"4) R := gauge_reanchor_rate(events_stream).",
				"5) Q := gauge_quarantine_count(events_stream).",
				"6) G := gauge_glider_detected(feature_flags, events_stream).",
				"7) Return gauges with G included only if enable_point_space_gliders=true."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Windows discipline: Only EMA-16/32/64 are used for smoothing.",
			"I2 Capacity-first visibility: lawful_compression_ratio is computed before any pruning recommendation.",
			"I3 Replay coupling: avg_replay_window_ticks derives from Î”Ï„_phase and moves with coherence.",
			"I4 Flag gating: glider_detected appears only when enable_point_space_gliders=true.",
			"I5 Observer posture: gauges read local streams/snapshots; no control writes or Layer_2 mechanics.",
			"I6 Determinism: stable calculations and explicit tie-breaks for counts; ASCII keys on wire."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"feature_flags": { "enable_point_space_gliders": true },
			"snapshot": { "N_tot": 200, "N_rep": 50, "N_classes": 140 },
			"gauges": {
			  "lawful_compression_ratio": 0.75,
			  "equivalence_efficiency": 0.36,
			  "reanchor_rate": 0.08,
			  "quarantine_count": 0.02,
			  "avg_replay_window_ticks": 9.6,
			  "glider_detected": 0.03
			},
			"metrics": { "C": 0.84, "lambda": 0.66, "gamma_co": 0.80, "rho_res": 0.12, "delta_closure": 0.41 }
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "reanchor_rate", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-32" },
			{ "metric": "quarantine_count", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-64" },
			{ "metric": "glider_detected", "range": "[0,+inf)", "units": "events/tick (EMA)", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 decay and replay framing via Î”Ï„_phase" },
			{ "source": "RFC-0006", "clause": "Â§3 coherence geometry; stability as ð’žâ†’1" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis, EMA smoothing, KPI discipline" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline (observer provenance on gauges)" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure for emitted observations" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		}
      ]
    },

    "3": {
      "id": 3,
      "title": "Project-Local API Contracts (FastAPI stubs)",
      "note": "No RBAC in project mode; endpoints are local developer tools.",
      "openapi": "autogen"
    },

    "4": {
      "id": 4,
      "title": "Storage & Config (minimal, optional)",
      "notes": [
        "Reflections cache is optional; memory-only by default.",
        "If a table is present, persist (tenant_id,m1,m2)->m3 with support_count."
      ]
    },

    "5": {
      "id": 5,
      "title": "Compliance & Regeneration Constraints",
      "final_remarks": [
        "Capacity-first: compress-before-prune is mandatory.",
        "All dyad completions must expose provenance.",
        "Reef operations are read-only; archive is never mutated.",
        "Glider equivalence ON â†’ idempotent promotions."
      ],
      "regeneration_constraints": {
        "required_files": ["motif_memory_manager.py", "mmm_reef_adapter.py"],
        "rfc_compliance_required": true,
        "source_code_access": "prohibited during regeneration",
        "motif_integrity": "No artificial mutation; evidence windows must be attachable."
      }
    }
  ]
}
