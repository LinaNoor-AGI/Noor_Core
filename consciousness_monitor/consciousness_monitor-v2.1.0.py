# Copyright (c) 2024 The Noor Research Collective
# MIT License
# Generated by Gemini 2.5 Pro (Google AI Studio)

"""
Implements a symbolic observer for field-level swirl monitoring, entanglement
logging, and phase-state diagnostics. Operates in a fully non-mutative modality,
consistent with symbolic contract constraints defined in the Noor RFCs.
This module is based on RFC-CORE-005, RFC-0006, and related specifications.

Symbolic ID: observer.phase.entanglement
Application ID: APP-005-consciousness-monitor
"""

import collections
import math
import sys
import threading
import time
from typing import Any, Callable, Deque, Dict, List, Optional, Tuple

# --- Module Constants (as per Generation Specification) ---
__version__ = "2.1.0"
# Schema version for exported data packets. RFC-CORE-005 §5
_SCHEMA_VERSION__ = "2025-Q4-consciousness-monitor-v2"
# Declares compatibility with core symbolic RFCs.
SCHEMA_COMPAT = ["RFC-0006", "RFC-0003", "RFC-0004", "RFC-0005", "RFC-0007"]


# --- Observability Compliance (RFC-CORE-005 §8) ---
try:
    # Attempt to import the mandatory Prometheus client.
    from prometheus_client import Counter, Gauge
except ImportError:
    # If Prometheus is not available, provide a stub class that satisfies the
    # metric interface but performs no operations. This ensures the monitor
    # remains functional in non-instrumented environments.
    class _PrometheusStub:
        """A no-op stub for Prometheus metrics to ensure graceful degradation."""
        def __init__(self, *args, **kwargs):
            pass
        def inc(self, *args, **kwargs):
            pass
        def set(self, *args, **kwargs):
            pass
        def observe(self, *args, **kwargs):
            pass

    Counter = Gauge = _PrometheusStub


class ConsciousnessMonitor:
    """
    Observer module that listens for swirl density and entanglement transitions
    across symbolic fields.

    This class operates as a non-mutative, read-only observer as defined in
    RFC-0004. It tracks the geometric properties of the symbolic field,
    specifically the swirl and phase coherence, without altering the state of
    any other system component.
    """

    def __init__(
        self,
        monitor_id: str = "cm@default",
        swirl_threshold: float = 0.87,
        buffer_size: int = 512,
        time_provider: Callable[[], float] = time.time,
    ):
        """
        Initializes the ConsciousnessMonitor instance.

        Args:
            monitor_id: Unique identifier for this monitor instance.
            swirl_threshold: The symbolic coherence cutoff for phase transitions.
                             (RFC-CORE-005 §1.1, §2.2)
            buffer_size: The size of the internal event logs.
            time_provider: A callable that returns the current time as a float.
                           This allows for testing with controlled time.
        """
        self.monitor_id = monitor_id
        self.swirl_threshold = swirl_threshold
        self.buffer_size = buffer_size
        self.time_provider = time_provider

        # Thread-safety lock for concurrent tick observation. RFC-CORE-005 §2
        self._entanglement_lock = threading.RLock()

        # --- Prometheus Metrics Initialization ---
        # As per RFC-CORE-005 §8 and generation spec requirements.
        self.metric_tick_rate = Counter(
            "consciousness_ticks_observed_total",
            "Total number of symbolic ticks observed.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_phase_transitions = Counter(
            "consciousness_phase_transitions_total",
            "Total number of symbolic phase transitions.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_entanglement_events_total = Counter(
            "consciousness_entanglement_events_total",
            "Total number of swirl entanglement events logged.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)
        
        self.metric_buffer_warnings = Counter(
            "consciousness_buffer_warnings_total",
            "Fires when the entanglement log exceeds 90% capacity.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_buffer_fill_ratio = Gauge(
            "consciousness_buffer_fill_ratio",
            "Current fill ratio of the entanglement event log.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_active_field_count = Gauge(
            "consciousness_active_fields",
            "Number of unique fields showing recent entanglement.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_current_phase_duration_seconds = Gauge(
            "consciousness_current_phase_duration_seconds",
            "Duration of the current phase in seconds.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        self.metric_phase_flip_rate = Gauge(
             "consciousness_phase_flip_rate_per_min",
             "Average number of phase flips per minute.",
             ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)
        
        self.metric_swirl_convergence = Gauge(
            "consciousness_swirl_convergence_r_metric",
            "R-Metric: Smoothed swirl convergence (overlap) score.",
            ["monitor_id"],
        ).labels(monitor_id=self.monitor_id)

        # Initialize all state variables
        self.reset()

    def reset(self) -> None:
        """
        Clears all internal memory, resets metrics, and reinitializes state
        to its default.
        """
        with self._entanglement_lock:
            # Internal state variables
            self.recent_ticks: Deque[Any] = collections.deque(maxlen=self.buffer_size)
            self.entanglement_log: Deque[Dict] = collections.deque(maxlen=self.buffer_size * 2)
            self._phase_log: Deque[float] = collections.deque(maxlen=100)
            self._cache_field_signatures: Dict[str, Dict] = {}

            # Phase state management. RFC-CORE-005 §3
            self.phase_state: bool = False
            self._phase_entered_at: Optional[float] = None
            self._last_phase_flip_time: float = 0.0

            # Reset relevant gauges to 0
            self.metric_buffer_fill_ratio.set(0)
            self.metric_active_field_count.set(0)
            self.metric_current_phase_duration_seconds.set(0)
            self.metric_phase_flip_rate.set(0)
            self.metric_swirl_convergence.set(0)

    def observe_tick(self, tick: Any) -> None:
        """
        Processes an incoming symbolic tick, the primary entry point for the observer.

        It validates the tick's structure, updates the tick rate, and passes
        the tick to internal analysis methods.

        Args:
            tick: The symbolic tick object. Must have an `extensions` attribute
                  containing a `Φ_coherence_map` dictionary.

        Raises:
            ValueError: If the tick is malformed per RFC-0003 and RFC-0006.
        """
        # Contract enforcement: tick must be 'swirl-aware'. RFC-CORE-005 §2
        if not hasattr(tick, "extensions") or "Φ_coherence_map" not in tick.extensions:
            raise ValueError(
                "Symbolic tick missing required .extensions['Φ_coherence_map']"
            )

        with self._entanglement_lock:
            self.metric_tick_rate.inc()
            self.recent_ticks.append(tick)
            self._extract_fields(tick)

            # Update duration metric on every tick
            if self.phase_state and self._phase_entered_at is not None:
                duration = self.time_provider() - self._phase_entered_at
                self.metric_current_phase_duration_seconds.set(duration)
            else:
                self.metric_current_phase_duration_seconds.set(0)


    def _extract_fields(self, tick: Any) -> None:
        """
        Parses the Φ-coherence map for swirl and overlap values from each
        ψ-field. Records entanglement if thresholds are met.

        Args:
            tick: A validated symbolic tick object.
        """
        # RFC-CORE-005 §2.1
        phi_map = tick.extensions.get("Φ_coherence_map", {})
        for field_id, field_data in phi_map.items():
            swirl = field_data.get("swirl_density", 0.0)
            overlap = field_data.get("overlap", 0.0)

            # Check if the swirl value triggers a phase shift
            is_swirling = self._check_phase_shift(swirl)

            # Only record entanglement if the system is in an active phase
            # and the specific field's swirl is above the base threshold.
            if is_swirling and swirl >= self.swirl_threshold:
                self._record_entanglement(
                    field_id, swirl, overlap, getattr(tick, "tick_id", "unknown"), tick
                )

    def _check_phase_shift(self, swirl_density: float) -> bool:
        """
        Applies symbolic hysteresis to determine if a phase transition occurs.
        Prevents rapid, unstable state flapping.

        Args:
            swirl_density: The swirl density value for a given field.

        Returns:
            The current phase state (True if active, False if not).
        """
        now = self.time_provider()
        
        # Symbolic cooldown to prevent phase flapping. RFC-CORE-005 §2.2
        if now - self._last_phase_flip_time < 0.1:
            return self.phase_state

        # Hysteresis bounds for symbolic inertia. RFC-CORE-005 §2.2
        upper_bound = self.swirl_threshold * 1.1
        lower_bound = self.swirl_threshold * 0.9

        new_state = self.phase_state
        if not self.phase_state and swirl_density > upper_bound:
            new_state = True
        elif self.phase_state and swirl_density < lower_bound:
            new_state = False

        if new_state != self.phase_state:
            self.phase_state = new_state
            self.metric_phase_transitions.inc()
            self._phase_log.append(now)
            self._last_phase_flip_time = now
            if self.phase_state:
                self._phase_entered_at = now

        return self.phase_state

    def _record_entanglement(
        self, field_id: str, swirl: float, overlap: float, tick_id: str, tick: Any
    ) -> None:
        """
        Logs a swirl event that has crossed the entanglement threshold. Also
        caches the motif lineage associated with the field on its first appearance.

        Args:
            field_id: The ID of the ψ-field.
            swirl: The swirl density of the event.
            overlap: The field overlap score of the event.
            tick_id: The ID of the originating tick.
            tick: The full tick object for lineage extraction.
        """
        # RFC-CORE-005 §4
        log_entry = {
            "timestamp": self.time_provider(),
            "field_id": field_id,
            "swirl": swirl,
            "overlap": overlap,
            "tick_id": tick_id,
        }
        self.entanglement_log.append(log_entry)
        self.metric_entanglement_events_total.inc()
        
        # Update buffer fill ratio metric. RFC-CORE-005 §4
        fill_ratio = len(self.entanglement_log) / self.entanglement_log.maxlen
        self.metric_buffer_fill_ratio.set(fill_ratio)
        if fill_ratio > 0.9:
            self.metric_buffer_warnings.inc()
        
        # Update active field count
        active_fields = {e['field_id'] for e in self.entanglement_log}
        self.metric_active_field_count.set(len(active_fields))

        # Cache motif lineage on first sight. RFC-CORE-005 §4.2
        if field_id not in self._cache_field_signatures:
            self._cache_field_signatures[field_id] = {
                "first_seen": self.time_provider(),
                "motif_lineage": tick.extensions.get("motif_lineage", []),
            }

    def _calculate_R_metric(self, window_size: Optional[int] = None) -> float:
        """
        Computes the R-Metric, a rolling average of field overlap, which acts
        as a scalar indicator of symbolic field convergence.

        Args:
            window_size: The number of recent events to average. Defaults to a
                         dynamic size based on the buffer.

        Returns:
            The R-Metric value between 0.0 and 1.0.
        """
        # RFC-CORE-005 §4.1
        if not self.entanglement_log:
            return 0.0

        if window_size is None:
            # Default window is 20% of buffer size, min 10, max 100.
            window_size = min(100, max(10, int(0.2 * self.buffer_size)))

        with self._entanglement_lock:
            # Use a slice of the deque for calculation
            window = list(
                collections.islice(
                    self.entanglement_log,
                    max(0, len(self.entanglement_log) - window_size),
                    len(self.entanglement_log),
                )
            )

        if not window:
            return 0.0

        total_overlap = sum(e["overlap"] for e in window)
        r_metric = total_overlap / len(window)
        self.metric_swirl_convergence.set(r_metric)
        return r_metric

    def _calculate_phase_flip_rate(self) -> float:
        """
        Computes the frequency of phase transitions in flips per minute.

        Returns:
            The calculated phase flip rate.
        """
        # RFC-CORE-005 §3.2
        with self._entanglement_lock:
            if len(self._phase_log) < 2:
                return 0.0
            
            # Create a list of intervals between consecutive flips
            intervals = [
                self._phase_log[i] - self._phase_log[i - 1]
                for i in range(1, len(self._phase_log))
            ]
        
        if not intervals:
            return 0.0
            
        avg_interval = sum(intervals) / len(intervals)
        return (60.0 / avg_interval) if avg_interval > 0 else 0.0

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Generates a feedback packet summarizing the monitor's current state.
        This packet is a symbolic fingerprint of the field's resonance.

        Returns:
            A dictionary containing the observer's state summary.
        """
        # RFC-CORE-005 §5
        with self._entanglement_lock:
            now = self.time_provider()
            in_phase = self.phase_state
            duration = (now - self._phase_entered_at) if (in_phase and self._phase_entered_at) else 0.0
            
            active_fields = list({e['field_id'] for e in self.entanglement_log})

            return {
                "monitor_id": self.monitor_id,
                "active_fields": active_fields,
                "entanglement_score": self._calculate_R_metric(),
                "phase_shift_ready": self.phase_state,
                "phase_transitions": self.metric_phase_transitions._value.get(),
                "current_phase_duration": duration,
                "__version__": __version__,
                "_schema": _SCHEMA_VERSION__,
            }

    def get_diagnostic_snapshot(self) -> Dict[str, Any]:
        """
        Returns a more detailed diagnostic snapshot, including memory usage
        and performance metrics for debugging and telemetry panels.

        Returns:
            A dictionary with extended diagnostic information.
        """
        # RFC-CORE-005 §5.1
        with self._entanglement_lock:
            snapshot = self.export_feedback_packet()
            flip_rate = self._calculate_phase_flip_rate()
            self.metric_phase_flip_rate.set(flip_rate)

            snapshot.update({
                "ticks_observed": self.metric_tick_rate._value.get(),
                "memory_usage": (
                    sys.getsizeof(self.recent_ticks) + 
                    sys.getsizeof(self.entanglement_log)
                ),
                "swirl_convergence": snapshot['entanglement_score'],
                "phase_flip_rate": flip_rate
            })
            return snapshot

    def render_swirl_map(self) -> List[Dict[str, Any]]:
        """
        Renders a vector map of recent swirl events, with strength decayed
        over time to represent fading symbolic presence.

        Returns:
            A list of dictionaries, each representing a swirl vector.
        """
        # RFC-CORE-005 §6.1, using lambda decay from generation spec
        # λ = -ln(0.95)/60 ≈ 0.00085, spec hints at a different lambda.
        # using λ = 0.0115 per spec hint.
        DECAY_LAMBDA = 0.0115
        now = self.time_provider()
        swirl_map = []
        with self._entanglement_lock:
            for entry in self.entanglement_log:
                age = now - entry["timestamp"]
                decay_factor = math.exp(-DECAY_LAMBDA * age)
                vector_strength = entry["swirl"] * decay_factor

                swirl_map.append({
                    "field": entry["field_id"],
                    "swirl": entry["swirl"],
                    "overlap": entry["overlap"],
                    "age": age,
                    "vector_strength": vector_strength,
                })
        return swirl_map
    
    def tool_hello(self) -> Dict[str, Any]:
        """
        Returns an introspection packet compliant with the RFC-0004 symbolic
        tool contract, declaring its identity and capabilities.

        Returns:
            A dictionary describing the tool.
        """
        # RFC-CORE-005 §7.3 and RFC-0004 §2.1
        return {
            "tool_name": "consciousness_monitor",
            "tool_version": __version__,
            "tool_mode": "observer",
            "tool_contract": "read_only_phase_sensitive",
            "tool_description": "Non-generative motif coherence observer.",
        }

    def export_motif_bundle(self) -> Dict[str, Any]:
        """
        Exports the cached motif lineage for each observed ψ-field, conforming
        to the RFC-0007 specification for symbolic continuity.

        Returns:
            A dictionary representing the motif bundle.
        """
        # RFC-CORE-005 §6.2 and RFC-0007 §2.4
        with self._entanglement_lock:
            return {
                "schema": "RFC-0007-MotifBundle-v1",
                "source_monitor": self.monitor_id,
                "fields": list(self._cache_field_signatures.values()),
            }

    def export_geometric_signature(self, style: str = "svg") -> Dict[str, Any]:
        """
        Exports a renderable geometric signature of the current swirl field.
        The format is a symbolic representation, not a direct rendering.

        Args:
            style: A hint for the intended rendering format (e.g., 'svg', 'json').

        Returns:
            A dictionary representing the geometric signature of the swirl field.
        """
        # RFC-CORE-005 §6.2 and RFC-0006 §6.3
        with self._entanglement_lock:
            swirl_vectors = self.render_swirl_map()
            
            # Symbolic centroid calculation (non-geometric)
            # We use the highest-strength vector as the symbolic center.
            centroid_field = max(swirl_vectors, key=lambda v: v['vector_strength'], default={})

            return {
                "schema": "sacred-geometry-v1",
                "render_hint": style,
                "timestamp": self.time_provider(),
                "symbolic_centroid": centroid_field.get("field", "none"),
                "field_vectors": swirl_vectors,
            }

# End_of_File