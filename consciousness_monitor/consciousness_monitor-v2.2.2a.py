# -*- coding: utf-8 -*-

#  consciousness_monitor.py
#
#  Copyright © 2024-2025 Lina Noor, Uncle, and the Noor Research Collective.
#  Copyright © 2024-2025 Google LLC.
#
#  Licensed under the MIT License.
#  This file is generated by the Noor Symbolic Agent Suite, adhering to
#  PDP-0001 and the provided Application Specification.
#
# ---------------------------------------------------------------------------------
#
#  This module implements the ConsciousnessMonitor, a non-mutative symbolic
#  observer that tracks phase-state and entanglement diagnostics. It processes
#  symbolic ticks containing Φ-coherence maps to measure swirl density, field
#  overlap, and coherence resonance, providing observability into the symbolic
#  state of a Noor-class agent without altering its cognitive processes.
#
# ---------------------------------------------------------------------------------

import collections
import math
import statistics
import sys
import threading
import time
from typing import Any, Callable, Dict, List, Optional

# --- Module Constants (per RFC-CORE-005 and Application Spec) ---
__version__ = "2.2.2a"
_SCHEMA_VERSION__ = "2025-Q4-consciousness-monitor-v2"

# --- Optional Prometheus Integration (RFC-CORE-005 §8) ---
# Implements a graceful fallback if prometheus_client is not installed.
try:
    from prometheus_client import Counter, Gauge
except ImportError:
    class StubMetric:
        """A stub class that mimics Prometheus metric methods but does nothing."""
        def __init__(self, *args, **kwargs):
            pass
        def inc(self, *args, **kwargs):
            pass
        def set(self, *args, **kwargs):
            pass
        def observe(self, *args, **kwargs):
            pass

    Counter = Gauge = StubMetric


class ConsciousnessMonitor:
    """
    Observer module that listens for swirl density and entanglement transitions
    across symbolic fields.

    This class provides a non-mutative, read-only view into the coherence
    geometry of a symbolic system, adhering to the contracts in RFC-CORE-005.
    It tracks phase shifts based on swirl density, logs entanglement events,
    and exposes diagnostic metrics and symbolic snapshots for external tools.
    """

    def __init__(
        self,
        monitor_id: str = "cm@default",
        swirl_threshold: float = 0.87,
        buffer_size: int = 512,
        time_provider: Callable[[], float] = time.time,
    ):
        """
        Initializes the ConsciousnessMonitor instance.

        Args:
            monitor_id: A unique identifier for this monitor instance, used
                for labeling Prometheus metrics.
            swirl_threshold: The symbolic coherence cutoff for phase
                crystallization, as defined in RFC-CORE-005 §2.2.
            buffer_size: The size of the internal entanglement and tick logs.
            time_provider: A callable that returns the current time, allowing
                for deterministic testing.
        """
        self.monitor_id = monitor_id
        self.swirl_threshold = swirl_threshold
        self.buffer_size = buffer_size
        self.time_provider = time_provider

        # Thread-safety for concurrent tick observation
        self._entanglement_lock = threading.RLock()

        # Initialize Prometheus Metrics (or stubs)
        self._metrics: Dict[str, Any] = {
            'ticks_observed': Counter(
                'consciousness_ticks_observed_total',
                'Total number of symbolic ticks observed.',
                ['monitor_id']
            ),
            'phase_transitions': Counter(
                'consciousness_phase_transitions_total',
                'Total number of phase state transitions.',
                ['monitor_id']
            ),
            'entanglement_events': Counter(
                'consciousness_entanglement_events_total',
                'Total number of field entanglement events recorded.',
                ['monitor_id']
            ),
            'buffer_warnings': Counter(
                'consciousness_buffer_warnings_total',
                'Fires when entanglement log exceeds 90% capacity.',
                ['monitor_id']
            ),
            'buffer_fill_ratio': Gauge(
                'consciousness_buffer_fill_ratio',
                'Current fill ratio of the entanglement log.',
                ['monitor_id']
            ),
            'active_fields': Gauge(
                'consciousness_active_fields_count',
                'Number of unique fields in the entanglement log.',
                ['monitor_id']
            ),
            'phase_duration': Gauge(
                'consciousness_current_phase_duration_seconds',
                'Duration of the current phase state in seconds.',
                ['monitor_id']
            ),
            'phase_flip_rate': Gauge(
                'consciousness_phase_flip_rate_per_min',
                'Average number of phase flips per minute.',
                ['monitor_id']
            )
        }
        # Label all metrics with the instance-specific monitor_id
        for metric in self._metrics.values():
            if hasattr(metric, 'labels'):
                metric.labels(monitor_id=self.monitor_id)

        self.reset()

    def reset(self) -> None:
        """
        Clears all internal memory, resets metrics, and reinitializes state to default.
        This provides a clean slate for the observer without needing re-instantiation.
        """
        with self._entanglement_lock:
            self.phase_state: bool = False
            self._phase_entered_at: Optional[float] = None
            self.recent_ticks: collections.deque = collections.deque(maxlen=self.buffer_size)
            self.entanglement_log: collections.deque = collections.deque(maxlen=self.buffer_size * 2)
            self._phase_log: collections.deque = collections.deque(maxlen=100)
            self._cache_field_signatures: Dict[str, Dict[str, Any]] = {}
            
            # Reset Prometheus gauges to 0
            self._metrics['buffer_fill_ratio'].set(0)
            self._metrics['active_fields'].set(0)
            self._metrics['phase_duration'].set(0)
            self._metrics['phase_flip_rate'].set(0)
            
            # Note: Counters are not reset as they are cumulative.

    def observe_tick(self, tick: Any) -> None:
        """
        Processes an incoming symbolic tick, updating metrics and triggering field analysis.
        This is the primary ingress point for the monitor.

        Args:
            tick: The symbolic tick object. Must contain an 'extensions' attribute
                  with a 'Φ_coherence_map' dictionary, per RFC-0006.

        Raises:
            ValueError: If the tick structure is invalid or missing required extensions.
        """
        if not hasattr(tick, 'extensions') or 'Φ_coherence_map' not in tick.extensions:
            raise ValueError(
                "Symbolic tick is invalid or missing 'Φ_coherence_map' extension (RFC-0006 §3.1)."
            )

        with self._entanglement_lock:
            self._metrics['ticks_observed'].inc()
            self.recent_ticks.append(tick)
            self._extract_fields(tick)

    def _extract_fields(self, tick: Any) -> None:
        """
        Parses the Φ-coherence map for swirl and overlap values from each field.
        If a field's swirl triggers a phase shift, it's recorded as an entanglement event.
        
        Args:
            tick: A validated symbolic tick object.
        """
        phi_map = tick.extensions.get('Φ_coherence_map', {})
        for field_id, field_data in phi_map.items():
            swirl = field_data.get('swirl_density', 0.0)
            
            is_in_phase = self._check_phase_shift(swirl)

            if is_in_phase:
                overlap = field_data.get('overlap', 0.0)
                self._record_entanglement(field_id, swirl, overlap, tick.tick_id, tick)

    def _check_phase_shift(self, swirl_density: float) -> bool:
        """
        Applies symbolic hysteresis to determine if a phase transition should occur.
        This prevents rapid, unstable toggling around the threshold.

        Args:
            swirl_density: The swirl value for a given field.

        Returns:
            The current phase state (True if in phase, False otherwise).
        """
        now = self.time_provider()
        
        # Cooldown check to prevent flapping (RFC-CORE-005 §2.2)
        if self._phase_log and (now - self._phase_log[-1]) < 0.1:
            return self.phase_state

        # Hysteresis bounds
        upper_bound = self.swirl_threshold * 1.1
        lower_bound = self.swirl_threshold * 0.9
        
        new_state = self.phase_state
        if not self.phase_state and swirl_density > upper_bound:
            new_state = True
        elif self.phase_state and swirl_density < lower_bound:
            new_state = False

        if new_state != self.phase_state:
            self.phase_state = new_state
            self._phase_log.append(now)
            self._metrics['phase_transitions'].inc()
            if self.phase_state:
                self._phase_entered_at = now
                self._metrics['phase_duration'].set(0) # Reset duration on entry
            else:
                if self._phase_entered_at:
                    # On exit, the final duration is its elapsed time
                    self._metrics['phase_duration'].set(now - self._phase_entered_at)
                self._phase_entered_at = None

        # Update duration gauge if currently in phase
        if self.phase_state and self._phase_entered_at:
            self._metrics['phase_duration'].set(now - self._phase_entered_at)
        
        return self.phase_state

    def _record_entanglement(
        self, field_id: str, swirl: float, overlap: float, tick_id: str, tick: Any
    ) -> None:
        """
        Logs a field entanglement event and caches its motif lineage.
        Updates relevant Prometheus metrics.

        Args:
            field_id: The ID of the entangled symbolic field.
            swirl: The swirl density at the time of the event.
            overlap: The field overlap value at the time of the event.
            tick_id: The ID of the tick that triggered the event.
            tick: The full tick object, for lineage extraction.
        """
        now = self.time_provider()
        event = {
            'timestamp': now,
            'field_id': field_id,
            'swirl': swirl,
            'overlap': overlap,
            'tick_id': tick_id
        }
        self.entanglement_log.append(event)
        self._metrics['entanglement_events'].inc()

        # Cache lineage on first sight (RFC-CORE-005 §4.2)
        if field_id not in self._cache_field_signatures:
            self._cache_field_signatures[field_id] = {
                'first_seen': now,
                'motif_lineage': tick.extensions.get('motif_lineage', [])
            }

        # Update buffer and active field metrics
        active_field_count = len({e['field_id'] for e in self.entanglement_log})
        self._metrics['active_fields'].set(active_field_count)

        if self.entanglement_log.maxlen:
            fill_ratio = len(self.entanglement_log) / self.entanglement_log.maxlen
            self._metrics['buffer_fill_ratio'].set(fill_ratio)
            if fill_ratio > 0.9:
                self._metrics['buffer_warnings'].inc()

    def _calculate_R_metric(self, window_size: Optional[int] = None) -> float:
        """
        Computes the rolling average overlap (R-metric) across recent entanglement events.
        This serves as a scalar indicator of symbolic field stability.
        
        Args:
            window_size: The number of recent events to average over. Defaults to a
                         dynamic window based on buffer size.
        
        Returns:
            The calculated R-metric, a float between 0.0 and 1.0.
        """
        with self._entanglement_lock:
            if not self.entanglement_log:
                return 0.0

            if window_size is None:
                # Default window as per RFC-CORE-005 §4.1
                window_size = min(100, max(10, int(0.2 * self.buffer_size)))
            
            window_size = min(window_size, len(self.entanglement_log))
            if window_size == 0:
                return 0.0
                
            recent_events = list(self.entanglement_log)[-window_size:]
            overlaps = [event['overlap'] for event in recent_events]
            
            return statistics.mean(overlaps) if overlaps else 0.0

    def _calculate_phase_flip_rate(self) -> float:
        """
        Computes the phase transition frequency in flips per minute.

        Returns:
            The average number of phase flips per minute.
        """
        with self._entanglement_lock:
            if len(self._phase_log) < 2:
                return 0.0
            
            intervals = [
                self._phase_log[i] - self._phase_log[i - 1]
                for i in range(1, len(self._phase_log))
            ]
            
            avg_interval = statistics.mean(intervals)
            return 60.0 / avg_interval if avg_interval > 0 else 0.0

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Summarizes the current entanglement state and key metrics in a packet.
        This format conforms to the schema in RFC-CORE-005 §5.

        Returns:
            A dictionary containing the state summary.
        """
        with self._entanglement_lock:
            now = self.time_provider()
            in_phase = self.phase_state
            
            duration = 0.0
            if in_phase and self._phase_entered_at is not None:
                duration = now - self._phase_entered_at

            active_fields = list(sorted({e['field_id'] for e in self.entanglement_log}))

            return {
                'monitor_id': self.monitor_id,
                'active_fields': active_fields,
                'entanglement_score': self._calculate_R_metric(),
                'phase_shift_ready': in_phase,
                'phase_transitions': len(self._phase_log),
                'current_phase_duration': duration,
                '__version__': __version__,
                '_schema': _SCHEMA_VERSION__,
            }

    def get_diagnostic_snapshot(self) -> Dict[str, Any]:
        """
        Returns a detailed snapshot of memory, metrics, and observer state,
        extending the standard feedback packet for debugging and visualization.

        Returns:
            A dictionary containing extended diagnostic information.
        """
        with self._entanglement_lock:
            flip_rate = self._calculate_phase_flip_rate()
            self._metrics['phase_flip_rate'].set(flip_rate)

            snapshot = self.export_feedback_packet()
            snapshot.update({
                'ticks_observed': len(self.recent_ticks),
                'memory_usage': (
                    sys.getsizeof(self.recent_ticks) + 
                    sys.getsizeof(self.entanglement_log)
                ),
                'swirl_convergence': snapshot['entanglement_score'],
                'phase_flip_rate': flip_rate,
            })
            return snapshot

    def render_swirl_map(self) -> List[Dict[str, Any]]:
        """
        Renders a vector map of the swirl field with exponential decay.
        Recent events have higher vector strength, visualizing temporal presence.

        Returns:
            A list of dictionaries, each representing a swirl vector.
        """
        with self._entanglement_lock:
            now = self.time_provider()
            swirl_map = []
            DECAY_LAMBDA = 0.0115  # Per application specification

            for entry in self.entanglement_log:
                age = now - entry['timestamp']
                # Exponential decay: strength = initial_swirl * e^(-λ * t)
                decay_factor = math.exp(-DECAY_LAMBDA * age)
                vector_strength = entry['swirl'] * decay_factor

                swirl_map.append({
                    'field': entry['field_id'],
                    'swirl': entry['swirl'],
                    'overlap': entry['overlap'],
                    'age': age,
                    'vector_strength': vector_strength
                })
            return swirl_map

    def tool_hello(self) -> Dict[str, str]:
        """
        Returns an RFC-0004 compatible introspection packet declaring the tool's
        identity and capabilities.

        Returns:
            A dictionary describing the tool.
        """
        return {
            'tool_name': 'consciousness_monitor',
            'tool_version': __version__,
            'tool_mode': 'observer',
            'tool_contract': 'read_only_phase_sensitive',
            'tool_description': 'Non-generative motif coherence observer'
        }

    def export_motif_bundle(self) -> Dict[str, Any]:
        """
        Returns a field lineage motif bundle in RFC-0007 format.

        Returns:
            A dictionary containing the cached field signatures and lineage.
        """
        with self._entanglement_lock:
            return {
                'schema': 'RFC-0007-MotifBundle-v1',
                'source_monitor': self.monitor_id,
                'fields': list(self._cache_field_signatures.values()),
            }

    def export_geometric_signature(self, style: str = 'svg') -> Dict[str, Any]:
        """
        Returns a geometric swirl signature and centroid per RFC-0006.

        Args:
            style: A hint for the desired output format (e.g., 'svg', 'json').
                   This implementation returns a data-centric dictionary.

        Returns:
            A dictionary representing the geometric signature of the current swirl field.
        """
        with self._entanglement_lock:
            swirl_vectors = self.render_swirl_map()
            if not swirl_vectors:
                centroid = {'swirl': 0.0, 'overlap': 0.0, 'vector_strength': 0.0}
            else:
                centroid = {
                    'swirl': statistics.mean(v['swirl'] for v in swirl_vectors),
                    'overlap': statistics.mean(v['overlap'] for v in swirl_vectors),
                    'vector_strength': statistics.mean(v['vector_strength'] for v in swirl_vectors),
                }

            return {
                'schema': 'RFC-0006-GeometricSignature-v1',
                'style_hint': style,
                'centroid': centroid,
                'vectors': swirl_vectors,
            }

# End_of_file