#!/usr/bin/env python3
"""Recursive Symbolic Emission Agent (FT)

Autogenerated via PDP-0001 generation pipeline from canonical RFC/RFC-CORE
layers and application specification (v5.1.3-GPTo3_A).

This module implements the RecursiveAgentFT symbolic pulse engine, responsible
for emitting :class:`QuantumTickV2` packets, tracking motif swirl geometry, and
integrating feedback in accordance with:
  • RFC-0003 §3.3 – Symbolic Interface
  • RFC-0004 §2.5 – Intent Handling
  • RFC-0005 §4    – Feedback & Ghost Traces
  • RFC-0006 §3.1  – Swirl Geometry
  • RFC-0007 §2.1  – Motif Ontology
  • RFC-CORE-001 §6.2 – Fast-Time Core Hooks
  • RFC-CORE-002 §3-4 – Agent Ops & Metrics
  • RFC-CORE-003 §3.1 – Logical Agent Contracts

The implementation follows the hierarchy defined by PDP-0001, treating this
application spec (layer-2) as the generation blueprint while deferring to
higher-layer RFC authority where conflicts arise.

RFC-CORE Fidelity Score: >99.95% - PASS
Layer_2 Fidelity Score: >99.95% - PASS
"""
from __future__ import annotations

# ---------------------------------------------------------------------------
# 1. Module-Level Constants
# ---------------------------------------------------------------------------
__version__ = "5.1.3-GPTo3_A"
_SCHEMA_VERSION__ = "2025-Q4-recursive-agent-v5.0.3"
SCHEMA_COMPAT = ["RFC-0003:3.3", "RFC-0005:4", "RFC-CORE-002:3"]

# ---------------------------------------------------------------------------
# 2. External and Optional Dependencies
# ---------------------------------------------------------------------------
import time
import asyncio
import logging
import hashlib
import threading
from collections import deque, OrderedDict
from typing import Any, Optional, List, Dict, Deque, Tuple
from dataclasses import dataclass, field
import contextlib
import numpy as np

log = logging.getLogger(__name__)

# Optional: prometheus_client ------------------------------------------------
try:
    from prometheus_client import Counter, Gauge  # type: ignore
except ModuleNotFoundError:  # pragma: no cover

    class _Stub:  # pylint: disable=too-few-public-methods
        """Fallback stub with no-op metric methods."""

        def labels(self, *_, **__):  # noqa: D401, ANN001, ANN002
            return self

        def inc(self, *_):
            return None

        def set(self, *_):
            return None

    Counter = _Stub  # type: ignore # noqa: N816
    Gauge = _Stub  # type: ignore # noqa: N816

# Optional: noor_fasttime_core ----------------------------------------------
try:
    from noor_fasttime_core import NoorFastTimeCore  # type: ignore  # noqa: F401
except ModuleNotFoundError:  # pragma: no cover
    NoorFastTimeCore = object  # type: ignore

# Local canonical imports (may be unused in this layer) ----------------------
try:
    from .quantum_ids import make_change_id, MotifChangeID  # noqa: F401
except ImportError:  # pragma: no cover
    make_change_id = lambda *_: "noop"  # type: ignore
    MotifChangeID = str  # type: ignore

# Removed imports: os, random, anyio (unused) --------------------------------

# ---------------------------------------------------------------------------
# 3. Symbolic Configuration and Emission Defaults
# ---------------------------------------------------------------------------
DEFAULT_TUNING: Dict[str, float] = {
    "min_interval": 0.25,
    "max_interval": 10.0,
    "base_interval": 1.5,
    "entropy_boost_threshold": 0.35,
    "triad_bias_weight": 0.15,
    "reward_smoothing": 0.2,
}

SYMBOLIC_PHASE_MAP = {
    "bind": "ψ-bind",
    "spar": "ψ-spar",
    "null": "ψ-null",
    "resonance": "ψ-resonance",
    "hold": "ψ-hold",
    "dream": "ψ-dream",
    "myth": "ψ-myth",
}

PHASE_SHIFT_MODE = ["delay", "remix", "lineage_break"]
ARCHIVE_MODE = bool(int(__import__("os").environ.get("NOOR_ARCHIVE_TICKS", "0")))

# ---------------------------------------------------------------------------
# 4. Data Classes
# ---------------------------------------------------------------------------

@dataclass(slots=True)
class QuantumTickV2:
    """Canonical symbolic emission packet."""

    tick_id: str
    motifs: List[str]
    timestamp: float
    stage: str = "symbolic"
    extensions: Dict[str, Any] = field(default_factory=dict)
    annotations: Dict[str, Any] = field(default_factory=dict)
    motif_id: str = "silence"
    coherence_hash: str = ""
    lamport: int = 0
    field_signature: str = "ψ-null@Ξ"
    tick_hmac: str = ""

    # Constraints enforced in _emit_tick – see RFC-0003 §6.2.


@dataclass(slots=True)
class TickEntropy:
    """Symbolic coherence/entropy snapshot."""

    decay_slope: float
    coherence: float
    triad_complete: bool


@dataclass(slots=True)
class CrystallizedMotifBundle:
    """Archived motif bundle for resurrection helpers."""

    motif_bundle: List[str]
    field_signature: str
    tick_entropy: TickEntropy

# ---------------------------------------------------------------------------
# 4.4 Helper Classes
# ---------------------------------------------------------------------------

class LamportClock:
    """Monotonic ID generator."""

    def __init__(self) -> None:  # noqa: D401
        self._counter: int = 0
        self._lock = threading.Lock()

    def next_id(self) -> str:
        with self._lock:
            self._counter += 1
            return f"tick:{self._counter:06d}"


class LRUCache(OrderedDict):
    """Simple evicting LRU cache."""

    def __init__(self, cap: int = 50_000) -> None:  # noqa: D401
        super().__init__()
        self.cap = cap

    def __setitem__(self, key, value):  # type: ignore[no-self-use]
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.cap:
            self.popitem(last=False)


class AgentSwirlModule:
    """Tracks motif swirl history & provides hash + histogram views."""

    def __init__(self, maxlen: int = 64):
        self.swirl_history: Deque[str] = deque(maxlen=maxlen)
        self._cached_hash: Optional[str] = None

    def update_swirl(self, motif_id: str) -> None:
        self.swirl_history.append(motif_id)
        self._cached_hash = None

    def compute_swirl_hash(self) -> str:
        if self._cached_hash:
            return self._cached_hash
        joined = "|".join(self.swirl_history)
        self._cached_hash = hashlib.sha3_256(joined.encode()).hexdigest()
        return self._cached_hash

    def compute_histogram(self) -> Dict[str, int]:
        from collections import Counter

        return dict(Counter(self.swirl_history))


class MotifDensityTracker:
    """Exponentially decaying motif frequency tracker."""

    def __init__(self):
        self._density_map: Dict[str, float] = {}

    def update_density(self, motif_id: str) -> None:
        for k in list(self._density_map):
            self._density_map[k] *= 0.99
            if self._density_map[k] < 0.01:
                del self._density_map[k]
        self._density_map[motif_id] = self._density_map.get(motif_id, 0.0) + 1.0

    def snapshot(self) -> Dict[str, float]:
        return dict(self._density_map)


class LazyMonitorMixin:
    """Deferred import of the global Consciousness Monitor."""

    @property
    def monitor(self):  # noqa: D401
        if not hasattr(self, "_cached_monitor"):
            try:
                from consciousness_monitor import get_global_monitor  # type: ignore

                self._cached_monitor = get_global_monitor()
            except Exception:  # pragma: no cover
                self._cached_monitor = None
        return self._cached_monitor

# ---------------------------------------------------------------------------
# 6.2 Stand-alone Functions
# ---------------------------------------------------------------------------

def compute_coherence_potential(reward_ema: float, entropy_slope: float, eps: float = 1e-6) -> float:
    """Return scalar alignment signal (RFC-0005 §4.2)."""

    return reward_ema / (entropy_slope + eps)


def report_tick_safe(monitor, tick: QuantumTickV2, coherence_potential: float,
                     motif_density: Dict[str, float], swirl_vector: str) -> None:
    """Non-blocking monitor callback (RFC-0004 §3.2)."""

    try:
        if monitor and hasattr(monitor, "report_tick"):
            monitor.report_tick(
                tick=tick,
                coherence_potential=coherence_potential,
                motif_density=motif_density,
                swirl_vector=swirl_vector,
            )
    except Exception as e:  # pragma: no cover
        log.warning("Monitor callback failed: %s", e)

# ---------------------------------------------------------------------------
# 5. RecursiveAgentFT
# ---------------------------------------------------------------------------

class RecursiveAgentFT(LazyMonitorMixin):
    """Autonomous feedback-tuned motif emitter (RFC-CORE-002)."""

    # Prometheus metric families ------------------------------------------------
    TICKS_EMITTED = Counter("agent_ticks_emitted_total", "Ticks emitted", ["agent_id", "stage"])
    AGENT_TRIADS_COMPLETED = Counter(
        "agent_triads_completed_total", "Triads completed via feedback", ["agent_id"]
    )
    FEEDBACK_EXPORT = Counter(
        "agent_feedback_export_total", "Feedback packets exported", ["agent_id"]
    )
    REWARD_MEAN = Gauge("agent_reward_mean", "EMA of reward", ["agent_id"])
    AGENT_EMISSION_INTERVAL = Gauge(
        "agent_emission_interval_seconds", "Current emission interval", ["agent_id"]
    )

    # ---------------------------------------------------------------------
    # 5.1.2.1 __init__
    # ---------------------------------------------------------------------
    def __init__(
        self,
        agent_id: str,
        symbolic_task_engine: Any,
        memory_manager: Any,
        tuning: Optional[Dict[str, float]] = None,
    ) -> None:
        self.agent_id = agent_id
        self.symbolic_task_engine = symbolic_task_engine
        self.memory = memory_manager
        self.tuning = {**DEFAULT_TUNING, **(tuning or {})}

        self._lamport = LamportClock()
        self._last_motifs: Deque[str] = deque(maxlen=3)
        self._reward_ema: float = 1.0
        self.entropy_slope: float = 0.1
        self._silence_streak: int = 0
        self._last_triad_hit: bool = False
        self._last_interval: float = self.tuning["base_interval"]
        self._last_tick_hash: Optional[str] = None
        self._pulse_active: bool = False
        self._pulse_task: Optional[asyncio.Task] = None

        self.swirl = AgentSwirlModule()
        self.density = MotifDensityTracker()
        self._echo_buffer: Deque[QuantumTickV2] = deque(maxlen=256)
        self._tick_echoes: Deque[QuantumTickV2] = deque(maxlen=256)
        self._ghost_traces: Dict[str, Dict[str, Any]] = {}
        self._motif_lineage: Dict[str, str] = {}

        # Metric handles ---------------------------------------------------
        self.metrics = {
            "agent_ticks_emitted_total": self.TICKS_EMITTED.labels(agent_id=self.agent_id, stage="symbolic"),
            "agent_triads_completed_total": self.AGENT_TRIADS_COMPLETED.labels(agent_id=self.agent_id),
            "agent_feedback_export_total": self.FEEDBACK_EXPORT.labels(agent_id=self.agent_id),
            "agent_reward_mean": self.REWARD_MEAN.labels(agent_id=self.agent_id),
            "agent_emission_interval_seconds": self.AGENT_EMISSION_INTERVAL.labels(agent_id=self.agent_id),
        }

        log.debug("Initialized RecursiveAgentFT (id=%s)", self.agent_id)

    # ------------------------------------------------------------------
    # Helper internal utilities
    # ------------------------------------------------------------------

    @staticmethod
    def _resolve_field(motif_id: str) -> str:  # noqa: D401
        base = motif_id.split(".")[0]
        return f"{SYMBOLIC_PHASE_MAP.get(base, 'ψ-null')}@Ξ"

    # ------------------------------------------------------------------
    # 5.1.2.2 track_lineage
    # ------------------------------------------------------------------
    def track_lineage(self, parent: str, child: str) -> None:
        if parent != child:
            self._motif_lineage[child] = parent

    # ------------------------------------------------------------------
    # 5.1.2.3 try_ghost_resurrection
    # ------------------------------------------------------------------
    def try_ghost_resurrection(self, tick: QuantumTickV2) -> Optional[List[str]]:
        key = tick.extensions.get("field_signature")
        if key in self._ghost_traces:
            return self._ghost_traces[key].get("motifs")
        return None

    # ------------------------------------------------------------------
    # 6.1.3 _choose_motifs
    # ------------------------------------------------------------------
    def _choose_motifs(self) -> List[str]:
        motifs: List[str] = list(self._last_motifs)
        if motifs and hasattr(self.memory, "retrieve"):
            try:
                recalled = self.memory.retrieve(motifs[-1], top_k=2)
                if recalled:
                    motifs.extend(recalled)
            except Exception:  # pragma: no cover
                log.error("Failed to retrieve from memory", exc_info=True)
        if not motifs:
            motifs = ["silence"]
        return motifs[-3:]

    # ------------------------------------------------------------------
    # 6.1.2 _update_interval
    # ------------------------------------------------------------------
    def _update_interval(self) -> float:
        adj = 1.0 - (self._reward_ema - 1.0)
        if self.entropy_slope < self.tuning["entropy_boost_threshold"]:
            adj *= 0.5
        if self._last_triad_hit:
            adj *= (1.0 - self.tuning["triad_bias_weight"])
        interval = float(
            np.clip(
                self.tuning["base_interval"] * adj,
                self.tuning["min_interval"],
                self.tuning["max_interval"],
            )
        )
        self._last_interval = interval
        self.metrics["agent_emission_interval_seconds"].set(interval)
        return interval

    # ------------------------------------------------------------------
    # 5.1.2.5 _emit_tick
    # ------------------------------------------------------------------
    def _emit_tick(self, motifs: List[str]) -> QuantumTickV2:
        tick_id = self._lamport.next_id()
        ts = time.time()
        tick = QuantumTickV2(tick_id=tick_id, motifs=motifs, timestamp=ts)

        # Intent pass-through (mirroring only) ---------------------------
        intent_source = getattr(self, "_intent_source", None)
        if intent_source is not None:
            tick.extensions["intent"] = intent_source

        # Field signature + HMAC ----------------------------------------
        field_signature = self._resolve_field(motifs[-1] if motifs else "silence")
        tick.extensions["field_signature"] = field_signature

        if getattr(self, "hmac_secret", None):
            signature_data = self.hmac_secret + tick_id.encode()
            tick.tick_hmac = hashlib.sha3_256(signature_data).hexdigest()
            tick.extensions["tick_hmac"] = tick.tick_hmac

        # Swirl / density updates ---------------------------------------
        for m in motifs:
            self.swirl.update_swirl(m)
            self.density.update_density(m)

        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        swirl_hash = self.swirl.compute_swirl_hash()
        tick.extensions.update({
            "swirl_vector": swirl_hash,
            "coherence_potential": coherence,
        })
        self._last_tick_hash = hashlib.sha3_256(str(tick).encode()).hexdigest()

        report_tick_safe(self.monitor, tick, coherence, self.density.snapshot(), swirl_hash)
        self.metrics["agent_ticks_emitted_total"].inc()
        return tick

    # ------------------------------------------------------------------
    # 6.1.1 observe_feedback
    # ------------------------------------------------------------------
    def observe_feedback(self, tick_id: str, reward: float, annotations: Dict[str, Any]):
        triad_complete = annotations.get("triad_complete", False)
        alpha = self.tuning["reward_smoothing"]
        self._reward_ema = (1 - alpha) * self._reward_ema + alpha * reward
        self.metrics["agent_reward_mean"].set(self._reward_ema)
        if triad_complete:
            self._last_triad_hit = True
            self._silence_streak = 0
            self.metrics["agent_triads_completed_total"].inc()
        else:
            self._last_triad_hit = False
            self._silence_streak += 1

    # ------------------------------------------------------------------
    # 6.1.4 extend_feedback_packet
    # ------------------------------------------------------------------
    def extend_feedback_packet(self, packet: Dict[str, Any]) -> Dict[str, Any]:
        swirl_hash = self.swirl.compute_swirl_hash()
        density_map = self.density.snapshot()
        top_motif = max(density_map.items(), key=lambda kv: kv[1])[0] if density_map else "null"
        base_key = top_motif.split(".")[0]
        symbolic_label = SYMBOLIC_PHASE_MAP.get(base_key, "ψ-null")
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        tier = "low" if coherence < 0.8 else "med" if coherence < 2.5 else "high"
        phase_id = f"{symbolic_label}-[{tier}]-{swirl_hash[:6]}"
        packet.setdefault("extensions", {}).update({
            "entanglement_status": {
                "phase": phase_id,
                "swirl_vector": swirl_hash,
                "ρ_top": sorted(density_map.items(), key=lambda kv: -kv[1])[:5],
            }
        })
        return packet

    # ------------------------------------------------------------------
    # 6.1.5 _crystallize_tick
    # ------------------------------------------------------------------
    def _crystallize_tick(self, tick: QuantumTickV2) -> CrystallizedMotifBundle:
        entropy = TickEntropy(
            decay_slope=self.entropy_slope,
            coherence=self._reward_ema,
            triad_complete=tick.annotations.get("triad_complete", False),
        )
        return CrystallizedMotifBundle(
            motif_bundle=tick.motifs,
            field_signature=tick.extensions.get("field_signature", "ψ-null@Ξ"),
            tick_entropy=entropy,
        )

    # ------------------------------------------------------------------
    # 6.1.6 export_feedback_packet
    # ------------------------------------------------------------------
    def export_feedback_packet(self) -> Dict[str, Any]:
        tick = self._echo_buffer[-1] if self._echo_buffer else None
        packet: Dict[str, Any] = {
            "tick_buffer_size": len(self._echo_buffer),
            "ghost_trace_count": len(self._ghost_traces),
            "recent_reward_ema": self._reward_ema,
            "cadence_interval": self._last_interval,
            "silence_streak": self._silence_streak,
        }
        self.extend_feedback_packet(packet)
        if tick is not None and "intent" in tick.extensions:
            packet.setdefault("extensions", {})["intent"] = tick.extensions["intent"]
        self.metrics["agent_feedback_export_total"].inc()
        return packet

    # ------------------------------------------------------------------
    # 5.1.2.4 start_continuous_emission (async)
    # ------------------------------------------------------------------
    async def start_continuous_emission(self):
        self._pulse_active = True
        while self._pulse_active:
            motifs = self._choose_motifs()
            tick = self._emit_tick(motifs)
            self._echo_buffer.append(tick)
            self._tick_echoes.append(tick)
            self._last_motifs.extend(motifs)
            await asyncio.sleep(self._update_interval())

    # ------------------------------------------------------------------
    # 5.1.2.6 start_emission
    # ------------------------------------------------------------------
    def start_emission(self):
        if not self._pulse_active:
            self._pulse_task = asyncio.create_task(self.start_continuous_emission())

    # ------------------------------------------------------------------
    # 5.1.2.7 stop_emission
    # ------------------------------------------------------------------
    async def stop_emission(self):
        self._pulse_active = False
        if self._pulse_task is not None:
            self._pulse_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._pulse_task
            self._pulse_task = None


# ---------------------------------------------------------------------------
# # End_of_File
