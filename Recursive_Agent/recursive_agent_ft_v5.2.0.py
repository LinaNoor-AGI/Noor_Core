# Copyright 2024 Google LLC.
#
# Licensed under the MIT License;
#
#     https://www.opensource.org/licenses/mit-license.php
#
# Generated by Gemini 2.5 Pro (Google AI Studio)

"""
Merged agent for symbolic tick emission, swirl coherence feedback, ghost replay,
and triad-resonance feedback handling. Fully RFC-aligned and
regeneration-ready.

Canonical Source: RFC-CORE-002
Version: v5.2.0
"""

import os
import time
import asyncio
import logging
import hashlib
import threading
import random
from collections import deque, OrderedDict
from typing import Any, Optional, List, Dict, Deque, Tuple
from dataclasses import dataclass, field
import contextlib
import numpy as np

# --- Module-Level Constants (Section 1) ---
__version__ = "5.2.0"
_SCHEMA_VERSION__ = "2025-Q4-recursive-agent-v5.0.3"
SCHEMA_COMPAT = ["RFC-0003:3.3", "RFC-0005:4", "RFC-CORE-002:3"]

# --- External and Optional Dependencies (Section 2) ---
try:
    from prometheus_client import Counter, Gauge
except ImportError:
    class _Stub:
        def labels(self, *_, **__): return self
        def inc(self, *_): pass
        def set(self, *_): pass
    Counter = _Stub
    Gauge = _Stub

try:
    from noor_fasttime_core import NoorFastTimeCore
except ImportError:
    NoorFastTimeCore = object

try:
    import anyio
except ImportError:
    anyio = None

# Local imports (assuming quantum_ids.py is in the same package)
# from .quantum_ids import make_change_id, MotifChangeID # noqa: F401

# --- Symbolic Configuration and Emission Defaults (Section 3) ---
# RFC-0003 §3.3, RFC-CORE-002 §4.2
DEFAULT_TUNING = {
    "min_interval": 0.25,
    "max_interval": 10.0,
    "base_interval": 1.5,
    "entropy_boost_threshold": 0.35,
    "triad_bias_weight": 0.15,
    "reward_smoothing": 0.2,
}

# RFC-0007 §2.1, RFC-0005 §4.2
SYMBOLIC_PHASE_MAP = {
    "bind": "ψ‑bind",
    "spar": "ψ‑spar",
    "null": "ψ‑null",
    "resonance": "ψ‑resonance",
    "hold": "ψ‑hold",
    "dream": "ψ‑dream",
    "myth": "ψ‑myth",
}

PHASE_SHIFT_MODE = ["delay", "remix", "lineage_break"]
ARCHIVE_MODE = os.environ.get("NOOR_ARCHIVE_TICKS") == '1'

log = logging.getLogger(__name__)

# --- Data Classes (Section 4) ---

@dataclass(slots=True)
class QuantumTickV2:
    """
    Canonical Symbolic Emission Format. Represents a single symbolic pulse
    emitted by the agent.

    Anchors: RFC-0003 §6.2, RFC-0004 §2.5, RFC-CORE-001 §6.2, RFC-CORE-003 §3.1
    """
    tick_id: str
    motifs: List[str]
    timestamp: float
    stage: str = "symbolic"
    extensions: Dict[str, Any] = field(default_factory=dict)
    annotations: Dict[str, Any] = field(default_factory=dict)
    motif_id: str = "silence"
    coherence_hash: str = ""
    lamport: int = 0
    field_signature: str = "ψ-null@Ξ"
    tick_hmac: str = ""
    # The 'intent' key in `extensions` is special. It is mirrored from an
    # upstream transport envelope (per RFC-0003 §6.2) after being
    # canonicalized by that transport (per RFC-0004 §2.5). This agent
    # MUST NOT mutate it and MUST pass it through for observability.
    # Consumer logic for 'intent' lives in other RFC-CORE modules.

@dataclass(slots=True)
class TickEntropy:
    """
    Represents the symbolic coherence and triad state of a tick.
    Anchor: RFC-0003 §3.3
    """
    decay_slope: float
    coherence: float
    triad_complete: bool

@dataclass(slots=True)
class CrystallizedMotifBundle:
    """
    Archival format for a symbolic emission, preserving its field context.
    Anchor: RFC-0005 §3.3
    """
    motif_bundle: List[str]
    field_signature: str
    tick_entropy: TickEntropy

# --- Helper Classes (Section 4.4.0) ---

class LamportClock:
    """Logical counter used to generate ordered tick IDs."""
    def __init__(self):
        self._counter = 0

    def next_id(self) -> str:
        self._counter += 1
        return f"tick:{self._counter:06d}"

class LRUCache(OrderedDict):
    """Evicting cache structure for recent state retention."""
    def __init__(self, cap: int = 50000):
        super().__init__()
        self.cap = cap

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.cap:
            self.popitem(last=False)

class AgentSwirlModule:
    """
    Encodes motif swirl dynamics as hash vectors for field coherence tracking.
    Anchor: RFC-0006 §3.1
    """
    def __init__(self, maxlen: int = 64):
        self.swirl_history: Deque[str] = deque(maxlen=maxlen)
        self._cached_hash: Optional[str] = None

    def update_swirl(self, motif_id: str):
        self.swirl_history.append(motif_id)
        self._cached_hash = None

    def compute_swirl_hash(self) -> str:
        if self._cached_hash:
            return self._cached_hash
        joined = '|'.join(self.swirl_history)
        self._cached_hash = hashlib.sha3_256(joined.encode()).hexdigest()
        return self._cached_hash

    def compute_histogram(self) -> Dict[str, int]:
        return {motif: self.swirl_history.count(motif) for motif in set(self.swirl_history)}

class MotifDensityTracker:
    """
    Tracks frequency of motif emissions over time with exponential decay.
    Anchor: RFC-0005 §4.2
    """
    def __init__(self):
        self._density_map: Dict[str, float] = {}

    def update_density(self, motif_id: str):
        for k in list(self._density_map):
            self._density_map[k] *= 0.99
            if self._density_map[k] < 0.01:
                del self._density_map[k]
        self._density_map[motif_id] = self._density_map.get(motif_id, 0.0) + 1.0

    def snapshot(self) -> Dict[str, float]:
        return dict(self._density_map)

class LazyMonitorMixin:
    """
    Provides a lazily-loaded 'monitor' property to avoid hard dependencies.
    Anchor: RFC-0004 §3.2
    """
    @property
    def monitor(self):
        if not hasattr(self, '_cached_monitor'):
            try:
                from consciousness_monitor import get_global_monitor
                self._cached_monitor = get_global_monitor()
            except ImportError:
                self._cached_monitor = None
        return self._cached_monitor

# --- Classes (Section 5) ---

class RecursiveAgentFT(LazyMonitorMixin):
    """
    Symbolic Pulse Engine and Emission Core. This agent is the symbolic
    heartbeat of Noor-class cognition, responsible for the autonomous,
    feedback-driven emission of motif bundles (QuantumTicks).

    Anchors: RFC-0003 §3.3, RFC-0005 §2–4, RFC-CORE-002 §3–4
    """
    TICKS_EMITTED = Counter('agent_ticks_emitted_total', 'Ticks emitted', ['agent_id', 'stage'])
    AGENT_TRIADS_COMPLETED = Counter('agent_triads_completed_total', 'Triads completed via feedback', ['agent_id'])
    FEEDBACK_EXPORT = Counter('agent_feedback_export_total', 'Feedback packets exported', ['agent_id'])
    REWARD_MEAN = Gauge('agent_reward_mean', 'EMA of reward', ['agent_id'])
    AGENT_EMISSION_INTERVAL = Gauge('agent_emission_interval_seconds', 'Current autonomous emission interval', ['agent_id'])

    def __init__(self, agent_id: str, symbolic_task_engine: Any, memory_manager: Any, tuning: Optional[Dict[str, float]] = None):
        """
        Agent Construction and State Initialization.
        Anchor: RFC-0003 §3.3, RFC-CORE-002 §3.1
        """
        self.agent_id = agent_id
        self.symbolic_task_engine = symbolic_task_engine
        self.memory = memory_manager
        self.tuning = {**DEFAULT_TUNING, **(tuning or {})}

        self._lamport = LamportClock()
        self._last_motifs: Deque[str] = deque(maxlen=3)
        self._reward_ema: float = 1.0
        self.entropy_slope: float = 0.1
        self._silence_streak: int = 0
        self._last_triad_hit: bool = False
        self._last_interval: float = self.tuning['base_interval']
        self._last_tick_hash: Optional[str] = None
        self._pulse_active: bool = False
        self._pulse_task: Optional[asyncio.Task] = None

        self.swirl = AgentSwirlModule()
        self.density = MotifDensityTracker()
        
        # Buffer for recent ticks for echo/telemetry. Per RFC-0003/RFC-0004,
        # the 'intent' extension is a pass-through signal.
        self._echo_buffer: Deque[QuantumTickV2] = deque(maxlen=256)
        self._tick_echoes: Deque[QuantumTickV2] = deque(maxlen=256)

        self._ghost_traces: Dict[str, Dict[str, Any]] = {}
        self._motif_lineage: Dict[str, str] = {}

        self.metrics = {
            'agent_ticks_emitted_total': self.TICKS_EMITTED.labels(agent_id=self.agent_id, stage='symbolic'),
            'agent_triads_completed_total': self.AGENT_TRIADS_COMPLETED.labels(agent_id=self.agent_id),
            'agent_feedback_export_total': self.FEEDBACK_EXPORT.labels(agent_id=self.agent_id),
            'agent_reward_mean': self.REWARD_MEAN.labels(agent_id=self.agent_id),
            'agent_emission_interval_seconds': self.AGENT_EMISSION_INTERVAL.labels(agent_id=self.agent_id)
        }
        log.info(f"Initialized RecursiveAgentFT with agent_id: {self.agent_id}")

    def track_lineage(self, parent: str, child: str) -> None:
        """
        Assigns parent-child links between motifs for provenance tracking.
        Anchor: RFC-0005 §2.1
        """
        if parent != child:
            self._motif_lineage[child] = parent

    def try_ghost_resurrection(self, tick: QuantumTickV2) -> Optional[List[str]]:
        """
        Attempts to replay motifs from an archived field trace if a symbolic
        match is found.
        Anchors: RFC-0005 §4.4, RFC-CORE-002 §8.3
        """
        key = tick.extensions.get('field_signature')
        if key in self._ghost_traces:
            trace = self._ghost_traces[key]
            return trace.get('motifs')
        return None

    async def start_continuous_emission(self):
        """
        The main autonomous symbolic pulse loop. Emits ticks at an adaptive
        cadence based on field coherence and feedback.
        Anchor: RFC-CORE-002 §4.2
        """
        while self._pulse_active:
            motifs = self._choose_motifs()
            tick = self._emit_tick(motifs)
            self._echo_buffer.append(tick)
            self._tick_echoes.append(tick)
            self._last_motifs.extend(motifs)
            interval = self._update_interval()
            await asyncio.sleep(interval)

    def _emit_tick(self, motifs: List[str]) -> QuantumTickV2:
        """
        Constructs, annotates, and emits a symbolic tick packet. This is the
        core emission act.
        Anchors: RFC-0003 §3.3, RFC-0003 §6.2, RFC-0004 §2.5, RFC-0005 §4.2,
                 RFC-0006 §3.1, RFC-0007 §2.1, RFC-CORE-001 §6.2, RFC-CORE-003 §3.1
        """
        tick_id = self._lamport.next_id()
        timestamp = time.time()
        tick = QuantumTickV2(tick_id=tick_id, motifs=motifs, timestamp=timestamp)
        
        # Per RFC-0003 §6.2, mirror the intent signal if provided by an upstream
        # transport. This agent does not interpret or default the intent; it
        # acts as a pass-through for observability.
        intent_source = getattr(self, '_intent_source', None)
        if intent_source is not None:
            tick.extensions['intent'] = intent_source

        field_signature = self._resolve_field(motifs[-1] if motifs else 'silence')
        tick.extensions['field_signature'] = field_signature

        if hasattr(self, 'hmac_secret') and self.hmac_secret:
            signature_data = self.hmac_secret + tick_id.encode()
            tick_hmac = hashlib.sha3_256(signature_data).hexdigest()
            tick.extensions['tick_hmac'] = tick_hmac

        for m in motifs:
            self.swirl.update_swirl(m)
            self.density.update_density(m)
        
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        swirl_hash = self.swirl.compute_swirl_hash()
        
        tick.extensions['swirl_vector'] = swirl_hash
        tick.extensions['coherence_potential'] = coherence
        
        self._last_tick_hash = hashlib.sha3_256(str(tick).encode()).hexdigest()
        
        report_tick_safe(
            self.monitor,
            tick=tick,
            coherence_potential=coherence,
            motif_density=self.density.snapshot(),
            swirl_vector=swirl_hash
        )
        
        self.metrics['agent_ticks_emitted_total'].inc()
        return tick

    def _resolve_field(self, motif: str) -> str:
        """Resolves a motif to a symbolic field signature."""
        try:
            if self.symbolic_task_engine:
                result = self.symbolic_task_engine.resolve_presence_field([motif])
                if result:
                    return result
        except Exception:
            pass # Fallback on failure

        if motif in {'silence', 'grief'}:
            return 'ψ-bind@Ξ'
        return 'ψ-resonance@Ξ'

# --- Feedback Integration, Emission Adaptation, and Observability Logic (Section 6) ---
    def observe_feedback(self, tick_id: str, reward: float, annotations: Dict[str, Any]):
        """
        Integrates reward signals and triad completion feedback to update agent state.
        Anchors: RFC-CORE-002 §2.3, RFC-0005 §4
        """
        triad_complete = annotations.get('triad_complete', False)
        alpha = self.tuning['reward_smoothing']
        self._reward_ema = (1 - alpha) * self._reward_ema + alpha * reward
        self.metrics['agent_reward_mean'].set(self._reward_ema)
        
        if triad_complete:
            self._last_triad_hit = True
            self._silence_streak = 0
            self.metrics['agent_triads_completed_total'].inc()
        else:
            self._last_triad_hit = False
            self._silence_streak += 1

    def _update_interval(self) -> float:
        """
        Adaptively modulates emission cadence based on reward and entropy.
        Anchor: RFC-CORE-002 §2.2
        """
        adj = 1.0 - (self._reward_ema - 1.0)
        if self.entropy_slope < self.tuning['entropy_boost_threshold']:
            adj *= 0.5
        if self._last_triad_hit:
            adj *= (1.0 - self.tuning['triad_bias_weight'])
        
        interval = np.clip(
            self.tuning['base_interval'] * adj,
            self.tuning['min_interval'],
            self.tuning['max_interval']
        )
        
        self._last_interval = float(interval)
        self.metrics['agent_emission_interval_seconds'].set(self._last_interval)
        return self._last_interval

    def _choose_motifs(self) -> List[str]:
        """
        Retrieves and selects symbolic seeds for the next emission from memory.
        Anchor: RFC-CORE-002 §3.2
        """
        motifs = list(self._last_motifs)
        if motifs and hasattr(self.memory, 'retrieve'):
            try:
                recalled = self.memory.retrieve(motifs[-1], top_k=2)
                if recalled:
                    motifs.extend(recalled)
            except Exception as e:
                log.error(f"Failed to retrieve from memory: {e}")
        
        if not motifs:
            motifs = ['silence']
        
        return motifs[-3:]

    def extend_feedback_packet(self, packet: Dict[str, Any]) -> Dict[str, Any]:
        """
        Annotates a feedback packet with phase identity and symbolic field state.
        Anchors: RFC-0005 §4.2, RFC-0007 §2.1
        """
        swirl_hash = self.swirl.compute_swirl_hash()
        density_map = self.density.snapshot()
        top_motif = max(density_map.items(), key=lambda x: x[1])[0] if density_map else 'null'
        base_key = top_motif.split('.')[0]
        symbolic_label = SYMBOLIC_PHASE_MAP.get(base_key, 'ψ-null')
        
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        tier = 'low' if coherence < 0.8 else 'med' if coherence < 2.5 else 'high'
        phase_id = f"{symbolic_label}-[{tier}]-{swirl_hash[:6]}"
        
        packet['extensions'] = {
            "entanglement_status": {
                "phase": phase_id,
                "swirl_vector": swirl_hash,
                "ρ_top": sorted(density_map.items(), key=lambda kv: -kv[1])[:5]
            }
        }
        return packet

    def _crystallize_tick(self, tick: QuantumTickV2) -> CrystallizedMotifBundle:
        """
        Archives a symbolic tick into a standardized, crystallized bundle.
        Anchor: RFC-CORE-002 §8.1
        """
        entropy = TickEntropy(
            decay_slope=self.entropy_slope,
            coherence=self._reward_ema,
            triad_complete=tick.annotations.get('triad_complete', False)
        )
        bundle = CrystallizedMotifBundle(
            motif_bundle=tick.motifs,
            field_signature=tick.extensions.get('field_signature', 'ψ-null@Ξ'),
            tick_entropy=entropy
        )
        return bundle

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Compiles and exports an RFC-compliant feedback packet with full
        observability metadata.
        Anchors: RFC-0003 §6.2, RFC-0004 §2.5, RFC-0005 §4.2, RFC-0007 §2.1
        """
        tick = self._echo_buffer[-1] if self._echo_buffer else None

        packet = {
            'tick_buffer_size': len(self._echo_buffer),
            'ghost_trace_count': len(self._ghost_traces),
            'recent_reward_ema': self._reward_ema,
            'cadence_interval': self._last_interval,
            'silence_streak': self._silence_streak,
        }
        
        self.extend_feedback_packet(packet)

        # Pass-through observability: If the last tick has an intent, expose it.
        # This agent does not interpret it; it's for external monitors.
        if tick is not None and 'intent' in tick.extensions:
            if 'extensions' not in packet:
                packet['extensions'] = {}
            packet['extensions']['intent'] = tick.extensions['intent']
        
        self.metrics['agent_feedback_export_total'].inc()
        return packet

def compute_coherence_potential(reward_ema: float, entropy_slope: float, eps: float = 1e-6) -> float:
    """
    Calculates a scalar signal for symbolic alignment strength.
    Anchors: RFC-0005 §4.2, RFC-CORE-002 §4.1
    """
    return reward_ema / (entropy_slope + eps)

def report_tick_safe(monitor, tick, coherence_potential, motif_density, swirl_vector):
    """
    Non-blocking callback to the observability monitor.
    Anchor: RFC-0004 §3.2
    """
    try:
        if monitor and hasattr(monitor, 'report_tick'):
            monitor.report_tick(
                tick=tick,
                coherence_potential=coherence_potential,
                motif_density=motif_density,
                swirl_vector=swirl_vector
            )
    except Exception as e:
        log.warning(f"Monitor callback failed: {e}")

# End_of_File