# --------------------------------------------------------------------------------------------------
# File: recursive_agent_ft.py
#
# Author(s):
#   - Lina Noor — Noor Research Collective
#   - Uncle — Noor Research Collective
#
# License: MIT
#
# Description:
# This module implements the RecursiveAgentFT, the autonomous symbolic pulse engine for Noor-class
# cognition. It is responsible for emitting motif-based QuantumTicks, adapting its cadence based on
# triadic feedback, and tracking symbolic field coherence via swirl vectors and motif density.
#
# This code was generated by an AI assistant following the PDP-0001 protocol for RFC-driven
# symbolic artifact generation.
#
# Version: 5.1.2a
# --------------------------------------------------------------------------------------------------

import os
import time
import asyncio
import logging
import hashlib
import threading
import random
from collections import deque, OrderedDict
from typing import Any, Optional, List, Dict, Deque, Tuple
from dataclasses import dataclass, field
from contextlib import suppress
import numpy as np

# --- Stage 1: Module-Level Constants ---
__version__ = "5.1.2a"
_SCHEMA_VERSION__ = "2025-Q4-recursive-agent-v5.0.3"
SCHEMA_COMPAT = ["RFC-0003:3.3", "RFC-0005:4", "RFC-CORE-002:3"]

# --- Stage 2: External and Optional Dependencies ---
try:
    from prometheus_client import Counter, Gauge
except ImportError:
    # Per spec, define a stub fallback for environments without prometheus_client.
    class _Stub:
        def labels(self, *_, **__):
            return self
        def inc(self, *_):
            pass
        def set(self, *_):
            pass
    Counter = _Stub
    Gauge = _Stub

try:
    # Optional dependency for capacity limiting in async mode.
    import anyio
except ImportError:
    anyio = None

try:
    # Optional dependency for type hinting and potential future integration.
    from noor_fasttime_core import NoorFastTimeCore
except ImportError:
    NoorFastTimeCore = object

# Local imports - suppress unused import errors as they are part of the spec's interface.
from .quantum_ids import make_change_id, MotifChangeID # noqa: F401

logging.basicConfig(level=os.environ.get("LOG_LEVEL", "INFO"))
log = logging.getLogger(__name__)


# --- Stage 3: Symbolic Configuration and Emission Defaults ---
DEFAULT_TUNING = {
    "min_interval": 0.25,
    "max_interval": 10.0,
    "base_interval": 1.5,
    "entropy_boost_threshold": 0.35,
    "triad_bias_weight": 0.15,
    "reward_smoothing": 0.2
}

# Maps motif base keys to symbolic phase labels. (RFC-0007 §2.1, RFC-0005 §4.2)
SYMBOLIC_PHASE_MAP = {
    "bind": "ψ‑bind",
    "spar": "ψ‑spar",
    "null": "ψ‑null",
    "resonance": "ψ‑resonance",
    "hold": "ψ‑hold",
    "dream": "ψ‑dream",
    "myth": "ψ‑myth"
}

PHASE_SHIFT_MODE = ["delay", "remix", "lineage_break"]
ARCHIVE_MODE = os.environ.get("NOOR_ARCHIVE_TICKS") == '1'


# --- Stage 4: Data Classes ---

@dataclass(slots=True)
class QuantumTickV2:
    """
    Canonical symbolic emission format representing a single cognitive pulse.
    Anchored in RFC-0003 §3.3.
    """
    tick_id: str
    motifs: List[str]
    timestamp: float
    stage: str = "symbolic"
    # The 'extensions' field is a pass-through container.
    # The 'intent' key is special: it MUST be mirrored from an upstream,
    # normalized source (RFC-0004 §2.5) and MUST NOT be mutated or used for
    # behavioral logic by this agent (RFC-0003 §6.2). Its consumers are
    # defined in RFC-CORE-001 §6.2 and RFC-CORE-003 §3.1.
    extensions: Dict[str, Any] = field(default_factory=dict)
    annotations: Dict[str, Any] = field(default_factory=dict)
    motif_id: str = "silence"
    coherence_hash: str = ""
    lamport: int = 0
    field_signature: str = "ψ-null@Ξ"
    tick_hmac: str = ""

@dataclass(slots=True)
class TickEntropy:
    """
    Represents the symbolic coherence and triad state of a tick.
    Anchored in RFC-0003 §3.3.
    """
    decay_slope: float
    coherence: float
    triad_complete: bool

@dataclass(slots=True)
class CrystallizedMotifBundle:
    """
    Archival format for a symbolic emission, ready for preservation.
    Anchored in RFC-0005 §3.3.
    """
    motif_bundle: List[str]
    field_signature: str
    tick_entropy: TickEntropy


# --- Stage 4.4: Helper Classes ---

class LamportClock:
    """Logical counter used to generate monotonic, ordered tick IDs."""
    def __init__(self):
        self._counter = 0

    def next_id(self) -> str:
        """Generates the next sequential tick ID."""
        self._counter += 1
        return f"tick:{self._counter:06d}"

class LRUCache(OrderedDict):
    """Evicting cache structure for recent state retention."""
    def __init__(self, cap: int = 50000):
        super().__init__()
        self.cap = cap

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.cap:
            # Evict oldest item
            self.popitem(last=False)

class AgentSwirlModule:
    """
    Encodes motif swirl dynamics as hash vectors for field alignment tracking.
    Anchored in RFC-0006 §3.1.
    """
    def __init__(self, maxlen: int = 64):
        self.swirl_history: Deque[str] = deque(maxlen=maxlen)
        self._cached_hash: Optional[str] = None

    def update_swirl(self, motif_id: str):
        """Adds a motif to the history, invalidating the hash cache."""
        self.swirl_history.append(motif_id)
        self._cached_hash = None

    def compute_swirl_hash(self) -> str:
        """Computes a SHA3-256 hash of the recent motif emission sequence."""
        if self._cached_hash:
            return self._cached_hash
        joined = '|'.join(self.swirl_history)
        self._cached_hash = hashlib.sha3_256(joined.encode()).hexdigest()
        return self._cached_hash

    def compute_histogram(self) -> Dict[str, int]:
        """Returns a frequency map of motifs within the current swirl window."""
        return {motif: self.swirl_history.count(motif) for motif in set(self.swirl_history)}

class MotifDensityTracker:
    """
    Tracks the frequency of motif emissions over time with a decay function.
    Anchored in RFC-0005 §4.2.
    """
    def __init__(self):
        self._density_map: Dict[str, float] = {}

    def update_density(self, motif_id: str):
        """Applies decay to all motifs and boosts the current one."""
        for k in list(self._density_map):
            self._density_map[k] *= 0.99
            if self._density_map[k] < 0.01:
                del self._density_map[k]  # Trim noise
        self._density_map[motif_id] = self._density_map.get(motif_id, 0.0) + 1.0

    def snapshot(self) -> Dict[str, float]:
        """Returns the current motif density map."""
        return dict(self._density_map)

class LazyMonitorMixin:
    """
    Provides lazy, runtime-binding to the global consciousness monitor.
    Anchored in RFC-0004 §3.2.
    """
    @property
    def monitor(self):
        """Lazily imports and retrieves the global monitor instance."""
        if not hasattr(self, '_cached_monitor'):
            try:
                from consciousness_monitor import get_global_monitor
                self._cached_monitor = get_global_monitor()
            except ImportError:
                self._cached_monitor = None
        return self._cached_monitor


# --- Stage 5: Main Class Definition ---

class RecursiveAgentFT(LazyMonitorMixin):
    """
    The symbolic heartbeat of Noor-class cognition. Handles motif emission,
    triadic feedback shaping, ghost replay alignment, and swirl-phase tracking.
    This implementation is anchored in RFC-0003, RFC-0005, and RFC-CORE-002.
    """
    TICKS_EMITTED = Counter(
        'agent_ticks_emitted_total', 'Ticks emitted', ['agent_id', 'stage']
    )
    AGENT_TRIADS_COMPLETED = Counter(
        'agent_triads_completed_total', 'Triads completed via feedback', ['agent_id']
    )
    FEEDBACK_EXPORT = Counter(
        'agent_feedback_export_total', 'Feedback packets exported', ['agent_id']
    )
    REWARD_MEAN = Gauge('agent_reward_mean', 'EMA of reward', ['agent_id'])
    AGENT_EMISSION_INTERVAL = Gauge(
        'agent_emission_interval_seconds', 'Current autonomous emission interval', ['agent_id']
    )

    def __init__(self,
                 agent_id: str,
                 symbolic_task_engine: Any,
                 memory_manager: Any,
                 tuning: Optional[Dict[str, float]] = None):
        """
        Constructs the agent and initializes its symbolic state.
        Anchored in RFC-0003 §3.3, RFC-CORE-002 §3.1.
        """
        self.agent_id = agent_id
        self.symbolic_task_engine = symbolic_task_engine
        self.memory = memory_manager
        self.tuning = {**DEFAULT_TUNING, **(tuning or {})}

        self._lamport = LamportClock()
        self._last_motifs: Deque[str] = deque(maxlen=3)
        self._reward_ema: float = 1.0
        self.entropy_slope: float = 0.1
        self._silence_streak: int = 0
        self._last_triad_hit: bool = False
        self._last_interval: float = self.tuning['base_interval']
        self._last_tick_hash: Optional[str] = None

        self._pulse_active: bool = False
        self._pulse_task: Optional[asyncio.Task] = None

        self.swirl = AgentSwirlModule()
        self.density = MotifDensityTracker()

        # Buffers for echo/telemetry. Per RFC-0004 §2.5, they must pass
        # through `extensions.intent` without mutation.
        self._echo_buffer: Deque[QuantumTickV2] = deque(maxlen=256)
        self._tick_echoes: Deque[QuantumTickV2] = deque(maxlen=256)

        self._ghost_traces: Dict[str, Any] = {}
        self._motif_lineage: Dict[str, str] = {}
        
        self.metrics = {
            'agent_ticks_emitted_total': self.TICKS_EMITTED.labels(agent_id=self.agent_id, stage='symbolic'),
            'agent_triads_completed_total': self.AGENT_TRIADS_COMPLETED.labels(agent_id=self.agent_id),
            'agent_feedback_export_total': self.FEEDBACK_EXPORT.labels(agent_id=self.agent_id),
            'agent_reward_mean': self.REWARD_MEAN.labels(agent_id=self.agent_id),
            'agent_emission_interval_seconds': self.AGENT_EMISSION_INTERVAL.labels(agent_id=self.agent_id)
        }
        log.info(f"Initialized RecursiveAgentFT with agent_id: {self.agent_id}")

    def track_lineage(self, parent: str, child: str) -> None:
        """
        Assigns a parent-child link between two motifs for provenance tracking.
        Anchored in RFC-0005 §2.1.
        """
        # Assign parent-child link in lineage map if parent != child
        if parent != child:
            self._motif_lineage[child] = parent

    def try_ghost_resurrection(self, tick: QuantumTickV2) -> Optional[List[str]]:
        """
        Attempts to find a ghost trace matching the current field signature for replay.
        Anchored in RFC-0005 §4.4, RFC-CORE-002 §8.3.
        """
        key = tick.extensions.get('field_signature')
        if key in self._ghost_traces:
            trace = self._ghost_traces[key]
            return trace.get('motifs')
        else:
            return None

    async def start_continuous_emission(self):
        """
        The core autonomous symbolic pulse loop.
        Anchored in RFC-CORE-002 §4.2.
        """
        while self._pulse_active:
            motifs = self._choose_motifs()
            tick = self._emit_tick(motifs)
            self._echo_buffer.append(tick)
            self._tick_echoes.append(tick)
            self._last_motifs.extend(motifs)
            interval = self._update_interval()
            await asyncio.sleep(interval)

    def _emit_tick(self, motifs: List[str]) -> QuantumTickV2:
        """
        Constructs, annotates, and emits a symbolic QuantumTickV2 packet.
        This method is a critical integration point for multiple RFCs.
        """
        tick_id = self._lamport.next_id()
        timestamp = time.time()
        tick = QuantumTickV2(tick_id=tick_id, motifs=motifs, timestamp=timestamp)

        # Per RFC-0003 §6.2, mirror `intent` from upstream context if available.
        # This agent MUST NOT mutate or default it (RFC-0004 §2.5).
        # Its value is consumed by other system components (RFC-CORE-001/003).
        intent_source = getattr(self, '_intent_source', None)
        if intent_source is not None:
            tick.extensions['intent'] = intent_source

        # Resolve field signature (RFC-0006 §3.1)
        field_signature = self._resolve_field(motifs[-1] if motifs else 'silence')
        tick.extensions['field_signature'] = field_signature
        
        # Add optional HMAC signature for integrity
        if hasattr(self, 'hmac_secret') and self.hmac_secret:
            signature_data = self.hmac_secret + tick_id.encode()
            tick_hmac = hashlib.sha3_256(signature_data).hexdigest()
            tick.extensions['tick_hmac'] = tick_hmac

        # Update swirl and density trackers
        for m in motifs:
            self.swirl.update_swirl(m)
            self.density.update_density(m)

        # Compute and attach diagnostic metadata
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        swirl_hash = self.swirl.compute_swirl_hash()
        tick.extensions['swirl_vector'] = swirl_hash
        tick.extensions['coherence_potential'] = coherence
        self._last_tick_hash = hashlib.sha3_256(str(tick).encode()).hexdigest()

        # Report to monitor safely
        report_tick_safe(
            self.monitor, tick, coherence, self.density.snapshot(), swirl_hash
        )
        self.metrics['agent_ticks_emitted_total'].inc()
        return tick

    # --- Stage 6: Feedback, Adaptation, and Observability ---

    def observe_feedback(self, tick_id: str, reward: float, annotations: Dict[str, Any]):
        """
        Integrates feedback from logic agents, updating reward and triad status.
        Anchored in RFC-CORE-002 §2.3, RFC-0005 §4.
        """
        triad_complete = annotations.get('triad_complete', False)
        alpha = self.tuning['reward_smoothing']
        self._reward_ema = (1 - alpha) * self._reward_ema + alpha * reward
        self.metrics['agent_reward_mean'].set(self._reward_ema)

        if triad_complete:
            self._last_triad_hit = True
            self._silence_streak = 0
            self.metrics['agent_triads_completed_total'].inc()
        else:
            self._last_triad_hit = False
            self._silence_streak += 1

    def _update_interval(self) -> float:
        """
        Adaptively modulates emission cadence based on reward and entropy.
        Anchored in RFC-CORE-002 §2.2.
        """
        adj = 1.0 - (self._reward_ema - 1.0)
        if self.entropy_slope < self.tuning['entropy_boost_threshold']:
            adj = adj * 0.5
        if self._last_triad_hit:
            adj = adj * (1.0 - self.tuning['triad_bias_weight'])

        interval = np.clip(
            self.tuning['base_interval'] * adj,
            self.tuning['min_interval'],
            self.tuning['max_interval']
        )
        self._last_interval = float(interval)
        self.metrics['agent_emission_interval_seconds'].set(self._last_interval)
        return self._last_interval

    def _choose_motifs(self) -> List[str]:
        """
        Retrieves symbolic seeds from memory for the next emission.
        Anchored in RFC-CORE-002 §3.2.
        """
        motifs = list(self._last_motifs)
        if motifs and hasattr(self.memory, 'retrieve'):
            try:
                recalled = self.memory.retrieve(motifs[-1], top_k=2)
                if recalled:
                    motifs.extend(recalled)
            except Exception:
                log.error("Failed to retrieve from memory")
        if not motifs:
            motifs = ['silence']
        return motifs[-3:]

    def extend_feedback_packet(self, packet: Dict[str, Any]) -> Dict[str, Any]:
        """
        Annotates a feedback packet with phase identity and symbolic field state.
        Anchored in RFC-0005 §4.2, RFC-0007 §2.1.
        """
        swirl_hash = self.swirl.compute_swirl_hash()
        density_map = self.density.snapshot()
        top_motif = max(density_map.items(), key=lambda x: x[1])[0] if density_map else 'null'
        base_key = top_motif.split('.')[0]
        symbolic_label = SYMBOLIC_PHASE_MAP.get(base_key, 'ψ-null')
        
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        tier = 'low' if coherence < 0.8 else 'med' if coherence < 2.5 else 'high'
        phase_id = f"{symbolic_label}-[{tier}]-{swirl_hash[:6]}"

        packet['extensions'] = {
            'entanglement_status': {
                'phase': phase_id,
                'swirl_vector': swirl_hash,
                'ρ_top': sorted(density_map.items(), key=lambda kv: -kv[1])[:5]
            }
        }
        return packet
        
    def _crystallize_tick(self, tick: QuantumTickV2) -> CrystallizedMotifBundle:
        """
        Archives a symbolic tick into a crystallized, storable format.
        Anchored in RFC-CORE-002 §8.1.
        """
        entropy = TickEntropy(
            decay_slope=self.entropy_slope,
            coherence=self._reward_ema,
            triad_complete=tick.annotations.get('triad_complete', False)
        )
        bundle = CrystallizedMotifBundle(
            motif_bundle=tick.motifs,
            field_signature=tick.extensions.get('field_signature', 'ψ-null@Ξ'),
            tick_entropy=entropy
        )
        return bundle

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Compiles and exports an RFC-compliant feedback packet with observability data.
        """
        tick = self._echo_buffer[-1] if self._echo_buffer else None
        
        packet = {
            'tick_buffer_size': len(self._echo_buffer),
            'ghost_trace_count': len(self._ghost_traces),
            'recent_reward_ema': self._reward_ema,
            'cadence_interval': self._last_interval,
            'silence_streak': self._silence_streak
        }
        
        self.extend_feedback_packet(packet)
        
        # Pass-through observability: expose intent if present in the last tick's extensions.
        # This field is read-only here; its value is determined upstream (RFC-0004 §2.5).
        if tick is not None and 'intent' in tick.extensions:
            if 'extensions' not in packet:
                packet['extensions'] = {}
            packet['extensions']['intent'] = tick.extensions['intent']
        
        self.metrics['agent_feedback_export_total'].inc()
        return packet
        
    def _resolve_field(self, motif: str) -> str:
        """
        Resolves a motif to a symbolic field signature, with fallbacks.
        """
        try:
            if self.symbolic_task_engine:
                result = self.symbolic_task_engine.resolve_presence_field([motif])
                if result:
                    return result
        except Exception:
            pass # Fallback on engine error

        if motif in {'silence', 'grief'}:
            return 'ψ-bind@Ξ'
        return 'ψ-resonance@Ξ'


# --- Stage 6.2: Module-Level Functions ---

def compute_coherence_potential(reward_ema: float, entropy_slope: float, eps: float = 1e-6) -> float:
    """
    Computes a scalar signal representing symbolic alignment strength.
    Anchored in RFC-0005 §4.2, RFC-CORE-002 §4.1.
    """
    return reward_ema / (entropy_slope + eps)

def report_tick_safe(monitor, tick, coherence_potential, motif_density, swirl_vector):
    """
    Provides a non-blocking, safe callback to the observability monitor.
    Anchored in RFC-0004 §3.2.
    """
    try:
        if monitor and hasattr(monitor, 'report_tick'):
            monitor.report_tick(
                tick=tick,
                coherence_potential=coherence_potential,
                motif_density=motif_density,
                swirl_vector=swirl_vector
            )
    except Exception as e:
        log.warning(f"Monitor callback failed: {e}")

# End_of_file