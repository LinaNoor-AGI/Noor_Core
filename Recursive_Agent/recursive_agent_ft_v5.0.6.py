# program_name: recursive_agent_ft.py
# version: v5.0.6
# canonical_source: RFC-CORE-002
# description: Merged agent for symbolic tick emission, swirl coherence feedback, ghost replay, and triad-resonance feedback handling. Fully RFC-aligned and regeneration-ready.
#
# Generated by Gemini 2.5 Pro (Google AI Studio)

import os
import time
import asyncio
import logging
import hashlib
import threading
import random
import contextlib
from collections import deque, OrderedDict
from typing import Any, Optional, List, Dict, Deque, Tuple
from dataclasses import dataclass, field

import numpy as np

# Optional dependency handling for prometheus_client
try:
    from prometheus_client import Counter, Gauge
except ImportError:
    class _Stub:
        def labels(self, *_, **__):
            return self
        def inc(self, *_):
            pass
        def set(self, *_):
            pass
    Counter = _Stub
    Gauge = _Stub

# Optional dependency handling for noor_fasttime_core
try:
    from noor_fasttime_core import NoorFastTimeCore
except ImportError:
    NoorFastTimeCore = object

# Optional dependency handling for anyio
try:
    import anyio
except ImportError:
    anyio = None

# Local imports
try:
    from .quantum_ids import make_change_id, MotifChangeID  # noqa: F401
except ImportError:
    # Fallback for standalone execution
    class MotifChangeID: pass
    def make_change_id(x): return str(x)

# Module-level constants
__version__ = "5.0.3"
_SCHEMA_VERSION__ = "2025-Q4-recursive-agent-v5.0.3"
SCHEMA_COMPAT = ["RFC-0003:3.3", "RFC-0005:4", "RFC-CORE-002:3"]

log = logging.getLogger(__name__)

# RFC-0003 §3.3, RFC-CORE-002 §4.2
DEFAULT_TUNING = {
    'min_interval': 0.25,
    'max_interval': 10.0,
    'base_interval': 1.5,
    'entropy_boost_threshold': 0.35,
    'triad_bias_weight': 0.15,
    'reward_smoothing': 0.2
}

# RFC-0007 §2.1, RFC-0005 §4.2
SYMBOLIC_PHASE_MAP = {
    'bind': 'ψ‑bind',
    'spar': 'ψ‑spar',
    'null': 'ψ‑null',
    'resonance': 'ψ‑resonance',
    'hold': 'ψ‑hold',
    'dream': 'ψ‑dream',
    'myth': 'ψ‑myth'
}

PHASE_SHIFT_MODE = ["delay", "remix", "lineage_break"]
ARCHIVE_MODE = os.getenv('NOOR_ARCHIVE_TICKS') == '1'

@dataclass(slots=True)
class QuantumTickV2:
    """
    Represents a symbolic emission packet, the core unit of cognition.
    RFC Anchors: RFC-0003 §6.2, RFC-0004 §2.5, RFC-CORE-001 §6.2, RFC-CORE-003 §3.1
    """
    tick_id: str
    motifs: List[str]
    timestamp: float
    stage: str = "symbolic"
    # extensions.intent: Transport-level intent (canonicalized upstream) per RFC-0004 §2.5;
    # MUST be mirrored from envelope.intent into tick.extensions.intent per RFC-0003 §6.2;
    # read-only for this agent. Consumption semantics live in RFC-CORE-001 §6.2 and RFC-CORE-003 §3.1.
    extensions: Dict[str, Any] = field(default_factory=dict)
    annotations: Dict[str, Any] = field(default_factory=dict)
    motif_id: str = "silence"
    coherence_hash: str = ""
    lamport: int = 0
    field_signature: str = "ψ-null@Ξ"
    tick_hmac: str = ""

@dataclass(slots=True)
class TickEntropy:
    """
    Represents the symbolic entropy and coherence of a tick.
    RFC Anchor: RFC-0003 §3.3
    """
    decay_slope: float
    coherence: float
    triad_complete: bool

@dataclass(slots=True)
class CrystallizedMotifBundle:
    """
    An archival format for a completed QuantumTickV2.
    RFC Anchor: RFC-0005 §3.3
    """
    motif_bundle: List[str]
    field_signature: str
    tick_entropy: TickEntropy

class LamportClock:
    """Logical counter used to generate ordered tick IDs."""
    def __init__(self):
        self._counter = 0

    def next_id(self) -> str:
        self._counter += 1
        return f"tick:{self._counter:06d}"

class LRUCache(OrderedDict):
    """Evicting cache structure for recent state retention."""
    def __init__(self, cap: int = 50000):
        super().__init__()
        self.cap = cap

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.cap:
            self.popitem(last=False)

class AgentSwirlModule:
    """
    Encodes motif swirl dynamics as hash vectors.
    RFC Anchor: RFC-0006 §3.1
    """
    def __init__(self, maxlen: int = 64):
        self.swirl_history: Deque[str] = deque(maxlen=maxlen)
        self._cached_hash: Optional[str] = None

    def update_swirl(self, motif_id: str):
        self.swirl_history.append(motif_id)
        self._cached_hash = None

    def compute_swirl_hash(self) -> str:
        if self._cached_hash:
            return self._cached_hash
        joined = '|'.join(self.swirl_history)
        self._cached_hash = hashlib.sha3_256(joined.encode()).hexdigest()
        return self._cached_hash

    def compute_histogram(self) -> Dict[str, int]:
        return { motif: self.swirl_history.count(motif) for motif in set(self.swirl_history) }

class MotifDensityTracker:
    """
    Tracks frequency of motif emissions over time.
    RFC Anchor: RFC-0005 §4.2
    """
    def __init__(self):
        self._density_map: Dict[str, float] = {}

    def update_density(self, motif_id: str):
        for k in list(self._density_map):
            self._density_map[k] *= 0.99
            if self._density_map[k] < 0.01:
                del self._density_map[k]
        self._density_map[motif_id] = self._density_map.get(motif_id, 0.0) + 1.0

    def snapshot(self) -> Dict[str, float]:
        return dict(self._density_map)

class LazyMonitorMixin:
    """
    Provides lazy loading of consciousness monitor.
    RFC Anchor: RFC-0004 §3.2
    """
    @property
    def monitor(self):
        if not hasattr(self, '_cached_monitor'):
            try:
                from consciousness_monitor import get_global_monitor
                self._cached_monitor = get_global_monitor()
            except ImportError:
                self._cached_monitor = None
        return self._cached_monitor

def compute_coherence_potential(reward_ema: float, entropy_slope: float, eps: float = 1e-6) -> float:
    """
    Computes a scalar metric for agent readiness and alignment.
    RFC Anchors: RFC-0005 §4.2, RFC-CORE-002 §4.1
    """
    return reward_ema / (entropy_slope + eps)

def report_tick_safe(monitor: Any, tick: QuantumTickV2, coherence_potential: float, motif_density: Dict[str, float], swirl_vector: str) -> None:
    """
    Safely reports a tick to the monitor, handling potential failures.
    RFC Anchor: RFC-0004 §3.2
    """
    try:
        if monitor and hasattr(monitor, 'report_tick'):
            monitor.report_tick(
                tick=tick,
                coherence_potential=coherence_potential,
                motif_density=motif_density,
                swirl_vector=swirl_vector
            )
    except Exception as e:
        log.warning(f"Monitor callback failed: {e}")

class RecursiveAgentFT(LazyMonitorMixin):
    """
    Autonomous symbolic pulse engine for Noor-class agents.
    RFC Anchors: RFC-0003 §3.3, RFC-0005 §2–4, RFC-CORE-002 §3–4
    """
    # RFC-0003 §3.3
    TICKS_EMITTED = Counter('agent_ticks_emitted_total', 'Ticks emitted', ['agent_id', 'stage'])
    # RFC-0005 §4.3
    AGENT_TRIADS_COMPLETED = Counter('agent_triads_completed_total', 'Triads completed via feedback', ['agent_id'])
    # RFC-0005 §4.2, RFC-0007 §2.1
    FEEDBACK_EXPORT = Counter('agent_feedback_export_total', 'Feedback packets exported', ['agent_id'])
    # RFC-0005 §4.1
    REWARD_MEAN = Gauge('agent_reward_mean', 'EMA of reward', ['agent_id'])
    # RFC-CORE-002 §4.2
    AGENT_EMISSION_INTERVAL = Gauge('agent_emission_interval_seconds', 'Current autonomous emission interval', ['agent_id'])

    def __init__(self, agent_id: str, symbolic_task_engine: Any, memory_manager: Any, tuning: Optional[Dict[str, float]] = None) -> None:
        """
        Initializes the RecursiveAgentFT instance.
        RFC Anchors: RFC-0003 §3.3, RFC-CORE-002 §3.1
        """
        self.agent_id = agent_id
        self.symbolic_task_engine = symbolic_task_engine
        self.memory = memory_manager
        self.tuning = {**DEFAULT_TUNING, **(tuning or {})}
        
        self._lamport = LamportClock()
        self._last_motifs: Deque[str] = deque(maxlen=3)
        self._reward_ema = 1.0
        self.entropy_slope = 0.1
        self._silence_streak = 0
        self._last_triad_hit = False
        self._last_interval = self.tuning['base_interval']
        self._last_tick_hash: Optional[str] = None
        
        self._pulse_active = False
        self._pulse_task: Optional[asyncio.Task] = None
        
        self.swirl = AgentSwirlModule()
        self.density = MotifDensityTracker()
        
        # _echo_buffer: Holds recent ticks for echo/telemetry.
        # MUST pass through extensions.intent unchanged; do not synthesize defaults (RFC-0004 §2.5).
        self._echo_buffer: Deque[QuantumTickV2] = deque(maxlen=256)
        
        # _tick_echoes: Lightweight echo of emitted ticks.
        # MUST pass through extensions.intent unchanged; read-only in feedback.
        self._tick_echoes: Deque[QuantumTickV2] = deque(maxlen=256)
        
        self._ghost_traces: Dict[str, Dict] = {}
        self._motif_lineage: Dict[str, str] = {}
        
        self.metrics = {
            'agent_ticks_emitted_total': self.TICKS_EMITTED.labels(agent_id=self.agent_id, stage='symbolic'),
            'agent_triads_completed_total': self.AGENT_TRIADS_COMPLETED.labels(agent_id=self.agent_id),
            'agent_feedback_export_total': self.FEEDBACK_EXPORT.labels(agent_id=self.agent_id),
            'agent_reward_mean': self.REWARD_MEAN.labels(agent_id=self.agent_id),
            'agent_emission_interval_seconds': self.AGENT_EMISSION_INTERVAL.labels(agent_id=self.agent_id),
        }
        
        log.info(f"Initialized RecursiveAgentFT with agent_id={self.agent_id}")

    def track_lineage(self, parent: str, child: str) -> None:
        """
        Assign parent-child link in lineage map if parent != child.
        RFC Anchor: RFC-0005 §2.1
        """
        if parent != child:
            self._motif_lineage[child] = parent

    def try_ghost_resurrection(self, tick: QuantumTickV2) -> Optional[List[str]]:
        """
        Attempts to resurrect motifs from ghost traces based on the tick's field signature.
        RFC Anchors: RFC-0005 §4.4, RFC-CORE-002 §8.3
        """
        key = tick.extensions.get('field_signature')
        if key in self._ghost_traces:
            trace = self._ghost_traces[key]
            return trace.get('motifs')
        else:
            return None

    async def start_continuous_emission(self):
        """
        The core autonomous emission loop.
        RFC Anchor: RFC-CORE-002 §4.2
        """
        while self._pulse_active:
            motifs = self._choose_motifs()
            tick = self._emit_tick(motifs)
            self._echo_buffer.append(tick)
            self._tick_echoes.append(tick)
            self._last_motifs.extend(motifs)
            interval = self._update_interval()
            await asyncio.sleep(interval)

    def _emit_tick(self, motifs: List[str]) -> QuantumTickV2:
        """
        Constructs and emits a QuantumTickV2, including all necessary metadata.
        RFC Anchors: RFC-0003 §3.3, §6.2; RFC-0004 §2.5; RFC-0005 §4.2; RFC-0006 §3.1; RFC-0007 §2.1; RFC-CORE-001 §6.2; RFC-CORE-003 §3.1
        """
        tick_id = self._lamport.next_id()
        timestamp = time.time()
        tick = QuantumTickV2(tick_id=tick_id, motifs=motifs, timestamp=timestamp)

        # intent_source: value provided by upstream transport/context (e.g., ESB envelope or Symbolic Task Engine request)
        # AFTER normalization per RFC-0004 §2.5 and mirroring policy per RFC-0003 §6.2.
        # This method MUST NOT mutate, synthesize, or default `intent`; it only mirrors a provided value into tick.extensions.intent.
        intent_source = getattr(self, '_intent_source', None)
        if intent_source is not None:
            tick.extensions['intent'] = intent_source

        field_signature = self._resolve_field(motifs[-1] if motifs else 'silence')
        tick.extensions['field_signature'] = field_signature

        if hasattr(self, 'hmac_secret') and self.hmac_secret:
            signature_data = self.hmac_secret + tick_id.encode()
            tick_hmac = hashlib.sha3_256(signature_data).hexdigest()
            tick.extensions['tick_hmac'] = tick_hmac

        for m in motifs:
            self.swirl.update_swirl(m)
            self.density.update_density(m)
            
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        swirl_hash = self.swirl.compute_swirl_hash()
        
        tick.extensions['swirl_vector'] = swirl_hash
        tick.extensions['coherence_potential'] = coherence
        
        self._last_tick_hash = hashlib.sha3_256(str(tick).encode()).hexdigest()
        
        report_tick_safe(
            self.monitor, tick, coherence, self.density.snapshot(), swirl_hash
        )
        
        self.metrics['agent_ticks_emitted_total'].inc()
        return tick

    def observe_feedback(self, tick_id: str, reward: float, annotations: Dict[str, Any]):
        """
        Processes feedback on a tick's utility and updates internal state.
        RFC Anchors: RFC-CORE-002 §2.3, RFC-0005 §4
        """
        triad_complete = annotations.get('triad_complete', False)
        alpha = self.tuning['reward_smoothing']
        self._reward_ema = (1 - alpha) * self._reward_ema + alpha * reward
        self.metrics['agent_reward_mean'].set(self._reward_ema)

        if triad_complete:
            self._last_triad_hit = True
            self._silence_streak = 0
            self.metrics['agent_triads_completed_total'].inc()
        else:
            self._last_triad_hit = False
            self._silence_streak += 1

    def _update_interval(self) -> float:
        """
        Dynamically adjusts the emission interval based on feedback and entropy.
        RFC Anchor: RFC-CORE-002 §2.2
        """
        adj = 1.0 - (self._reward_ema - 1.0)
        if self.entropy_slope < self.tuning['entropy_boost_threshold']:
            adj *= 0.5
        if self._last_triad_hit:
            adj *= (1.0 - self.tuning['triad_bias_weight'])
            
        interval = np.clip(
            self.tuning['base_interval'] * adj,
            self.tuning['min_interval'],
            self.tuning['max_interval']
        )
        self._last_interval = float(interval)
        self.metrics['agent_emission_interval_seconds'].set(self._last_interval)
        return self._last_interval

    def _choose_motifs(self) -> List[str]:
        """
        Selects motifs for the next emission based on memory and recent history.
        RFC Anchor: RFC-CORE-002 §3.2
        """
        motifs = list(self._last_motifs)
        if motifs and hasattr(self.memory, 'retrieve'):
            try:
                recalled = self.memory.retrieve(motifs[-1], top_k=2)
                if recalled:
                    motifs.extend(recalled)
            except Exception:
                log.error("Failed to retrieve from memory", exc_info=True)
                
        if not motifs:
            motifs = ['silence']
            
        return motifs[-3:]

    def extend_feedback_packet(self, packet: Dict[str, Any]) -> Dict[str, Any]:
        """
        Adds entanglement status and other diagnostics to a feedback packet.
        RFC Anchors: RFC-0005 §4.2, RFC-0007 §2.1
        """
        swirl_hash = self.swirl.compute_swirl_hash()
        density_map = self.density.snapshot()
        top_motif = max(density_map.items(), key=lambda x: x[1])[0] if density_map else 'null'
        base_key = top_motif.split('.')[0]
        symbolic_label = SYMBOLIC_PHASE_MAP.get(base_key, 'ψ-null')

        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        tier = 'low' if coherence < 0.8 else 'med' if coherence < 2.5 else 'high'
        phase_id = f"{symbolic_label}-[{tier}]-{swirl_hash[:6]}"
        
        packet['extensions'] = {
            'entanglement_status': {
                'phase': phase_id,
                'swirl_vector': swirl_hash,
                'ρ_top': sorted(density_map.items(), key=lambda kv: -kv[1])[:5]
            }
        }
        return packet
    
    def _crystallize_tick(self, tick: QuantumTickV2) -> CrystallizedMotifBundle:
        """
        Packages a tick into an archival format.
        RFC Anchor: RFC-CORE-002 §8.1
        """
        entropy = TickEntropy(
            decay_slope=self.entropy_slope,
            coherence=self._reward_ema,
            triad_complete=tick.annotations.get('triad_complete', False)
        )
        bundle = CrystallizedMotifBundle(
            motif_bundle=tick.motifs,
            field_signature=tick.extensions.get('field_signature', 'ψ-null@Ξ'),
            tick_entropy=entropy
        )
        return bundle

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Constructs and exports a feedback packet with current agent state.
        RFC Anchors: RFC-0003 §6.2, RFC-0004 §2.5, RFC-0005 §4.2, RFC-0007 §2.1
        """
        tick = self._echo_buffer[-1] if self._echo_buffer else None

        packet = {
            'tick_buffer_size': len(self._echo_buffer),
            'ghost_trace_count': len(self._ghost_traces),
            'recent_reward_ema': self._reward_ema,
            'cadence_interval': self._last_interval,
            'silence_streak': self._silence_streak
        }
        
        self.extend_feedback_packet(packet)
        
        # Pass-through only: if the last emitted tick contains extensions.intent, expose it.
        # This is for observability only and has no behavioral effects here.
        if tick is not None and 'intent' in tick.extensions:
            if 'extensions' not in packet:
                packet['extensions'] = {}
            packet['extensions']['intent'] = tick.extensions['intent']
        
        self.metrics['agent_feedback_export_total'].inc()
        return packet
        
    def _resolve_field(self, motif: str) -> str:
        """Helper to resolve a motif to its symbolic field."""
        if self.symbolic_task_engine and hasattr(self.symbolic_task_engine, 'resolve_presence_field'):
            try:
                result = self.symbolic_task_engine.resolve_presence_field([motif])
                if result:
                    return result
            except Exception:
                pass  # Fallback
        
        if motif in {'silence', 'grief'}:
            return 'ψ-bind@Ξ'
        return 'ψ-resonance@Ξ'

# End_of_File