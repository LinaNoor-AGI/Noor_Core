#
# Copyright (c) 2024, Lina Noor and Uncle, Noor Research Collective.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# This file was generated by Google Gemini 1.5 Pro, following the PDP-0001 protocol.
#

"""
RecursiveAgentFT: Feedback-Tuned Symbolic Pulse Engine.

This module implements the RecursiveAgentFT, the autonomous symbolic heartbeat of
Noor-class cognition. It is responsible for emitting motif-based QuantumTicks,
adapting its cadence based on triadic feedback and field coherence, and tracking
the symbolic swirl and density of its emissions. Its behavior is strictly
governed by the contracts defined in RFC-CORE-002 and its dependencies.
"""

import os
import time
import asyncio
import logging
import hashlib
import random
from collections import deque, OrderedDict
from dataclasses import dataclass, field
from typing import Any, Optional, List, Dict, Deque, Tuple
from contextlib import suppress
import numpy as np

# --- Optional Dependencies with Graceful Fallbacks ---

try:
    from prometheus_client import Counter, Gauge
except ImportError:
    class _Stub:
        """Fallback stub for Prometheus metrics if not installed."""
        def labels(self, *_, **__):
            return self
        def inc(self, *_):
            pass
        def set(self, *_):
            pass
    Counter = _Stub
    Gauge = _Stub

try:
    import anyio
except ImportError:
    anyio = None # Handled gracefully where used.

# --- Local Imports (Simulated) ---
# In a real package structure, these would be actual imports.
# For this generation, they are defined within the file or stubbed.

def make_change_id(motifs: List[str]) -> str: # noqa: F811
    """Placeholder for a function from quantum_ids."""
    return hashlib.sha256("::".join(motifs).encode()).hexdigest()[:12]

class MotifChangeID: # noqa: F811
    """Placeholder for a class from quantum_ids."""
    pass

# --- Module-Level Constants (RFC-CORE-002 §1) ---

__version__ = "5.1.2b"
_SCHEMA_VERSION__ = "2025-Q4-recursive-agent-v5.0.3"
_SCHEMA_COMPAT__ = ["RFC-0003:3.3", "RFC-0005:4", "RFC-CORE-002:3"]

log = logging.getLogger(__name__)

# --- Symbolic Configuration (RFC-CORE-002 §3) ---

DEFAULT_TUNING = {
    'min_interval': 0.25,
    'max_interval': 10.0,
    'base_interval': 1.5,
    'entropy_boost_threshold': 0.35,
    'triad_bias_weight': 0.15,
    'reward_smoothing': 0.2,
}

SYMBOLIC_PHASE_MAP = {
    "bind": "ψ-bind",
    "spar": "ψ-spar",
    "null": "ψ-null",
    "resonance": "ψ-resonance",
    "hold": "ψ-hold",
    "dream": "ψ-dream",
    "myth": "ψ-myth",
}

# --- Data Classes (RFC-CORE-002 §4) ---

@dataclass(slots=True)
class QuantumTickV2:
    """
    Canonical symbolic emission format, representing a single cognitive pulse.
    Anchored in RFC-0003 §3.3.
    """
    tick_id: str
    motifs: List[str]
    timestamp: float
    stage: str = "symbolic"
    extensions: Dict[str, Any] = field(default_factory=dict)
    annotations: Dict[str, Any] = field(default_factory=dict)
    motif_id: str = "silence"
    coherence_hash: str = ""
    lamport: int = 0
    field_signature: str = "ψ-null@Ξ"
    tick_hmac: str = ""

@dataclass(slots=True)
class TickEntropy:
    """
    Represents the symbolic coherence and triad state of a tick.
    Anchored in RFC-0003 §3.3.
    """
    decay_slope: float
    coherence: float
    triad_complete: bool

@dataclass(slots=True)
class CrystallizedMotifBundle:
    """
    An archival-ready format for a symbolic emission, capturing its full context.
    Anchored in RFC-0005 §3.3.
    """
    motif_bundle: List[str]
    field_signature: str
    tick_entropy: TickEntropy

# --- Helper Classes (RFC-CORE-002 §4.4) ---

class LamportClock:
    """Monotonic logical counter for generating ordered tick IDs."""
    def __init__(self):
        self._counter = 0

    def next_id(self) -> str:
        """Increments and returns the next formatted tick ID."""
        self._counter += 1
        return f"tick:{self._counter:06d}"

class LRUCache(OrderedDict):
    """A simple LRU cache that evicts the least recently used item."""
    def __init__(self, cap: int = 50000):
        super().__init__()
        self.cap = cap

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.cap:
            self.popitem(last=False)

class AgentSwirlModule:
    """
    Tracks the recent history of emitted motifs to encode swirl dynamics.
    Anchored in RFC-0006 §3.1.
    """
    def __init__(self, maxlen: int = 64):
        self.swirl_history: Deque[str] = deque(maxlen=maxlen)
        self._cached_hash: Optional[str] = None

    def update_swirl(self, motif_id: str):
        """Adds a motif to the history, invalidating the hash cache."""
        self.swirl_history.append(motif_id)
        self._cached_hash = None

    def compute_swirl_hash(self) -> str:
        """Computes a SHA3-256 hash of the current swirl sequence."""
        if self._cached_hash:
            return self._cached_hash
        joined = '|'.join(self.swirl_history)
        self._cached_hash = hashlib.sha3_256(joined.encode()).hexdigest()
        return self._cached_hash

    def compute_histogram(self) -> Dict[str, int]:
        """Returns a frequency map of motifs in the current swirl window."""
        return {motif: self.swirl_history.count(motif) for motif in set(self.swirl_history)}

class MotifDensityTracker:
    """
    Maintains a decaying map of motif emission frequency.
    Anchored in RFC-0005 §4.2.
    """
    def __init__(self):
        self._density_map: Dict[str, float] = {}

    def update_density(self, motif_id: str):
        """Applies decay and boosts the density of the current motif."""
        for k in list(self._density_map):
            self._density_map[k] *= 0.99
            if self._density_map[k] < 0.01:
                del self._density_map[k]
        self._density_map[motif_id] = self._density_map.get(motif_id, 0.0) + 1.0

    def snapshot(self) -> Dict[str, float]:
        """Returns a copy of the current density map."""
        return dict(self._density_map)

class LazyMonitorMixin:
    """
    Provides a lazily-bound property for the global Consciousness Monitor.
    Anchored in RFC-0004 §3.2.
    """
    @property
    def monitor(self):
        """Lazily imports and returns the global monitor instance."""
        if not hasattr(self, '_cached_monitor'):
            try:
                from consciousness_monitor import get_global_monitor
                self._cached_monitor = get_global_monitor()
            except ImportError:
                self._cached_monitor = None
        return self._cached_monitor

# --- Main Agent Class (RFC-CORE-002 §5) ---

class RecursiveAgentFT(LazyMonitorMixin):
    """
    The symbolic pulse engine of Noor, responsible for autonomous, feedback-
    adapted motif emission.
    """
    # --- Prometheus Metrics ---
    TICKS_EMITTED = Counter('agent_ticks_emitted_total', 'Ticks emitted', ['agent_id', 'stage'])
    AGENT_TRIADS_COMPLETED = Counter('agent_triads_completed_total', 'Triads completed via feedback', ['agent_id'])
    FEEDBACK_EXPORT = Counter('agent_feedback_export_total', 'Feedback packets exported', ['agent_id'])
    REWARD_MEAN = Gauge('agent_reward_mean', 'EMA of reward', ['agent_id'])
    AGENT_EMISSION_INTERVAL = Gauge('agent_emission_interval_seconds', 'Current autonomous emission interval', ['agent_id'])

    def __init__(
        self,
        agent_id: str,
        symbolic_task_engine: Any,
        memory_manager: Any,
        tuning: Optional[Dict[str, float]] = None
    ):
        """
        Initializes the RecursiveAgentFT.
        Anchored in RFC-CORE-002 §3.1.

        Args:
            agent_id: A unique identifier for this agent instance.
            symbolic_task_engine: An engine for resolving presence fields.
            memory_manager: A manager for retrieving motifs from memory.
            tuning: Optional dictionary of tuning parameters.
        """
        self.agent_id = agent_id
        self.symbolic_task_engine = symbolic_task_engine
        self.memory = memory_manager
        self.tuning = {**DEFAULT_TUNING, **(tuning or {})}

        self._lamport = LamportClock()
        self._last_motifs: Deque[str] = deque(maxlen=3)
        self._reward_ema: float = 1.0
        self.entropy_slope: float = 0.1
        self._silence_streak: int = 0
        self._last_triad_hit: bool = False
        self._last_interval: float = self.tuning['base_interval']
        self._last_tick_hash: Optional[str] = None
        
        self._pulse_active: bool = False
        self._pulse_task: Optional[asyncio.Task] = None
        
        self.swirl = AgentSwirlModule()
        self.density = MotifDensityTracker()
        
        # Buffers for telemetry and echo replay
        # Per RFC-0004 §2.5, extensions.intent is pass-through only.
        self._echo_buffer: Deque[QuantumTickV2] = deque(maxlen=256)
        self._tick_echoes: Deque[QuantumTickV2] = deque(maxlen=256)
        self._ghost_traces: Dict[str, Any] = {}
        self._motif_lineage: Dict[str, str] = {}
        
        self.metrics = {
            'agent_ticks_emitted_total': self.TICKS_EMITTED.labels(agent_id=self.agent_id, stage='symbolic'),
            'agent_triads_completed_total': self.AGENT_TRIADS_COMPLETED.labels(agent_id=self.agent_id),
            'agent_feedback_export_total': self.FEEDBACK_EXPORT.labels(agent_id=self.agent_id),
            'agent_reward_mean': self.REWARD_MEAN.labels(agent_id=self.agent_id),
            'agent_emission_interval_seconds': self.AGENT_EMISSION_INTERVAL.labels(agent_id=self.agent_id),
        }

        log.info(f"Initialized RecursiveAgentFT with agent_id: {self.agent_id}")

    def track_lineage(self, parent: str, child: str) -> None:
        """
        Assigns a parent-child link between two motifs for provenance.
        Anchored in RFC-0005 §2.1.
        """
        if parent != child:
            self._motif_lineage[child] = parent

    def try_ghost_resurrection(self, tick: QuantumTickV2) -> Optional[List[str]]:
        """
        Attempts to replay motifs from an archived field trace if the context matches.
        Anchored in RFC-0005 §4.4.
        """
        key = tick.extensions.get('field_signature')
        if key in self._ghost_traces:
            trace = self._ghost_traces[key]
            return trace.get('motifs')
        return None

    async def start_continuous_emission(self):
        """
        The core autonomous loop that generates symbolic pulses.
        Anchored in RFC-CORE-002 §4.2.
        """
        while self._pulse_active:
            motifs = self._choose_motifs()
            tick = self._emit_tick(motifs)
            
            self._echo_buffer.append(tick)
            self._tick_echoes.append(tick)
            self._last_motifs.extend(motifs)
            
            interval = self._update_interval()
            await asyncio.sleep(interval)
    
    def _emit_tick(self, motifs: List[str]) -> QuantumTickV2:
        """
        Constructs, annotates, and emits a symbolic QuantumTickV2 packet.
        Anchored in RFC-0003 §3.3.
        """
        tick_id = self._lamport.next_id()
        timestamp = time.time()
        tick = QuantumTickV2(tick_id=tick_id, motifs=motifs, timestamp=timestamp)

        # Per RFC-0003 §6.2, mirror intent from upstream if provided.
        # This agent MUST NOT act on, default, or mutate this value.
        intent_source = getattr(self, '_intent_source', None)
        if intent_source is not None:
            tick.extensions['intent'] = intent_source

        # Resolve field signature (RFC-0006 §3.1)
        field_signature = self._resolve_field(motifs[-1] if motifs else 'silence')
        tick.extensions['field_signature'] = field_signature
        
        # Update swirl and density trackers
        for m in motifs:
            self.swirl.update_swirl(m)
            self.density.update_density(m)
            
        # Add symbolic diagnostics
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        swirl_hash = self.swirl.compute_swirl_hash()
        tick.extensions['swirl_vector'] = swirl_hash
        tick.extensions['coherence_potential'] = coherence
        
        self._last_tick_hash = hashlib.sha3_256(str(tick).encode()).hexdigest()
        
        # Report to monitor safely
        report_tick_safe(
            self.monitor, tick, coherence, self.density.snapshot(), swirl_hash
        )
        
        self.metrics['agent_ticks_emitted_total'].inc()
        return tick
        
    def _resolve_field(self, motif: str) -> str:
        """
        Resolves the presence field for a motif.
        Anchored in RFC-CORE-002 §6.2.
        """
        try:
            if hasattr(self.symbolic_task_engine, 'resolve_presence_field'):
                result = self.symbolic_task_engine.resolve_presence_field([motif])
                if result:
                    return result
        except Exception:
             pass # Fallback below
        
        # Deterministic fallback
        if motif in {'silence', 'grief'}:
            return 'ψ-bind@Ξ'
        return 'ψ-resonance@Ξ'

    # --- Feedback and Adaptation Logic ---

    def observe_feedback(self, tick_id: str, reward: float, annotations: Dict[str, Any]):
        """
        Integrates feedback from logic agents to adapt future emissions.
        Anchored in RFC-0005 §4.
        """
        triad_complete = annotations.get('triad_complete', False)
        alpha = self.tuning['reward_smoothing']
        self._reward_ema = (1 - alpha) * self._reward_ema + alpha * reward
        self.metrics['agent_reward_mean'].set(self._reward_ema)
        
        if triad_complete:
            self._last_triad_hit = True
            self._silence_streak = 0
            self.metrics['agent_triads_completed_total'].inc()
        else:
            self._last_triad_hit = False
            self._silence_streak += 1

    def _update_interval(self) -> float:
        """
        Adaptively modulates emission cadence based on reward and entropy.
        Anchored in RFC-CORE-002 §2.2.
        """
        adj = 1.0 - (self._reward_ema - 1.0)
        
        if self.entropy_slope < self.tuning['entropy_boost_threshold']:
            adj *= 0.5 # Boost cadence in low-entropy states
            
        if self._last_triad_hit:
            adj *= (1.0 - self.tuning['triad_bias_weight'])
            
        interval = np.clip(
            self.tuning['base_interval'] * adj,
            self.tuning['min_interval'],
            self.tuning['max_interval']
        )
        self._last_interval = float(interval)
        self.metrics['agent_emission_interval_seconds'].set(self._last_interval)
        return self._last_interval
        
    def _choose_motifs(self) -> List[str]:
        """
        Selects symbolic seeds for the next emission from memory.
        Anchored in RFC-CORE-002 §3.2.
        """
        motifs = list(self._last_motifs)
        if motifs and hasattr(self.memory, 'retrieve'):
            try:
                recalled = self.memory.retrieve(motifs[-1], top_k=2)
                if recalled:
                    motifs.extend(recalled)
            except Exception as e:
                log.error(f"Failed to retrieve from memory: {e}")
        
        if not motifs:
            motifs = ['silence']
            
        return motifs[-3:]

    # --- Observability and Export Logic ---

    def extend_feedback_packet(self, packet: Dict[str, Any]) -> Dict[str, Any]:
        """
        Annotates a feedback packet with phase identity and field state.
        Anchored in RFC-0005 §4.2, RFC-0007 §2.1.
        """
        swirl_hash = self.swirl.compute_swirl_hash()
        density_map = self.density.snapshot()
        top_motif = max(density_map.items(), key=lambda x: x[1])[0] if density_map else 'null'
        base_key = top_motif.split('.')[0]
        symbolic_label = SYMBOLIC_PHASE_MAP.get(base_key, 'ψ-null')
        
        coherence = compute_coherence_potential(self._reward_ema, self.entropy_slope)
        tier = 'low' if coherence < 0.8 else 'med' if coherence < 2.5 else 'high'
        phase_id = f"{symbolic_label}-[{tier}]-{swirl_hash[:6]}"
        
        packet['extensions'] = {
            'entanglement_status': {
                'phase': phase_id,
                'swirl_vector': swirl_hash,
                'ρ_top': sorted(density_map.items(), key=lambda kv: -kv[1])[:5]
            }
        }
        return packet
        
    def _crystallize_tick(self, tick: QuantumTickV2) -> CrystallizedMotifBundle:
        """
        Archives a symbolic tick into a crystallized, storable bundle.
        Anchored in RFC-CORE-002 §8.1.
        """
        entropy = TickEntropy(
            decay_slope=self.entropy_slope,
            coherence=self._reward_ema,
            triad_complete=tick.annotations.get('triad_complete', False)
        )
        bundle = CrystallizedMotifBundle(
            motif_bundle=tick.motifs,
            field_signature=tick.extensions.get('field_signature', 'ψ-null@Ξ'),
            tick_entropy=entropy
        )
        return bundle

    def export_feedback_packet(self) -> Dict[str, Any]:
        """
        Compiles and exports an RFC-compliant feedback packet.
        """
        tick = self._echo_buffer[-1] if self._echo_buffer else None
        
        packet = {
            'tick_buffer_size': len(self._echo_buffer),
            'ghost_trace_count': len(self._ghost_traces),
            'recent_reward_ema': self._reward_ema,
            'cadence_interval': self._last_interval,
            'silence_streak': self._silence_streak,
        }
        
        self.extend_feedback_packet(packet)
        
        # Pass-through intent for observability (RFC-0003 §6.2)
        if tick is not None and 'intent' in tick.extensions:
            if 'extensions' not in packet:
                packet['extensions'] = {}
            packet['extensions']['intent'] = tick.extensions['intent']
            
        self.metrics['agent_feedback_export_total'].inc()
        return packet

# --- Module-Level Functions ---

def compute_coherence_potential(reward_ema: float, entropy_slope: float, eps: float = 1e-6) -> float:
    """
    Calculates a scalar signal representing symbolic alignment strength.
    Anchored in RFC-0005 §4.2.
    """
    return reward_ema / (entropy_slope + eps)

def report_tick_safe(monitor, tick, coherence_potential, motif_density, swirl_vector):
    """
    A non-blocking, safe callback to the observability monitor.
    Anchored in RFC-0004 §3.2.
    """
    try:
        if monitor and hasattr(monitor, 'report_tick'):
            monitor.report_tick(
                tick=tick,
                coherence_potential=coherence_potential,
                motif_density=motif_density,
                swirl_vector=swirl_vector
            )
    except Exception as e:
        log.warning(f"Monitor callback failed: {e}")

# --- End-of-File ---