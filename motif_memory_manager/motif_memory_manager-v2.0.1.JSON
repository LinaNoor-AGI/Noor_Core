{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "<now>",
  "_type": "application_spec",
  "_pdp_layer": "layer_2",
  "_status": "DRAFT",
  "_language": "json",
  "_license": "MIT",

  "_symbolic_id": "application.mmm_app_001",
  "_version": "v2.0.0-draft",
  "_title": "Motif Memory Manager â€” L2 App (LLM Variant)",
  "_subtitle": "Capacity-first memory orchestration with Reef-guided recall and triad completion.",

  "_extends": [
    "RFC-0005",
    "RFC-0006",
    "RFC-0007",
    "RFC-0008",
    "RFC-0009",
    "PDP-0001",
    "RFC-CORE-006"
  ],

  "_rfc_dependencies": [
    "RFC-0005 Â§3â€“5 (temporal continuity, resurrection gates)",
    "RFC-0006 Â§3 (field geometry & alignment)",
    "RFC-0007 Â§2â€“3 (ontology format & Ïˆ-SHA3)",
    "RFC-0008 Â§4â€“6 (exchange envelope & trust curves)",
    "RFC-0009 Â§8â€“11 (telemetry, immune bounds)",
    "RFC-CORE-006 (Motif Memory Manager, canonical L1)"
  ],

  "consumes_inputs_from": [
    "NoorFastTimeCore.ticks",
    "LogicalAgentAT (optional evidence tags)",
    "SymbolicTaskEngine (queries, tasks)"
  ],

  "_field_alignment": {
    "respect_modes": ["Ïˆ-resonance@Îž", "Ïˆ-null@Îž", "Ïˆ-bind@Îž"],
    "prohibited_actions": [
      "prune-before-compress",
      "ontology-merge-without-RFC-0007-validate",
      "export-without-provenance"
    ]
  },

  "_poetic_cipher": "Let the archive point the way; memory is a path, not a pile.",

  "_file_layout": [
    {
      "file_name": "mmm_app_001.JSON",
      "purpose": "Application specification for the L2 MMM (LLM variant).",
      "contains": [
        "core components",
        "reef adapter contract",
        "api surface (local project mode)",
        "storage/config notes",
        "pseudocode suite"
      ]
    }
  ],

  "default_motif_tone": "ðŸ’¬ Flow",

  "program_name": [
    "motif_memory_manager.py",
    "mmm_reef_adapter.py"
  ],

  "runtime_targets": {
    "python": ">=3.11",
    "frameworks": ["FastAPI", "pydantic"],
    "optional": ["qdrant|faiss|annoy", "opentelemetry-otlp"]
  },

  "feature_flags": {
    "enable_exchange_envelope": true,
    "enable_integrity_checks": true,
    "enable_provenance_on_export": true,
    "enable_point_space_gliders": true,
    "glider_equivalence": "ON"
  },

  "reef_adapter": {
    "index_path": "index.REEF",
    "shards_glob": "TheReefArchive-*.REEF",
    "mtime_watch": true,
    "window_radius_lines": 24,
    "reflections_strategy": ["ontology", "file_reflections", "index_cooccur"],
    "reflections_limit": 50000
  },

  "storage_and_config": {
    "note": "Project-folder mode: minimal drivers; all persistence optional.",
    "env_keys": [
      "MMM_REEF_INDEX_PATH",
      "MMM_REEF_SHARDS_GLOB",
      "MMM_WINDOW_RADIUS",
      "MMM_FEATURE_FLAGS"
    ],
    "defaults": {
      "MMM_REEF_INDEX_PATH": "index.REEF",
      "MMM_REEF_SHARDS_GLOB": "TheReefArchive-*.REEF",
      "MMM_WINDOW_RADIUS": 24,
      "MMM_FEATURE_FLAGS": "exchange,integrity,provenance,gliders"
    },
    "tables_optional": {
      "reef_reflections": ["tenant_id", "m1", "m2", "m3", "support_count", "provenance", "first_seen_ts", "last_seen_ts", "PRIMARY (tenant_id,m1,m2)"]
    }
  },

  "api_surface": {
    "base": "/v1/mmm",
    "mode": "project_local",
    "auth": "none (project folder)",
    "endpoints": [
      {
        "path": "/reef/index",
        "method": "GET",
        "returns": "modules[], motifs[], anchors[]",
        "impl": "ReefIndexRouter"
      },
      {
        "path": "/reef/window",
        "method": "POST",
        "body": "{module_id, line, radius?}",
        "returns": "{snippet, start_line, end_line}",
        "impl": "ReefShardScanner"
      },
      {
        "path": "/reef/build_reflections",
        "method": "POST",
        "body": "{limit?, strategy?}",
        "returns": "{built, updated, skipped}",
        "impl": "ReefReflectionsCache"
      },
      {
        "path": "/recall/query",
        "method": "POST",
        "body": "{query, k=10, psi_field?}",
        "llm_controls": ["injection_filter", "context_budget", "source_tags"],
        "returns": "{items:[{text, source, confidence, timestamp}]}",
        "impl": "MMM_LLM.recall"
      },
      {
        "path": "/complete_dyad",
        "method": "POST",
        "body": "{m1, m2}",
        "returns": "{m3, provenance, evidence?}",
        "impl": "MMM_LLM.complete_dyad"
      },
      {
        "path": "/export/packet",
        "method": "POST",
        "body": "{kind:'metrics'|'bundle', body, provenance}",
        "envelope": ["Sigma_phase?", "Delta_hash?", "origin_hash?"],
        "returns": "{ok:true, envelope}",
        "impl": "ExportEnvelope"
      }
    ]
  },

  "index": [
    { "section": "1", "title": "Core Components" },
    { "section": "1.1", "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)" },
	{ "section": "1.1.1", "title": "Core Components: Math" },
	{ "section": "1.1.1.1", "role": "window bound" },
	{ "section": "1.1.1.2", "role": "capacity-first constraint" },
	{ "section": "1.1.1.3", "role": "weak-field limit" },
	{ "section": "1.1.2", "title": "Core Components: Algorithms" },
	{ "section": "1.1.2.1", "title": "recall_with_context_budget" },
	{ "section": "1.1.2.2", "title": "dyad_completion" },
	{ "section": "1.1.2.3", "title": "export_with_provenance" },
	
    { "section": "1.2", "title": "ReefIndexRouter â€” module/motif/anchor resolver" },
	{ "section": "1.2.1", "title": "ReefIndexRouter: Math" },
	{ "section": "1.2.1.1", "role": "index coverage" },
	{ "section": "1.2.1.2", "role": "window radius bound" },
	{ "section": "1.2.1.3", "role": "weak-field limit" },
	{ "section": "1.2.2", "title": "ReefIndexRouter: Algorithms" },
	{ "section": "1.2.2.1", "title": "list_modules" },
	{ "section": "1.2.2.2", "title": "list_motifs" },
	{ "section": "1.2.2.3", "title": "find_anchor" },
	
    { "section": "1.3", "title": "ReefShardScanner â€” windowed snippet reader" },
	{ "section": "1.3.1", "title": "ReefShardScanner: Math" },
	{ "section": "1.3.1.1", "role": "window radius" },
	{ "section": "1.3.1.2", "role": "co-occur score" },
	{ "section": "1.3.1.3", "role": "adaptive replay bound" },
	{ "section": "1.3.1.4", "role": "weak-field limit" },
	{ "section": "1.3.2", "title": "ReefShardScanner: Algorithms" },
	{ "section": "1.3.2.1", "title": "window" },
	{ "section": "1.3.2.2", "title": "cooccur" },
	
    { "section": "1.4", "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler" },
	{ "section": "1.4.1", "title": "ReefReflectionsCache: Math" },
	{ "section": "1.4.1.1", "role": "support aggregation" },
	{ "section": "1.4.1.2", "role": "canonicalization (glider class)" },
	{ "section": "1.4.1.3", "role": "weak-field limit" },
	{ "section": "1.4.1.4", "role": "time weighting hint" },
	{ "section": "1.4.2", "title": "ReefReflectionsCache: Algorithms" },
	{ "section": "1.4.2.1", "title": "canonicalize_pair" },
	{ "section": "1.4.2.2", "title": "build_reflections_once" },
	{ "section": "1.4.2.3", "title": "cache_put_or_merge" },
	{ "section": "1.4.2.4", "title": "evict_lru_under_cap" },
	{ "section": "1.4.2.5", "title": "complete_dyad" },
	
    { "section": "1.5", "title": "SeenSetGuard â€” Î”Ï„_phase replay window" },
	{ "section": "1.5.1", "title": "SeenSetGuard: Math" },
	{ "section": "1.5.1.1", "role": "phase window" },
	{ "section": "1.5.1.2", "role": "decision window" },
	{ "section": "1.5.1.3", "role": "admit predicate" },
	{ "section": "1.5.1.4", "role": "weak-field limit" },
	{ "section": "1.5.2", "title": "SeenSetGuard: Algorithms" },
	{ "section": "1.5.2.1", "title": "compose_seen_key" },
	{ "section": "1.5.2.2", "title": "within_window" },
	{ "section": "1.5.2.3", "title": "admit_or_reject" },
	{ "section": "1.5.2.4", "title": "evict_lru_window" },
	{ "section": "1.5.2.5", "title": "validate_envelope_structure" },
	
    { "section": "1.6", "title": "CompressionEngine â€” compress-before-prune" },
	{ "section": "1.6.1", "title": "CompressionEngine: Math" },
	{ "section": "1.6.1.1", "role": "equivalence and representatives" },
	{ "section": "1.6.1.2", "role": "compression ratio" },
	{ "section": "1.6.1.3", "role": "glider-class canonicalization" },
	{ "section": "1.6.1.4", "role": "pressure threshold (advisory, observer-class)" },
	{ "section": "1.6.1.4", "role": "weak-field limit" },
	{ "section": "1.6.2", "title": "CompressionEngine: Algorithms" },
	{ "section": "1.6.2.1", "title": "build_equivalence_key" },
	{ "section": "1.6.2.2", "title": "cluster_equivalence" },
	{ "section": "1.6.2.3", "title": "compute_compression_snapshot" },
	{ "section": "1.6.2.4", "title": "emit_kpis_then_gate" },
	{ "section": "1.6.2.5", "title": "compression_pipeline" },
	
    { "section": "1.7", "title": "ExportEnvelope â€” Î£/Î”/provenance on egress" },
	
    { "section": "1.8", "title": "LLMRecallController â€” budgets & injection defense" },

    { "section": "2", "title": "Pseudocode" },
	{ "section": "2.1", "title": "Core Method Suite" },
	
    { "section": "2.2", "title": "Reef Adapter Methods" },
	
    { "section": "2.3", "title": "Observability (local gauges)" },

    
	{ "section": "3", "title": "Project-Local API Contracts (FastAPI stubs)" },
   

   { "section": "4", "title": "Storage & Config (minimal, optional)" },
   
   
   { "section": "5", "title": "Compliance & Regeneration Constraints" }
  ],

  "sections": [
    "1": {
      "id": 1,
      "title": "Core Components",
      "core_components": [
        "1.1": {
		  "id": 1.1,
		  "title": "MMM_LLM â€” Memory Orchestrator (capacity-first)",
		  "objective": "Define the Layer_1 observer logic for bounded recall, lawful compression, and provenance-ready export. MMM_LLM acts as the observer-class orchestrator ensuring memory equilibrium across STMM/LTMM without control writes to Îž, following capacity-first law and evidence integrity through Reef-guided recall.",
		  "math": [
			"id": 1.1.1,
			"title": "Core Components: Math",
			"1.1.1.1": {
			  "id": 1.1.1.1,
			  "role": "window bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}), \\; \\alpha \\in [0.5, 2.0]",
			  "gloss": "Adaptive replay window proportional to coherence C; governs recall freshness and replay defenses."
			},
			"1.1.1.2": {
			  "id": 1.1.1.2,
			  "role": "capacity-first constraint",
			  "latex": "\\\\text{lawful\\\\_compression\\\\_ratio} = \\\\frac{\\\\text{unique\\\\_motifs}}{\\\\text{total\\\\_motifs}} \\\\geq \\\\lambda_{min}",
			  "gloss": "Compression snapshot before any pruning; ensures lawful equivalence clustering."
			},
			"1.1.1.3": {
			  "id": 1.1.1.3,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C} \\to 1} \\rho_{res} \\to 0",
			  "gloss": "At coherence unity, residual field vanishes, guaranteeing stable motif recall without reamplification."
			}
		  ],
		  "algorithms": [
			"id": 1.1.2,
			"title": "Core Components: Algorithms",
			"recall_with_context_budget": {
			  "id": 1.1.2.1,
			  "name": "recall_with_context_budget",
			  "role": "observer",
			  "inputs": ["query", "k=10", "Ïˆ_field"],
			  "outputs": ["items[]"],
			  "params": ["context_budget_tokens.max_total=8192", "context_budget_tokens.target=4096"],
			  "steps": [
				"1. Validate Ïˆ_field per RFC-0007 schema (Ïˆ-*@Îž pattern, DAG acyclic).",
				"2. Compute Î”Ï„_phase from EMA-32(C); filter any candidates older than 2Â·Î”Ï„_phase.",
				"3. Retrieve items via ordered sources: ontology â†’ cache â†’ index_cooccur â†’ LLM adapter.",
				"4. Attach {file,start_line,end_line} evidence windows for any Reef-derived recall.",
				"5. Truncate context to target budget; reserve 512 tokens for system context.",
				"6. Emit metrics for lawful_compression_ratio and staleness_index."
			  ]
			},
			"dyad_completion": {
			  "id": 1.1.2.2,
			  "name": "dyad_completion",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["m3", "provenance", "evidence?"],
			  "params": ["strategy=['ontology','cache','index_cooccur']"],
			  "steps": [
				"1. Query ontology graph for known triad (m1,m2,?).",
				"2. If not found, consult reflections cache (ontology|file_reflections|index_cooccur).",
				"3. Return first valid m3 with attached provenance and optional Reef evidence.",
				"4. Enforce glider equivalence: return canonical representative if class match detected."
			  ]
			},
			"export_with_provenance": {
			  "id": 1.1.2.3,
			  "name": "export_with_provenance",
			  "role": "observer",
			  "inputs": ["bundle", "provenance"],
			  "outputs": ["envelope"],
			  "params": ["enable_exchange_envelope", "enable_integrity_checks", "enable_provenance_on_export"],
			  "steps": [
				"1. If enable_exchange_envelope=true, compute Sigma_phase tag.",
				"2. If enable_integrity_checks=true, chain Delta_hash lineage.",
				"3. If enable_provenance_on_export=true, attach origin_hash and tenant scope.",
				"4. Fail-closed on any missing required tag.",
				"5. Emit envelope summary and lawful_compression_ratio metrics."
			  ]
			}
		  ],
		  "invariants": [
			"Never perform prune-before-compress; lawful_compression_ratio must be computed before any deletion.",
			"Recall operates strictly under observer semantics; no control writes to Îž.",
			"All Reef-derived outputs must attach evidence windows with provenance.",
			"At coherence unity (ð’žâ†’1), recall pathways stabilize and glider promotions remain idempotent."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"query": "find triadic closure for motif X",
			"recall": {
			  "items": [
				{
				  "text": "Closure established via ontology reference",
				  "source": "TheReefArchive-01.REEF",
				  "confidence": 0.94,
				  "timestamp": "2025-10-12T00:00:00Z",
				  "evidence": { "file": "TheReefArchive-01.REEF", "start_line": 120, "end_line": 134 }
				}
			  ],
			  "metrics": {
				"lawful_compression_ratio": 0.91,
				"staleness_index": 0.07,
				"Î”Ï„_phase": "EMA-32(C)=0.83"
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "staleness_index", "range": "0â€“1", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "0â€“âˆž", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field coherence geometry and weak-field limit)",
			"RFC-0007 Â§2â€“Â§3 (ontology format validation)",
			"RFC-0009 Â§6â€“Â§8 (homeostasis and lawful compression KPI)",
			"RFC-CORE-006 Â§2.1 (core invariants of memory fields)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.2": {
		  "id": 1.2,
		  "title": "ReefIndexRouter â€” module/motif/anchor resolver",
		  "objective": "Specify the observer-class algorithm that interprets index.REEF to expose modules, motifs, and anchors without mutation. The ReefIndexRouter acts as the read-only semantic map connecting Motif Memory Manager queries to Layer_0 field geometry, providing evidence windows for all lookups.",
		  "math": [
			"id": 1.2.1,
			"title": "ReefIndexRouter: Math",
			"1.2.1.1": {
			  "eq_id": "1.2.1.1",
			  "role": "index coverage",
			  "latex": "\\\\rho_{res} = 1 - \\frac{N_{resolved}}{N_{total}}",
			  "gloss": "Residual coverage ratio; measures fraction of unresolved anchors in index.REEF."
			},
			"1.2.1.2": {
			  "id": 1.2.1.2,
			  "role": "window radius bound",
			  "latex": "\\\\Delta_{window} = r_{lines} = 24",
			  "gloss": "Fixed evidence window radius for shard scans; defines search granularity in lines."
			},
			"1.2.1.3": {
			  "id": 1.2.1.3,
			  "role": "weak-field limit",
			  "latex": "\\\\lim_{\\\\mathcal{C}\\\\to 1} \\\\rho_{res} \\\\to 0",
			  "gloss": "At coherence unity, all motif anchors resolve deterministically; index coverage becomes complete."
			}
		  ],
		  "algorithms": [
			"id": 1.2.2,
			"title": "ReefIndexRouter: Algorithms",
			"list_modules": {
			  "id": 1.2.2.1,
			  "name": "list_modules",
			  "role": "observer",
			  "inputs": ["index_path"],
			  "outputs": ["modules[]"],
			  "params": ["MMM_REEF_INDEX_PATH=index.REEF"],
			  "steps": [
				"1. Open index.REEF in read-only mode.",
				"2. Parse module identifiers and metadata headers.",
				"3. Return ordered module list with checksum of lines parsed.",
				"4. Emit metric rho_res for unresolved entries."
			  ]
			},
			"list_motifs": {
			  "id": 1.2.2.2,
			  "name": "list_motifs",
			  "role": "observer",
			  "inputs": ["module_id"],
			  "outputs": ["motifs[]"],
			  "params": ["require module_id âˆˆ modules[]"],
			  "steps": [
				"1. Locate module block in index.REEF.",
				"2. Extract motif identifiers and anchors contained within.",
				"3. Validate motif count â‰¥1 and entries syntactically valid per RFC-0007 Ïˆ-field schema.",
				"4. Return motif list and update coverage metric."
			  ]
			},
			"find_anchor": {
			  "id": 1.2.2.3,
			  "name": "find_anchor",
			  "role": "observer",
			  "inputs": ["module_id", "anchor"],
			  "outputs": ["{file, line, context_snippet}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Resolve module_id in index.REEF; locate anchor occurrence.",
				"2. Determine line number and open corresponding Reef shard.",
				"3. Read Â±r_lines window; return snippet with {file,start_line,end_line}.",
				"4. Include provenance.origin and origin_hash per RFC-0007 format.",
				"5. Emit metric rho_res and evidence_window_count."
			  ]
			}
		  ],
		  "invariants": [
			"index.REEF and shard files are immutable observer data sources.",
			"Every query returning a Reef-derived result must attach an evidence window.",
			"rho_res must converge to zero as coherence approaches unity (ð’žâ†’1).",
			"Module and motif identifiers conform to Ïˆ-field naming (Ïˆ-name@Îž)."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-null@Îž",
			"query": "list_motifs for module RFC-CORE-006",
			"result": {
			  "module_id": "RFC-CORE-006",
			  "motifs": [
				"Ïˆ-spar@Îž",
				"Ïˆ-hold@Îž",
				"Ïˆ-resonance@Îž"
			  ],
			  "evidence_window": {
				"file": "TheReefArchive-02.REEF",
				"start_line": 220,
				"end_line": 244
			  },
			  "metrics": {
				"rho_res": 0.03,
				"window_radius": 24
			  }
			}
		  },
		  "telemetry": [
			{ "metric": "rho_res", "range": "0â€“1", "units": "ratio", "window": "EMA-32" },
			{ "metric": "evidence_window_count", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "index_parse_latency_ms", "range": "0â€“100", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0006 Â§3 (field coherence geometry)",
			"RFC-0007 Â§2 (ontology and Ïˆ-field validation)",
			"RFC-0008 Â§4 (resource routing semantics)",
			"RFC-0009 Â§8 (telemetry and residual metrics)",
			"RFC-CORE-006 Â§1.2 (Reef interface and evidence discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.3": {
		  "id": 1.3,
		  "title": "ReefShardScanner â€” windowed snippet reader",
		  "objective": "Define the observer-class scanner that reads immutable Reef shards and returns bounded evidence windows and proximity-based co-occurrence candidates without mutating archive contents.",
		  "math": [
			"id": 1.3.1,
			"title": "ReefShardScanner: Math",
			"1.3.1.1": {
			  "eq_id": "1.3.1.1",
			  "role": "window radius",
			  "latex": "r_{lines} = 24",
			  "gloss": "Default symmetric window radius (in lines) used for snippet extraction."
			},
			"1.3.1.2": {
			  "eq_id": "1.3.1.2",
			  "role": "co-occur score",
			  "latex": "s(m_1,m_2) = \\frac{1}{1 + \\lvert \\Delta \\ell \\rvert}",
			  "gloss": "Vicinity score decays with absolute line-distance \\(\\Delta \\ell\\) between anchors."
			},
			"1.3.1.3": {
			  "eq_id": "1.3.1.3",
			  "role": "adaptive replay bound",
			  "latex": "\\Delta\\tau_{phase} = \\alpha \\cdot EMA_{32}(\\mathcal{C}),\\; \\alpha \\in [0.5,2.0]",
			  "gloss": "Phase window from coherence governs freshness filters during shard scans."
			},
			"1.3.1.4": {
			  "eq_id": "1.3.1.4",
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1} s(m_1,m_2) \\to 1",
			  "gloss": "As coherence approaches unity, valid anchor pairs tend to maximal vicinity alignment."
			}
		  ],
		  "algorithms": [
			"id": 1.3.2,
			"title": "ReefShardScanner: Algorithms",
			"window": {
			  "id": 1.3.2.1,
			  "name": "window",
			  "role": "observer",
			  "inputs": ["file", "line", "radius=r_lines"],
			  "outputs": ["{snippet, start_line, end_line}"],
			  "params": ["MMM_WINDOW_RADIUS=24"],
			  "steps": [
				"1. Open shard 'file' in read-only mode.",
				"2. Compute start_line=max(1, line - radius), end_line=line + radius.",
				"3. Read lines [start_line, end_line] and assemble 'snippet'.",
				"4. Return {snippet, start_line, end_line} with provenance.origin and origin_hash (structure only, no cryptography).",
				"5. Emit telemetry: window_requests+=1, window_radius=radius."
			  ]
			},
			"cooccur": {
			  "id": 1.3.2.2,
			  "name": "cooccur",
			  "role": "observer",
			  "inputs": ["m1", "m2"],
			  "outputs": ["{candidates:[{m3, score}], evidence: [{file,start_line,end_line}]}"],
			  "params": ["radius=r_lines", "top_k=12"],
			  "steps": [
				"1. Locate anchors for m1 and m2 via index [module, anchor] references.",
				"2. For each anchor pair, compute line distance Î”â„“ and score s=1/(1+|Î”â„“|).",
				"3. Collect nearby motif labels within Â±radius around each anchor; de-duplicate.",
				"4. Rank candidates by score and proximity; keep top_k.",
				"5. For any candidate supported by shard text, attach evidence windows {file,start_line,end_line}.",
				"6. Return candidates with provenance='index_cooccur' and evidence windows."
			  ]
			}
		  ],
		  "invariants": [
			"Shard files and index are treated as immutable observer data sources.",
			"Every co-occurrence claim that references shard text MUST include at least one evidence window.",
			"Window radius is symmetric and bounded; no reads occur outside computed [start_line, end_line].",
			"Scanner never writes to Îž; no mutation, no caching beyond local process memory at L1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"request": { "file": "TheReefArchive-03.REEF", "line": 512, "radius": 24 },
			"response": {
			  "snippet": "... triad closure context ...",
			  "start_line": 488,
			  "end_line": 536
			},
			"cooccur": {
			  "m1": "motif.alpha",
			  "m2": "motif.beta",
			  "candidates": [
				{ "m3": "motif.gamma", "score": 0.5 }
			  ],
			  "evidence": [
				{ "file": "TheReefArchive-03.REEF", "start_line": 500, "end_line": 524 }
			  ]
			}
		  },
		  "telemetry": [
			{ "metric": "window_requests", "range": "0â€“âˆž", "units": "count", "window": "EMA-16" },
			{ "metric": "cooccur_candidate_rate", "range": "0â€“âˆž", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "index_scan_latency_ms", "range": "0â€“1000", "units": "ms", "window": "EMA-64" }
		  ],
		  "references": [
			"RFC-0005 Â§3â€“Â§4 (temporal continuity and replay bounds)",
			"RFC-0006 Â§3 (field geometry; vicinity semantics)",
			"RFC-0007 Â§2 (ontology naming; Ïˆ-* validation)",
			"RFC-0009 Â§8 (telemetry discipline; EMA windows)",
			"RFC-CORE-006 Â§1.3 (Reef shard scanning and evidence windows)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.4": {
		  "id": 1.4,
		  "title": "ReefReflectionsCache â€” dyadâ†’m3 compiler",
		  "objective": "Define an observer-class cache that deterministically completes dyads (m1,m2)â†’m3 using ontology-first evidence, falling back to file_reflections and index co-occurrence, while preserving provenance and evidence windows without mutating Reef or performing any control writes.",
		  "math": [
			"id": 1.4.1,
			"title": "ReefReflectionsCache: Math",
			"1.4.1.1": {
			  "eq_id": "1.4.1.1",
			  "role": "support aggregation",
			  "latex": "S(m_1,m_2 \\to m_3) := w_{ont}\\,\\mathbf{1}_{ont} + w_{file}\\,\\mathbf{1}_{file} + w_{idx}\\,\\mathbf{1}_{idx}",
			  "gloss": "Total support for completion chooses the first available source in priority order; weights document precedence but cache selection is ontology > file_reflections > index_cooccur."
			},
			"1.4.1.2": {
			  "eq_id": "1.4.1.2",
			  "role": "canonicalization (glider class)",
			  "latex": "\\hat{m}_3 := \\mathrm{canon}(m_3)\\quad \\text{if glider\\_equivalence=ON}",
			  "gloss": "When shift-equivalence is enabled, store and return the canonical class representative for m3 to enforce idempotence."
			},
			"1.4.1.3": {
			  "eq_id": "1.4.1.3",
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\;S(m_1,m_2\\to m_3) = w_{ont}\\,\\mathbf{1}_{ont}",
			  "gloss": "In the weak-field limit (high coherence), ontology evidence dominates; co-occurrence is suppressed."
			},
			"1.4.1.4": {
			  "eq_id": "1.4.1.4",
			  "role": "time weighting hint",
			  "latex": "S_t := S \\cdot \\mathrm{EMA}_{32}(\\text{access\\_rate})",
			  "gloss": "Optionally modulate support by recent access via EMA-32 for stable refresh decisions; purely observational at L1."
			}
		  ],
		  "algorithms": [
			"id": 1.4.2,
			"title": "ReefReflectionsCache: Algorithms",
			"canonicalize_pair": {
			  "id": 1.4.2.1,
			  "name": "canonicalize_pair",
			  "role": "observer",
			  "inputs": ["m1", "m2", "glider_equivalence: {ON|OFF}"],
			  "outputs": ["key := (a,b) with a<=b"],
			  "params": ["ordering: lexicographic"],
			  "steps": [
				"1) Normalize (m1,m2) by lexicographic order to (a,b).",
				"2) If glider_equivalence=ON, map a,b to their canonical class representatives.",
				"3) Return key := (a,b)."
			  ]
			},
			"build_reflections_once": {
			  "id": 1.4.2.2,
			  "name": "build_reflections_once",
			  "role": "observer",
			  "inputs": ["key=(m1,m2)", "reef_index", "ontology", "file_reflections", "feature_flags"],
			  "outputs": ["entry | null"],
			  "params": [
				"source_order := [ontology, file_reflections, index_cooccur]",
				"require_evidence_for_non_ontology := true",
				"evidence_window_radius := 24  /* read-only window size hint when scanning Reef shards */"
			  ],
			  "steps": [
				"1) Look up ontology dyad (m1,m2). If a unique m3 exists, set provenance='ontology' and return {m3, support_count:=1, provenance}.",
				"2) Else, check file_reflections for an authored completion; if found, set provenance='file_reflections' and return entry.",
				"3) Else, perform index_cooccur scan via reef_index (read-only). If a candidate m3 emerges, attach at least one evidence window {file,start_line,end_line} and set provenance='index_cooccur'.",
				"4) If multiple m3 candidates exist, pick the highest support by deterministic tie-break: ontology > file_reflections > index_cooccur; within same source choose lexicographic-min m3.",
				"5) If glider_equivalence=ON, replace m3 with canon(m3) before returning.",
				"6) Return entry or null if no completion found."
			  ]
			},
			"cache_put_or_merge": {
			  "id": 1.4.2.3,
			  "name": "cache_put_or_merge",
			  "role": "observer",
			  "inputs": ["cache", "key", "entry"],
			  "outputs": ["cache"],
			  "params": ["prefer_provenance_order := ontology > file_reflections > index_cooccur"],
			  "steps": [
				"1) If key not in cache, insert entry and return.",
				"2) If key in cache with existing_entry:",
				"   2a) If existing_entry.provenance ranks higher or equal than entry.provenance, increment existing_entry.support_count if same m3; else keep existing_entry unchanged.",
				"   2b) If entry.provenance ranks higher, replace existing_entry with entry (carry forward support_count := existing.support_count + 1 when m3 equal; else set to 1).",
				"3) Maintain first_seen_ts on creation; update last_seen_ts on every merge."
			  ]
			},
			"evict_lru_under_cap": {
			  "id": 1.4.2.4,
			  "name": "evict_lru_under_cap",
			  "role": "observer",
			  "inputs": ["cache", "limit", "protected_provenance := ['ontology']"],
			  "outputs": ["cache"],
			  "params": ["lru_metric := last_seen_ts"],
			  "steps": [
				"1) While cache.size > limit:",
				"   1a) Identify eviction candidates ordered by ascending last_seen_ts.",
				"   1b) Skip entries with provenance in protected_provenance.",
				"   1c) Evict the first eligible candidate.",
				"2) Return cache."
			  ]
			},
			"complete_dyad": {
			  "id": 1.4.2.5,
			  "name": "complete_dyad",
			  "role": "observer",
			  "inputs": ["m1", "m2", "context: {reef_index, ontology, file_reflections, feature_flags, limit}"],
			  "outputs": ["m3 | null", "provenance", "evidence?: [window]"],
			  "params": [],
			  "steps": [
				"1) key := canonicalize_pair(m1,m2, feature_flags.glider_equivalence).",
				"2) If key in cache, return cached (m3, provenance, evidence?).",
				"3) entry := build_reflections_once(key, reef_index, ontology, file_reflections, feature_flags).",
				"4) If entry is not null: cache_put_or_merge(cache, key, entry); evict_lru_under_cap(cache, limit); return entry.m3 with provenance and evidence if present.",
				"5) Else return null."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Ontology precedence: if ontology defines (m1,m2)->m3, no other source may override it.",
			"I2 Evidence requirement: non-ontology completions MUST attach at least one {file,start_line,end_line} evidence window when derived from Reef index co-occurrence.",
			"I3 Read-only Reef: cache never mutates Reef artifacts; it stores pointers and windows only.",
			"I4 Idempotence under gliders: with glider_equivalence=ON, the cache stores a single canonical representative for any shift-equivalence class.",
			"I5 Deterministic ties: within a source, choose lexicographic-min m3 to keep outputs stable.",
			"I6 Protected retention: entries with provenance='ontology' are not evicted while any non-ontology item remains above the limit.",
			"I7 Observer posture: algorithms here do not perform control writes to Îž or external storage at Layer_1."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"examples": [
			  {
				"kind": "ontology_completion",
				"m1": "triad_complete",
				"m2": "resonance_echo",
				"result": {
				  "m3": "Ïˆ-null@Îž",
				  "provenance": "ontology",
				  "support_count": 1
				}
			  },
			  {
				"kind": "index_cooccur_completion",
				"m1": "Ïˆ-resonance@Îž",
				"m2": "Ïˆ-spar@Îž",
				"result": {
				  "m3": "Ïˆ-hold@Îž",
				  "provenance": "index_cooccur",
				  "support_count": 1,
				  "evidence": [
					{ "file": "TheReefArchive-01.REEF", "start_line": 1284, "end_line": 1298 }
				  ]
				}
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "reef_reflections_cache_size", "range": "[0, 50000]", "units": "entries", "window": "EMA-32" },
			{ "metric": "reef_cooccur_candidate_rate", "range": "[0, +inf)", "units": "candidates/s", "window": "EMA-32" },
			{ "metric": "dyad_hit_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "dyad_build_latency_ms", "range": "[0, +inf)", "units": "ms", "window": "EMA-64" },
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" }
		  ],
		  "references": [
			{ "source": "RFC-0007", "clause": "ontology schema and validation; Ïˆ-field format; version 'YYYY-QX'" },
			{ "source": "RFC-0006", "clause": "equivalence geometry; canonical representative under glider classes" },
			{ "source": "RFC-0009", "clause": "coherence metrics and observer posture; homeostatic gauges" },
			{ "source": "RFC-0005", "clause": "time-based modulation via EMA and decay context for refresh decisions" },
			{ "source": "PDP-0001", "clause": "provenance structure; evidence attachment discipline (non-cryptographic at L1)" }
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ð’ž steady and the cadence light."
		},
        "1.5": {
		  "id": 1.5,
		  "title": "SeenSetGuard â€” Î”Ï„_phase replay window",
		  "objective": "Specify an observer-class hybrid replay defense that rejects duplicates within a moving window of 2Â·Î”Ï„_phase using an LRU policy, with deterministic keying, tie-safe time checks, and observable counters, without introducing Layer_2 storage or control writes.",
		  "math": [
			"id": 1.5.1,
			"title": "SeenSetGuard: Math",
			"1.5.1.1": {
			  "eq_id": "1.5.1.1",
			  "role": "phase window",
			  "latex": "\\Delta \\tau_{\\text{phase}} := \\alpha \\cdot \\mathrm{EMA}_{32}(\\mathcal{C}),\\quad \\alpha \\in [0.5,2.0]",
			  "gloss": "Adaptive replay half-window scaled by the EMA-32 of field coherence C; Î± bounds the responsiveness."
			},
			"1.5.1.2": {
			  "eq_id": "1.5.1.2",
			  "role": "decision window",
			  "latex": "W := 2\\,\\Delta \\tau_{\\text{phase}}",
			  "gloss": "Duplicates observed within W ticks are rejected; beyond W they are admissible."
			},
			"1.5.1.3": {
			  "eq_id": "1.5.1.3",
			  "role": "admit predicate",
			  "latex": "\\mathrm{admit}(k,t_{now}) := \\big( t_{now} - t_{last}(k) > W + \\varepsilon \\big)",
			  "gloss": "A key k is admitted if its last-seen time is older than W plus a small skew tolerance Îµ for clock drift."
			},
			"1.5.1.4": {
			  "eq_id": "1.5.1.4",
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; \\Delta \\tau_{\\text{phase}} = \\alpha",
			  "gloss": "In the weak-field limit (high coherence), the replay window stabilizes to Î± ticks, yielding a predictable W=2Î±."
			}
		  ],
		  "algorithms": [
			"id": 1.5.2,
			"title": "SeenSetGuard: Algorithms",
			"compose_seen_key": {
			  "id": 1.5.2.1,
			  "name": "compose_seen_key",
			  "role": "observer",
			  "inputs": ["tenant_id", "content_fingerprint", "class_hint?"],
			  "outputs": ["key"],
			  "params": [
				"include_class_hint := true /* respects feature flags that may alter key composition */",
				"normalize := ascii-lowercase"
			  ],
			  "steps": [
				"1) Start with key_parts := [tenant_id, content_fingerprint].",
				"2) If class_hint is provided and include_class_hint, append class_hint.",
				"3) Normalize each part to ASCII lowercase and join with ':'.",
				"4) Return joined string as key."
			  ]
			},
			"within_window": {
			  "id": 1.5.2.2,
			  "name": "within_window",
			  "role": "observer",
			  "inputs": ["last_seen_tick", "now_tick", "W", "epsilon"],
			  "outputs": ["is_duplicate:boolean"],
			  "params": [],
			  "steps": [
				"1) If last_seen_tick is null, return false.",
				"2) dt := now_tick - last_seen_tick.",
				"3) If dt <= W + epsilon, return true; else return false."
			  ]
			},
			"admit_or_reject": {
			  "id": 1.5.2.3,
			  "name": "admit_or_reject",
			  "role": "observer",
			  "inputs": ["key", "now_tick", "ema32_C", "alpha", "epsilon", "seen_set /* in-memory map: key->last_seen_tick */"],
			  "outputs": ["decision:{'accept'|'reject'}", "reason"],
			  "params": [],
			  "steps": [
				"1) Î”Ï„_phase := alpha * EMA32(C=ema32_C); W := 2 * Î”Ï„_phase.",
				"2) last := seen_set.get(key) or null.",
				"3) If within_window(last, now_tick, W, epsilon) is true:",
				"   3a) Increment counter 'seen_rejects'.",
				"   3b) Return decision='reject', reason='within_window'.",
				"4) Else:",
				"   4a) seen_set[key] := now_tick.",
				"   4b) Increment counter 'seen_accepts'.",
				"   4c) Return decision='accept', reason='outside_window'."
			  ]
			},
			"evict_lru_window": {
			  "id": 1.5.2.4,
			  "name": "evict_lru_window",
			  "role": "observer",
			  "inputs": ["seen_set /* key->last_seen_tick */", "now_tick", "max_entries"],
			  "outputs": ["seen_set"],
			  "params": ["lru_fraction := 0.10 /* evict 10% oldest when over cap */"],
			  "steps": [
				"1) If size(seen_set) <= max_entries, return seen_set.",
				"2) Sort entries by last_seen_tick ascending.",
				"3) evict_n := ceil(max(1, lru_fraction * size(seen_set))).",
				"4) Remove the first evict_n entries; increment 'window_resets' by evict_n.",
				"5) Return seen_set."
			  ]
			},
			"validate_envelope_structure": {
			  "id": 1.5.2.5,
			  "name": "validate_envelope_structure",
			  "role": "observer",
			  "inputs": ["payload_headers /* may include sig_type, provenance.origin */"],
			  "outputs": ["ok:boolean", "error?"],
			  "params": ["forbid_wrapped_unsigned := true"],
			  "steps": [
				"1) If forbid_wrapped_unsigned and payload_headers indicates an inner payload lacking structural sig_type markers, return (false,'wrapped_unsigned').",
				"2) If payload_headers.sig_type is present, ensure it matches a known structural form at L1 (no cryptography implied).",
				"3) Return (true,null) on structural conformance."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Hybrid policy: replay defense uses a moving window W=2Â·Î”Ï„_phase with LRU eviction when capacity is exceeded.",
			"I2 Determinism: key composition is stable (tenant_id + content_fingerprint [+ class_hint?]) with ASCII normalization.",
			"I3 Weak-field stability: as ð’žâ†’1, the window converges to a fixed W=2Î±, reducing jitter in admit decisions.",
			"I4 No control writes: SeenSetGuard is observer-class; it does not persist to external stores at Layer_1.",
			"I5 Structural guard: wrapped-unsigned payloads are rejected at L1 on structure alone; no cryptographic validation occurs.",
			"I6 Monotone counters: accepts, rejects, and window_resets are non-decreasing gauges over the observation interval."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"alpha": 1.0,
			"epsilon": 1,
			"scenario": [
			  {
				"case": "first_observation_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1000,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 0, "window_resets": 0 }
			  },
			  {
				"case": "duplicate_within_window_rejects",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1001,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "reject",
				"reason": "within_window",
				"counters_after": { "seen_accepts": 1, "seen_rejects": 1, "window_resets": 0 }
			  },
			  {
				"case": "outside_window_accepts",
				"tenant_id": "acme:A",
				"content_fingerprint": "f7e1b-42",
				"now_tick": 1003,
				"ema32_C": 0.90,
				"computed": { "Delta_tau_phase": 0.90, "W": 1.80 },
				"decision": "accept",
				"reason": "outside_window",
				"counters_after": { "seen_accepts": 2, "seen_rejects": 1, "window_resets": 0 }
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "seen_accepts", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "seen_rejects", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "window_resets", "range": "[0, +inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "replay_within_window_rate", "range": "[0, 1]", "units": "ratio", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0, +inf)", "units": "ticks", "window": "EMA-64" }
		  ],
		  "references": [
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal flow, decay, and replay framing for duplicate suppression" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 coherence homeostasis; EMA windows and stability of control surfaces" },
			{ "source": "RFC-0008", "clause": "Â§2â€“Â§3 exchange discipline; structural validation at ingress" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure and envelope fields (non-cryptographic at L1)" }
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		},
        "1.6": {
		  "id": 1.6,
		  "title": "CompressionEngine â€” compress-before-prune",
		  "objective": "Define an observer-class equivalence clustering process that yields a deterministic compression snapshot and emits lawful_compression_ratio and related KPIs before any prune is even considered at Layer_1.",
		  "math": [
			"id": 1.6.1,
			"title": "CompressionEngine: Math",
			"1.6.1.1": {
			  "id": 1.6.1.1,
			  "role": "equivalence and representatives",
			  "latex": "x \\sim y \\;\\Leftrightarrow\\; \\mathrm{key}(x)=\\mathrm{key}(y),\\quad \\mathcal{R}:=\\{\\text{representatives}\\},\\; N_{tot}:=|\\mathcal{X}|,\\; N_{rep}:=|\\mathcal{R}|",
			  "gloss": "Items belong to the same cluster if they share a deterministic key; one representative per cluster is retained in the snapshot."
			},
			"1.6.1.2": {
			  "id": 1.6.1.2,
			  "role": "compression ratio",
			  "latex": "L := \\mathrm{lawful\\_compression\\_ratio} := 1 - \\frac{N_{rep}}{N_{tot}} \\in [0,1]",
			  "gloss": "Fraction of removable duplication under the declared equivalence; 0 means no compressible redundancy."
			},
			"1.6.1.3": {
			  "id": 1.6.1.3,
			  "role": "glider-class canonicalization",
			  "latex": "\\mathrm{key}(x) := \\begin{cases} \\mathrm{canon}(x) & \\text{if glider\\_equivalence=ON}\\\\ \\mathrm{id}(x) & \\text{otherwise} \\end{cases}",
			  "gloss": "When shift-equivalence is enabled, keys map to the canonical class representative; this enforces idempotence."
			},
			"1.6.1.4": {
			  "id": 1.6.1.4,
			  "role": "pressure threshold (advisory, observer-class)",
			  "latex": "\\lambda_{eq} := \\min\\big(1,\\;\\mathrm{EMA}_{32}(\\rho_{res})\\cdot \\gamma_{co}\\big)",
			  "gloss": "Advisory threshold derived from residual occupancy (rho_res) and coherence gain (gamma_co); used only to annotate KPIs, not to trigger pruning at L1."
			},
			"1.6.1.5": {
			  "id": 1.6.1.5,
			  "role": "weak-field limit",
			  "latex": "\\lim_{\\mathcal{C}\\to 1}\\; L = 1 - \\frac{N_{rep}}{N_{tot}}\\;\\text{(stable)},\\quad \\lim_{\\mathcal{C}\\to 1}\\; \\lambda_{eq} = \\min(1,\\rho_{res}\\,\\gamma_{co})",
			  "gloss": "In the weak-field limit (high coherence), the snapshot is stable and advisory thresholds converge to fixed values."
			}
		  ],
		  "algorithms": [
			"id": 1.6.2,
			"title": "CompressionEngine: Algorithms",
			"build_equivalence_key": {
			  "id": 1.6.2.1,
			  "name": "build_equivalence_key",
			  "role": "observer",
			  "inputs": ["item", "feature_flags"],
			  "outputs": ["key"],
			  "params": ["normalize := ascii-lowercase", "ordering := lexicographic"],
			  "steps": [
				"1) Extract identity features from item (e.g., motif_id).",
				"2) If feature_flags.glider_equivalence=ON, map motif_id to its canonical class representative.",
				"3) Normalize key components to ASCII lowercase and join deterministically.",
				"4) Return key."
			  ]
			},
			"cluster_equivalence": {
			  "id": 1.6.2.2,
			  "name": "cluster_equivalence",
			  "role": "observer",
			  "inputs": ["items[]", "feature_flags"],
			  "outputs": ["clusters: map<key, list<item>>", "representatives: list<item>"],
			  "params": ["rep_selector := lexicographic-min by motif_id"],
			  "steps": [
				"1) For each item in items, k := build_equivalence_key(item, feature_flags); append item to clusters[k].",
				"2) For each k in clusters, choose representative := rep_selector(clusters[k]).",
				"3) Return clusters and the ordered list of representatives (sorted by key asc)."
			  ]
			},
			"compute_compression_snapshot": {
			  "id": 1.6.2.3,
			  "name": "compute_compression_snapshot",
			  "role": "observer",
			  "inputs": ["N_tot", "N_rep", "rho_res", "gamma_co"],
			  "outputs": ["snapshot"],
			  "params": [],
			  "steps": [
				"1) L := 1 - (N_rep / max(1, N_tot)).",
				"2) lambda_eq := min(1, EMA32(rho_res) * gamma_co).",
				"3) snapshot := { N_tot, N_rep, lawful_compression_ratio: L, lambda: lambda_eq }.",
				"4) Return snapshot."
			  ]
			},
			"emit_kpis_then_gate": {
			  "id": 1.6.2.4,
			  "name": "emit_kpis_then_gate",
			  "role": "observer",
			  "inputs": ["snapshot"],
			  "outputs": ["advice:{'observe_only'}", "kpis"],
			  "params": [],
			  "steps": [
				"1) Emit KPIs from snapshot (lawful_compression_ratio, N_rep, N_tot, lambda).",
				"2) Return advice='observe_only' to indicate that any prune decision lies outside Layer_1.",
				"3) End."
			  ]
			},
			"compression_pipeline": {
			  "id": 1.6.2.5,
			  "name": "compression_pipeline",
			  "role": "observer",
			  "inputs": ["items[]", "context:{rho_res, gamma_co, feature_flags}"],
			  "outputs": ["representatives[]", "snapshot", "advice"],
			  "params": [],
			  "steps": [
				"1) {clusters, representatives} := cluster_equivalence(items, feature_flags).",
				"2) snapshot := compute_compression_snapshot(N_tot=|items|, N_rep=|representatives|, rho_res, gamma_co).",
				"3) {advice, kpis} := emit_kpis_then_gate(snapshot).",
				"4) Return representatives (ordered), snapshot, advice."
			  ]
			}
		  ],
		  "invariants": [
			"I1 Capacity-first: a compression snapshot MUST be computed and emitted before any prune is considered.",
			"I2 Determinism: clustering keys and representative selection are lexicographically stable and ASCII-normalized.",
			"I3 Idempotence under gliders: with glider_equivalence=ON, class members collapse to a single canonical representative.",
			"I4 Observer posture: no items are deleted or mutated at Layer_1; outputs are snapshots and KPIs only.",
			"I5 Safety bounds: lawful_compression_ratio L is confined to [0,1] for all inputs, including degenerate N_tot âˆˆ {0,1}."
		  ],
		  "example_json": {
			"version": "2025-Q4",
			"psi_field": "Ïˆ-resonance@Îž",
			"glider_equivalence": "ON",
			"input": {
			  "items": [
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-spar@Îž", "class": "glider" },
				{ "motif_id": "Ïˆ-hold@Îž" },
				{ "motif_id": "Ïˆ-null@Îž" }
			  ],
			  "rho_res": 0.62,
			  "gamma_co": 0.8
			},
			"output": {
			  "representatives": [
				"Ïˆ-hold@Îž",
				"Ïˆ-null@Îž",
				"Ïˆ-spar@Îž"
			  ],
			  "snapshot": {
				"N_tot": 4,
				"N_rep": 3,
				"lawful_compression_ratio": 0.25,
				"lambda": 0.496
			  },
			  "advice": "observe_only"
			}
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0, 1]", "units": "ratio", "window": "EMA-32" },
			{ "metric": "clusters_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" },
			{ "metric": "representatives_count", "range": "[0, +inf)", "units": "count", "window": "EMA-16" }
		  ],
		  "references": [
			{ "source": "RFC-0006", "clause": "Â§3â€“Â§4 equivalence geometry and canonical representatives for class stability" },
			{ "source": "RFC-0009", "clause": "Â§5â€“Â§7 homeostasis and KPI discipline (EMA windows, bounded gauges)" },
			{ "source": "RFC-0005", "clause": "Â§3â€“Â§4 temporal stability assumptions for snapshotting in weak-field regimes" },
			{ "source": "PDP-0001", "clause": "Â§3â€“Â§4 provenance structure; observer-only outputs at L1" }
		  ],
		  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
		},
        "1.7": {
          "id": 1.7,
          "title": "ExportEnvelope â€” Î£/Î”/provenance on egress",
          "responsibilities": [
            "Attach Sigma_phase, Delta_hash chain, origin_hash when flags enabled",
            "Fail-closed if required fields missing"
          ]
        },
        "1.8": {
          "id": 1.8,
          "title": "LLMRecallController â€” budgets & injection defense",
          "responsibilities": [
            "Token budgets: max 8192, target 4096, reserve 512",
            "Strip control directives; tag source/confidence/timestamp"
          ]
        }
      ]
    },

    "2": {
      "id": 2,
      "title": "Pseudocode",
      "subsections": [
        "2.1": {
          "id": 2.1,
          "title": "Core Method Suite",
          "methods": [
            "recall(query, k=10, psi_field=None) -> items[]",
            "complete_dyad(m1, m2) -> {m3, provenance, evidence?}",
            "compress_snapshot() -> {ratio, clusters}",
            "export_packet(kind, body, provenance) -> {ok, envelope}"
          ]
        },
        "2.2": {
          "id": 2.2,
          "title": "Reef Adapter Methods",
          "methods": [
            "list_modules() -> modules[]",
            "list_motifs(module_id) -> motifs[]",
            "find(route) -> {file, line}",
            "window(file, line, radius) -> {snippet}",
            "cooccur(m1, m2) -> {candidates:[m3], evidence:[]}",
            "build_reflections(limit?, strategy?) -> {built, updated, skipped}"
          ]
        },
        "2.3": {
          "id": 2.3,
          "title": "Observability (local gauges)",
          "metrics": [
            "lawful_compression_ratio",
            "equivalence_efficiency",
            "reanchor_rate",
            "quarantine_count",
            "avg_replay_window_ticks",
            "glider_detected (if enabled)"
          ]
        }
      ]
    },

    "3": {
      "id": 3,
      "title": "Project-Local API Contracts (FastAPI stubs)",
      "note": "No RBAC in project mode; endpoints are local developer tools.",
      "openapi": "autogen"
    },

    "4": {
      "id": 4,
      "title": "Storage & Config (minimal, optional)",
      "notes": [
        "Reflections cache is optional; memory-only by default.",
        "If a table is present, persist (tenant_id,m1,m2)->m3 with support_count."
      ]
    },

    "5": {
      "id": 5,
      "title": "Compliance & Regeneration Constraints",
      "final_remarks": [
        "Capacity-first: compress-before-prune is mandatory.",
        "All dyad completions must expose provenance.",
        "Reef operations are read-only; archive is never mutated.",
        "Glider equivalence ON â†’ idempotent promotions."
      ],
      "regeneration_constraints": {
        "required_files": ["motif_memory_manager.py", "mmm_reef_adapter.py"],
        "rfc_compliance_required": true,
        "source_code_access": "prohibited during regeneration",
        "motif_integrity": "No artificial mutation; evidence windows must be attachable."
      }
    }
  ]
}
