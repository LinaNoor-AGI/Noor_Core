#
# MIT License
#
# Copyright (c) 2025 Noor Research Collective
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

"""
mmm_reef_adapter.py - Layer 2 Application for Reef Interaction

This module provides the necessary interfaces to read from and interpret the
Noor Reef Archives (index.REEF, TheReefArchive-*.REEF). It acts as a
read-only, observer-class adapter for the Motif Memory Manager, providing
context, evidence, and dyad completion candidates.

Generated by: Google Gemini Pro
Anchored in: MMM-APP-001 (v2.0.1_Gemini_A)
Dependencies:
- PDP-0001, RFC-0005, RFC-0006, RFC-0007, RFC-0008, RFC-0009, RFC-CORE-006
"""

import os
import glob
import json
import time
import logging
from pathlib import Path
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Tuple,
    NamedTuple,
    Set,
    Callable,
    Iterable,
)
from dataclasses import dataclass, field

# --- Configuration (per MMM-APP-001 §4) ---

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - [%(levelname)s] - %(message)s"
)

# Read from environment variables with specified defaults.
MMM_REEF_INDEX_PATH = os.getenv("MMM_REEF_INDEX_PATH", "noor_rfc_xref.json")
MMM_REEF_SHARDS_GLOB = os.getenv("MMM_REEF_SHARDS_GLOB", "RFC-*.JSON")
MMM_WINDOW_RADIUS = int(os.getenv("MMM_WINDOW_RADIUS", 24))
MMM_REFLECTIONS_LIMIT = int(os.getenv("MMM_REFLECTIONS_LIMIT", 50000))


# --- Data Structures (per RFCs) ---

@dataclass(frozen=True)
class EvidenceWindow:
    """
    Represents an evidence window pointer to a location in a Reef shard.
    Per MMM-APP-001 §_llm_controls.reef_evidence_policy and §1.3.
    """
    file: str
    start_line: int
    end_line: int


@dataclass
class Reflection:
    """
    Represents a cached dyad completion (m1, m2) -> m3.
    Per MMM-APP-001 §1.4.
    """
    m1: str
    m2: str
    m3: str
    provenance: str  # 'ontology', 'file_reflections', 'index_cooccur'
    support_count: int = 1
    first_seen_ts: float = field(default_factory=time.time)
    last_seen_ts: float = field(default_factory=time.time)
    evidence: List[EvidenceWindow] = field(default_factory=list)


# --- Core Components (as specified in MMM-APP-001) ---

class ReefIndexRouter:
    """
    Resolves modules, motifs, and anchors from the Reef Index (index.REEF).
    Acts as a read-only semantic map for the Motif Memory Manager.
    Anchored in MMM-APP-001 §1.2.
    """
    def __init__(self, index_path: str):
        self.index_path = Path(index_path)
        self._index_data: Dict[str, Any] = {}
        self._load_index()

    def _load_index(self):
        """Loads the index file."""
        try:
            with self.index_path.open('r', encoding='utf-8') as f:
                self._index_data = json.load(f)
            logging.info(f"Reef Index loaded successfully from {self.index_path}")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logging.error(f"Failed to load or parse Reef Index '{self.index_path}': {e}")
            self._index_data = {}

    def list_modules(self) -> List[Dict[str, str]]:
        """
        Lists all modules from the index. Per MMM-APP-001 §1.2.2.1.
        """
        modules = []
        index_list = self._index_data.get("_index", [])
        if not isinstance(index_list, list):
            return []
            
        for section in index_list:
            if isinstance(section, dict) and "section" in section and "title" in section:
                modules.append({"module_id": section["section"], "title": section["title"]})
        return modules

    def find_anchor(self, module_id: str) -> Optional[Dict[str, Any]]:
        """
        Finds the location for a given module_id.
        Returns the first URL as the file reference. Line numbers are not in the index.
        Per MMM-APP-001 §1.2.2.3.
        """
        sections_list = self._index_data.get("_sections", [])
        if not isinstance(sections_list, list) or not sections_list:
            return None

        sections_dict = sections_list[0]
        
        # Handle top-level protocols
        if module_id in sections_dict and isinstance(sections_dict.get(module_id), dict):
            return {"file": sections_dict[module_id].get("urls", [None])[0], "line": None}

        # Handle layered protocols
        for layer_key in ["layer_0", "layer_1", "layer_2"]:
            layer_list = sections_dict.get(layer_key)
            if not isinstance(layer_list, list):
                continue

            for item in layer_list:
                if isinstance(item, dict) and module_id in item:
                    rfc_data = item[module_id]
                    if isinstance(rfc_data, dict):
                        return {"file": rfc_data.get("urls", [None])[0], "line": None}
        return None

class ReefShardScanner:
    """
    Reads immutable Reef shards to return evidence windows and co-occurrence candidates.
    Anchored in MMM-APP-001 §1.3.
    """
    def __init__(self, shards_glob: str, default_radius: int):
        self.shards_glob = shards_glob
        self.default_radius = default_radius
        self.shard_paths = list(Path().glob(shards_glob))
        logging.info(f"Found {len(self.shard_paths)} shards for glob pattern '{shards_glob}'.")

    def window(self, file: str, line: int, radius: Optional[int] = None, coherence_C: float = 1.0) -> Optional[EvidenceWindow]:
        """
        Extracts an EvidenceWindow pointer. The radius is adaptive to coherence.
        Per MMM-APP-001 §1.3.2.1 and §2.2.1.2 (adaptive radius).
        """
        # Adaptive radius based on coherence, per spec §2.2.1.2
        # R = min(R_max, floor(EMA16(C)) + 1)
        # Using a simplified version here, as we don't maintain EMA state.
        adaptive_radius = min(48, int(coherence_C * (radius if radius is not None else self.default_radius)) + 1)
        
        target_path = Path(file)
        if not target_path.exists():
            logging.warning(f"Shard file not found: {file}")
            return None

        try:
            with target_path.open('r', encoding='utf-8') as f:
                line_count = sum(1 for _ in f)
            
            start_line = max(1, line - adaptive_radius)
            end_line = min(line_count, line + adaptive_radius)

            return EvidenceWindow(file=str(target_path), start_line=start_line, end_line=end_line)
        except IOError as e:
            logging.error(f"Could not read shard {file}: {e}")
            return None

class ReefReflectionsCache:
    """
    Observer-class cache for dyad completions, following ontology-first evidence.
    Anchored in MMM-APP-001 §1.4.
    """
    def __init__(self, limit: int, feature_flags: Dict[str, bool]):
        self._cache: Dict[Tuple[str, str], Reflection] = {}
        self._limit = limit
        self._glider_equivalence_on = feature_flags.get("enable_point_space_gliders", True)
        self._provenance_priority = {'ontology': 3, 'file_reflections': 2, 'index_cooccur': 1}
        logging.info(f"ReefReflectionsCache initialized with limit={limit}, glider_equivalence={self._glider_equivalence_on}.")

    def _canonicalize_pair(self, m1: str, m2: str) -> Tuple[str, str]:
        """Per §1.4.2.1, normalizes a motif pair to a canonical key."""
        if self._glider_equivalence_on:
            # Placeholder for mapping to canonical class representatives
            m1_canon, m2_canon = m1, m2
            return tuple(sorted((m1_canon, m2_canon)))
        return tuple(sorted((m1, m2)))
        
    def complete_dyad(self, m1: str, m2: str) -> Optional[Reflection]:
        """
        Completes a dyad (m1, m2) -> m3 using cache-first, then build-once logic.
        This is a high-level stub as building reflections is complex and out of scope for a single file generation.
        Per MMM-APP-001 §1.4.2.5.
        """
        key = self._canonicalize_pair(m1, m2)
        if key in self._cache:
            self._cache[key].last_seen_ts = time.time()
            return self._cache[key]
        
        # In a full implementation, this would trigger `build_reflections_once`.
        # For this demonstration, we acknowledge it's a cache-miss.
        logging.info(f"Cache miss for dyad ({m1}, {m2}). Build logic is external.")
        return None

# End_of_File