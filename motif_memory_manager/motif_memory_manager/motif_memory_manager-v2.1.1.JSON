{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_type": "application_spec",
  "_pdp_layer": "layer_2",
  "_status": "DRAFT",
  "_language": "json",
  "_license": "MIT",

  "_title": "Motif Memory Manager (MMM)",
  "_subtitle": "Capacity-first symbolic memory with provenance, integrity, and Reef exchange surfaces",
  "_version": "v2.1.1",
  "_symbolic_id": "memory.motif.manager",

  "_authors": [
    "Lina Noor — Noor Research Collective",
    "Uncle — Noor Research Collective"
  ],

  "_extends": [
    "RFC-0003",
    "RFC-0004",
    "RFC-0005",
    "RFC-0006",
    "RFC-0007",
    "RFC-CORE-001",
    "RFC-CORE-002",
    "RFC-CORE-003"
  ],

  "_rfc_dependencies": [
    "RFC-0003 §6.2",
    "RFC-0004 §2.5",
    "RFC-0004 §3.2",
    "RFC-0005 §3–4",
    "RFC-0006 §3.1",
    "RFC-CORE-001 §6.2",
    "RFC-CORE-002 §3–4",
    "RFC-CORE-003 §3.1"
  ],

  "_poetic_cipher": "Remember lightly, verify heavily.",
  "_cipher_explanation": "MMM prefers lawful compression and verifiable recall over maximal retention; all exports carry provenance and integrity tags.",

  "programs": ["motif_memory_manager.py", "mmm_reef_adapter.py"],

  "compat_flags": {
    "enable_exchange_envelope": true,
    "enable_integrity_checks": true,
    "enable_provenance_on_export": true,
    "enable_point_space_gliders": true
  },

  "_field_alignment": {
    "respect_modes": ["ψ-null@Ξ", "ψ-resonance@Ξ", "ψ-hold@Ξ", "ψ-spar@Ξ"],
    "prohibited_actions": [
      "intent-mutation",
      "field-spoofing",
      "unauthorized-ghost-rewrite"
    ]
  },

  "_file_layout": [
    {
      "file_name": "motif_memory_manager.py",
      "purpose": "Implements MMM core (ingest, index, recall, compression, retention policy, provenance, integrity)."
    },
    {
      "file_name": "mmm_reef_adapter.py",
      "purpose": "Adapter to Reef archives and evidence windows; translates MMM packets to Reef Exchange Envelope."
    }
  ],

  "index": [
    { "section": "1", "title": "Module-Level Constants & Flags" },
    { "section": "2", "title": "External and Optional Dependencies" },
    { "section": "3", "title": "Wire Formats & Exchange Envelope" },
    { "section": "4", "title": "Data Models (Dataclasses)" },
    { "section": "4.1", "title": "MotifTrace" },
    { "section": "4.2", "title": "MemoryShard" },
    { "section": "4.3", "title": "ProvenanceStamp" },
    { "section": "4.4", "title": "IntegritySeal" },
    { "section": "4.5", "title": "RecallQuery / RecallResult" },
    { "section": "5", "title": "Helper Structures" },
    { "section": "5.1", "title": "LRUWindow" },
    { "section": "5.2", "title": "CountMinSketch" },
    { "section": "5.3", "title": "TriagedQueue (hot/warm/cold)" },
    { "section": "6", "title": "Classes" },
    { "section": "6.1", "title": "MotifMemoryManager (MMM)" },
    { "section": "6.1.1", "title": "Constraints — Intent & RFC Hygiene" },
    { "section": "6.1.2", "title": "Methods — Ingest / Recall / Compact / Export" },
    { "section": "6.2", "title": "MMMReefAdapter" },
    { "section": "7", "title": "Policies" },
    { "section": "7.1", "title": "Retention & Compaction" },
    { "section": "7.2", "title": "Provenance Policy" },
    { "section": "7.3", "title": "Integrity & Evidence Windows" },
    { "section": "8", "title": "Observability & Metrics" },
    { "section": "9", "title": "Mermaid Diagrams" },
    { "section": "10", "title": "End-of-File" }
  ],

  "sections": [
    {
      "id": "1",
      "title": "Module-Level Constants & Flags",
      "constants": {
        "__version__": "2.1.0",
        "_SCHEMA_VERSION__": "2025-Q4-mmm-v2.1.0",
        "SCHEMA_COMPAT": ["RFC-0003:6.2", "RFC-0004:2.5", "RFC-CORE-002:3"],
        "DEFAULT_LIMITS": {
          "max_hot": 2048,
          "max_warm": 65536,
          "max_cold": 524288,
          "max_trace_len": 64
        },
        "PROVENANCE_ALGO": "sha3_256",
        "INTEGRITY_HMAC": "sha3_256"
      },
      "flags": {
        "enable_exchange_envelope": true,
        "enable_integrity_checks": true,
        "enable_provenance_on_export": true,
        "enable_point_space_gliders": true
      }
    },

    {
      "id": "2",
      "title": "External and Optional Dependencies",
      "dependencies": {
        "required": [
          "time", "hashlib", "logging", "threading",
          { "package": "collections", "imports": ["deque", "Counter", "OrderedDict"] },
          { "package": "typing", "imports": ["Any", "Optional", "List", "Dict", "Tuple"] },
          { "package": "dataclasses", "imports": ["dataclass", "field"] }
        ],
        "optional": [
          { "package": "numpy", "fallback_on_import_error": { "assignments": ["np=None"] } },
          { "package": "prometheus_client", "fallback_on_import_error": { "assignments": ["Counter=_Stub", "Gauge=_Stub"] } }
        ],
        "local_imports": [
          { "from": "symbolic_task_engine", "imports": ["SymbolicTaskEngine"], "optional": true },
          { "from": "consciousness_monitor", "imports": ["get_global_monitor"], "optional": true }
        ]
      }
    },

    {
      "id": "3",
      "title": "Wire Formats & Exchange Envelope",
      "exchange_envelope": {
        "enabled_by": "compat_flags.enable_exchange_envelope",
        "schema": {
          "envelope.intent": {
            "type": "str",
            "rfc": ["RFC-0004 §2.5", "RFC-0003 §6.2"],
            "constraints": ["MUST mirror from upstream; MUST NOT mutate in MMM."]
          },
          "envelope.phase": { "type": "str", "example": "ψ-resonance@Ξ" },
          "envelope.timestamp": { "type": "float", "units": "unix-seconds" },
          "payload": { "type": "object", "description": "MotifTrace or RecallResult" },
          "provenance": { "type": "ProvenanceStamp" },
          "integrity": { "type": "IntegritySeal" }
        }
      },
      "pseudocode": [
        "def attach_envelope(payload, upstream_intent, phase, secret=None):",
        "    env = {",
        "      'envelope': { 'intent': upstream_intent, 'phase': phase, 'timestamp': time.time() },",
        "      'payload': payload,",
        "      'provenance': make_provenance(payload),",
        "      'integrity': make_integrity(payload, secret) if secret else None",
        "    }",
        "    return env"
      ]
    },

    {
      "id": "4",
      "title": "Data Models (Dataclasses)",
      "dataclasses": [
        {
          "id": "4.1",
          "name": "MotifTrace",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "trace_id", "type": "str" },
            { "name": "motifs", "type": "List[str]" },
            { "name": "field_signature", "type": "str", "default": "ψ-null@Ξ" },
            { "name": "timestamp", "type": "float" },
            { "name": "extensions", "type": "Dict[str, Any]", "default_factory": "dict",
              "meta": { "reserved": ["intent"] } }
          ],
          "constraints": [
            "extensions.intent MUST be a pass-through from upstream; no defaulting."
          ]
        },
        {
          "id": "4.2",
          "name": "MemoryShard",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "level", "type": "str", "enum": ["hot", "warm", "cold"] },
            { "name": "items", "type": "Dict[str, MotifTrace]", "default_factory": "dict" },
            { "name": "evictions", "type": "int", "default": 0 }
          ]
        },
        {
          "id": "4.3",
          "name": "ProvenanceStamp",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "algo", "type": "str", "default": "sha3_256" },
            { "name": "content_hash", "type": "str" },
            { "name": "created_at", "type": "float" }
          ]
        },
        {
          "id": "4.4",
          "name": "IntegritySeal",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "algo", "type": "str", "default": "sha3_256" },
            { "name": "hmac", "type": "str" },
            { "name": "salt", "type": "str" }
          ]
        },
        {
          "id": "4.5",
          "name": "RecallQuery",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "keys", "type": "List[str]" },
            { "name": "top_k", "type": "int", "default": 3 },
            { "name": "phase_hint", "type": "Optional[str]", "default": null }
          ]
        },
        {
          "id": "4.6",
          "name": "RecallResult",
          "decorators": [{ "name": "dataclass", "args": ["slots=True"] }],
          "fields": [
            { "name": "items", "type": "List[MotifTrace]" },
            { "name": "provenance", "type": "ProvenanceStamp" },
            { "name": "integrity", "type": "Optional[IntegritySeal]", "default": null }
          ]
        }
      ]
    },

    {
      "id": "5",
      "title": "Helper Structures",
      "helpers": [
        {
          "id": "5.1",
          "name": "LRUWindow",
          "description": "OrderedDict with cap; promotes on access; evicts oldest."
        },
        {
          "id": "5.2",
          "name": "CountMinSketch",
          "description": "Approximate frequency tracker for motif IDs; supports decay."
        },
        {
          "id": "5.3",
          "name": "TriagedQueue",
          "description": "Three-tier queue (hot/warm/cold) with hysteresis thresholds."
        }
      ],
      "pseudocode": [
        "# LRUWindow (eviction on insert)",
        "def lru_set(win, key, value, cap):",
        "    if key in win: del win[key]",
        "    win[key] = value",
        "    if len(win) > cap: win.popitem(last=False)"
      ]
    },

    {
      "id": "6",
      "title": "Classes"
    },

    {
      "id": "6.1",
      "title": "MotifMemoryManager (MMM)",
      "inherits": [],
      "class_attributes": [
        { "name": "INGEST_TOTAL", "type": "Counter", "args": ["'mmm_ingest_total'", "'Traces ingested'", "['level']"] },
        { "name": "RECALL_TOTAL", "type": "Counter", "args": ["'mmm_recall_total'", "'Recall attempts'", "['result']"] },
        { "name": "EXPORT_TOTAL", "type": "Counter", "args": ["'mmm_export_total'", "'Packets exported'", "['kind']"] }
      ],
      "buffers": [
        { "name": "_hot", "kind": "LRUWindow", "capacity": "DEFAULT_LIMITS.max_hot" },
        { "name": "_warm", "kind": "LRUWindow", "capacity": "DEFAULT_LIMITS.max_warm" },
        { "name": "_cold", "kind": "LRUWindow", "capacity": "DEFAULT_LIMITS.max_cold" }
      ],
      "constraints": {
        "id": "6.1.1",
        "title": "Constraints — Intent & RFC Hygiene",
        "MUST": [
          "Mirror envelope.intent to trace.extensions.intent when provided; no defaulting (RFC-0004 §2.5).",
          "Maintain provenance on export when enable_provenance_on_export=true.",
          "Attach integrity seals when enable_integrity_checks=true."
        ],
        "MUST_NOT": [
          "Mutate or infer intent.",
          "Write intent to long-term shards unless explicitly present."
        ],
        "SHOULD": [
          "Prefer lawful compression and phase-aware recall.",
          "Decay counts; avoid unbounded growth."
        ]
      },
      "methods": [
        {
          "id": "6.1.2.1",
          "name": "__init__",
          "signature": ["self", "limits: Optional[Dict[str,int]]=None", "secret: Optional[bytes]=None"],
          "logic_flow": [
            "self.limits = {**DEFAULT_LIMITS, **(limits or {})}",
            "init _hot/_warm/_cold windows",
            "init sketches/counters",
            "self.secret = secret"
          ]
        },
        {
          "id": "6.1.2.2",
          "name": "ingest",
          "signature": ["self", "trace: MotifTrace", "level: str='hot'"],
          "rfc_anchors": ["RFC-CORE-002 §3"],
          "pseudocode": [
            "def ingest(trace, level='hot'):",
            "  assert level in {'hot','warm','cold'}",
            "  trace.motifs = trace.motifs[:DEFAULT_LIMITS.max_trace_len]",
            "  shard = {'hot': self._hot, 'warm': self._warm, 'cold': self._cold}[level]",
            "  lru_set(shard, trace.trace_id, trace, self.limits[f'max_{level}'])",
            "  self.INGEST_TOTAL.labels(level=level).inc()",
            "  update_sketch(trace.motifs)"
          ]
        },
        {
          "id": "6.1.2.3",
          "name": "recall",
          "signature": ["self", "query: RecallQuery"],
          "pseudocode": [
            "def recall(q):",
            "  cands = gather_candidates(q.keys, tiers=[_hot,_warm,_cold])",
            "  scored = score_phase_aware(cands, q.phase_hint)",
            "  top = sorted(scored, key=lambda x: -x.score)[:q.top_k]",
            "  prov = make_provenance(top)",
            "  integ = make_integrity(top, self.secret) if self.secret else None",
            "  return RecallResult(items=[t for t,_ in top], provenance=prov, integrity=integ)"
          ]
        },
        {
          "id": "6.1.2.4",
          "name": "compact",
          "signature": ["self"],
          "description": "Demote least-recent hot→warm; warm→cold using decay and usage.",
          "pseudocode": [
            "def compact():",
            "  demote_by_pressure(_hot-> _warm); demote_by_pressure(_warm-> _cold)",
            "  drop_cold_if_overflow()"
          ]
        },
        {
          "id": "6.1.2.5",
          "name": "export_packet",
          "signature": ["self", "result_or_trace: Any", "upstream_intent: Optional[str]", "phase: str"],
          "pseudocode": [
            "payload = as_payload(result_or_trace)",
            "if compat.enable_provenance_on_export: prov = make_provenance(payload)",
            "else: prov = None",
            "integ = make_integrity(payload, self.secret) if compat.enable_integrity_checks and self.secret else None",
            "return attach_envelope(payload, upstream_intent, phase, self.secret)"
          ]
        }
      ]
    },

    {
      "id": "6.2",
      "title": "MMMReefAdapter",
      "purpose": "Bridges MMM payloads into Reef archives and back (evidence windows, replay defense).",
      "constraints": {
        "MUST": [
          "Respect Reef evidence window bounds.",
          "Refuse imports with failed integrity or mismatched provenance."
        ]
      },
      "methods": [
        {
          "id": "6.2.1",
          "name": "to_reef_record",
          "signature": ["self", "trace_or_result: Any"],
          "pseudocode": [
            "normalize to {kind:'trace'|'recall', data:..., stamps:{prov, integ}}"
          ]
        },
        {
          "id": "6.2.2",
          "name": "from_reef_record",
          "signature": ["self", "record: Dict[str,Any]"],
          "pseudocode": [
            "verify integrity; verify provenance; enforce window; map back to MMM types"
          ]
        }
      ]
    },

    {
      "id": "7",
      "title": "Policies"
    },
    {
      "id": "7.1",
      "title": "Retention & Compaction",
      "policy": {
        "hot_to_warm_threshold": "LRU age > A or freq < f_hot_min",
        "warm_to_cold_threshold": "LRU age > B or freq < f_warm_min",
        "cold_drop": "size > max_cold and freq < f_cold_min"
      }
    },
    {
      "id": "7.2",
      "title": "Provenance Policy",
      "pseudocode": [
        "def make_provenance(payload):",
        "  blob = stable_encode(payload)",
        "  return ProvenanceStamp(algo='sha3_256', content_hash=sha3_256(blob), created_at=time.time())"
      ]
    },
    {
      "id": "7.3",
      "title": "Integrity & Evidence Windows",
      "pseudocode": [
        "def make_integrity(payload, secret):",
        "  salt = gen_salt()",
        "  return IntegritySeal(algo='sha3_256', hmac=hmac_sha3_256(secret, payload, salt), salt=salt)",
        "",
        "def within_window(ts, now, window_s):",
        "  return (now - ts) <= window_s"
      ]
    },

    {
      "id": "8",
      "title": "Observability & Metrics",
      "metrics": [
        "mmm_ingest_total{level}",
        "mmm_recall_total{result}",
        "mmm_export_total{kind}",
        "mmm_shard_sizes{level}",
        "mmm_evictions_total{level}"
      ],
      "pseudocode": [
        "def report_sizes():",
        "  sizes = { 'hot': len(_hot), 'warm': len(_warm), 'cold': len(_cold) }",
        "  gauges.update(sizes)"
      ]
    },

    {
      "id": "9",
      "title": "Mermaid Diagrams",
      "diagrams": [
        {
          "name": "Architecture",
          "mermaid": "```mermaid\\nflowchart TD\\n  A[Upstream Envelope] -->|intent pass-through| B[MMM Ingest]\\n  B --> C{Triaged Shards}\\n  C -->|LRU/freq| H[Hot]\\n  C -->|decay| W[Warm]\\n  C -->|overflow| D[Cold]\\n  H --> R[Recall]\\n  W --> R\\n  D --> R\\n  R --> E[Export Packet]\\n  E -->|provenance+integrity| Reef[(Reef Archive)]\\n```"
        },
        {
          "name": "Recall Path",
          "mermaid": "```mermaid\\nsequenceDiagram\\n  participant Agent\\n  participant MMM\\n  participant Reef\\n  Agent->>MMM: RecallQuery(keys, top_k, phase_hint)\\n  MMM->>MMM: Gather candidates (hot/warm/cold)\\n  MMM->>MMM: Phase-aware scoring\\n  MMM-->>Agent: RecallResult + stamps\\n  Agent->>Reef: Optional export via Adapter\\n```"
        }
      ]
    },

    {
      "id": "10",
      "title": "End-of-File"
    }
  ]
}
